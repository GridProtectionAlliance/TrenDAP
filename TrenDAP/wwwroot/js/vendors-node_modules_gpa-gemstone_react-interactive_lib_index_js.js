"use strict";
(self["webpackChunktrendap"] = self["webpackChunktrendap"] || []).push([["vendors-node_modules_gpa-gemstone_react-interactive_lib_index_js"],{

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/ConfigurableTable.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/ConfigurableTable.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// ******************************************************************************************************
//  ConfigurableTable.tsx - Gbtc
//
//  Copyright © 2021, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  09/15/2021 - Christoph Lackner
//       Generated original version of source code.
// ******************************************************************************************************
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var Modal_1 = __webpack_require__(/*! ./Modal */ "./node_modules/@gpa-gemstone/react-interactive/lib/Modal.js");
var react_table_1 = __webpack_require__(/*! @gpa-gemstone/react-table */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/index.js");
/**
 * Table with modal to show and hide collumns
 */
function ConfigurableTable(props) {
    var _a = React.useState(false), showSettings = _a[0], setShowSettings = _a[1];
    var _b = React.useState(props.cols), collumns = _b[0], setCollumns = _b[1];
    var _c = React.useState(props.cols.map(function (d) { return d.key; })), colKeys = _c[0], setColKeys = _c[1];
    var _d = React.useState(props.cols.map(function (d) { return props.defaultColumns.findIndex(function (v) { return v === d.key; }) > -1 ||
        (props.requiredColumns !== undefined && props.requiredColumns.findIndex(function (v) { return v === d.key; }) > -1); })), colEnabled = _d[0], setColEnabled = _d[1];
    React.useEffect(function () {
        if (props.cols.length !== colEnabled.length)
            setColEnabled(props.cols.map(function (d) { return props.defaultColumns.findIndex(function (v) { return v === d.key; }) > -1 || (props.requiredColumns !== undefined && props.requiredColumns.findIndex(function (v) { return v === d.key; }) > -1); }));
    }, [props.cols]);
    React.useEffect(function () {
        setColKeys(props.cols.map(function (d) { return d.key; }));
    }, [props.cols]);
    React.useEffect(function () {
        setCollumns(props.cols.filter(function (c, i) { return colEnabled[i]; }));
    }, [colEnabled]);
    function changeCollums(index) {
        setColEnabled(function (d) { return d.map(function (c, i) { return (i === index ? !c : c); }); });
    }
    return (React.createElement(React.Fragment, null,
        React.createElement(react_table_1.default, { cols: __spreadArray(__spreadArray([], collumns, true), [{ key: 'SettingsCog', label: React.createElement("div", { style: { marginLeft: -25 } }, "SVGIcons.Settings"), headerStyle: { width: 30, padding: 0, verticalAlign: 'middle', textAlign: 'right' }, rowStyle: { padding: 0, width: 30 } }], false), data: props.data, onClick: props.onClick, sortKey: props.sortKey, ascending: props.ascending, onSort: function (d) { if (d.colKey === 'SettingsCog')
                setShowSettings(true);
            else
                props.onSort(d); }, tableClass: props.tableClass, tableStyle: props.tableStyle, theadStyle: props.theadStyle, theadClass: props.theadClass, tbodyStyle: props.tbodyStyle, tbodyClass: props.tbodyClass, selected: props.selected, rowStyle: props.rowStyle, keySelector: props.keySelector }),
        React.createElement(Modal_1.default, { Title: 'Table Columns', Show: showSettings, ShowX: true, ShowCancel: false, CallBack: function (conf) {
                setShowSettings(false);
                if (conf)
                    setColEnabled(props.cols.map(function (d) { return props.defaultColumns.findIndex(function (v) { return v === d.key; }) > -1 ||
                        (props.requiredColumns !== undefined && props.requiredColumns.findIndex(function (v) { return v === d.key; }) > -1); }));
            }, ConfirmText: 'Reset Defaults' },
            React.createElement("div", null,
                React.createElement("form", null,
                    React.createElement("ul", { style: { listStyleType: 'none', padding: 0, width: '100%', position: 'relative', float: 'left' } }, colKeys.map(function (k, i) { return (props.requiredColumns === undefined || props.requiredColumns.findIndex(function (v) { return v === k; }) === -1 ?
                        React.createElement("li", { key: k },
                            React.createElement("label", null,
                                React.createElement("input", { type: "checkbox", onChange: function () { return changeCollums(i); }, checked: colEnabled[i] }),
                                " ",
                                k,
                                " ")) : null); })))))));
}
exports["default"] = ConfigurableTable;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/BooleanFilter.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/BooleanFilter.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BooleanFilter = void 0;
// ******************************************************************************************************
//  BooleanFilter.tsx - Gbtc
//
//  Copyright © 2022, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/02/2022 - C. Lackner
//       Generated original version of source code.
// ******************************************************************************************************
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
function BooleanFilter(props) {
    var _a = React.useState(false), selected = _a[0], setSelected = _a[1];
    var _b = React.useState(false), notSelected = _b[0], setNotSelected = _b[1];
    React.useEffect(function () {
        if (props.Filter.length === 0) {
            setSelected(true);
            setNotSelected(true);
            return;
        }
        setSelected(props.Filter[0].SearchText === '1');
        setNotSelected(props.Filter[0].SearchText !== '1');
    }, [props.Filter]);
    React.useEffect(function () {
        if (!selected && !notSelected) {
            setSelected(true);
            setNotSelected(true);
        }
    }, [selected, notSelected]);
    React.useEffect(function () {
        if (selected && !notSelected && (props.Filter.length === 0 || props.Filter[0].SearchText !== '1')) {
            props.SetFilter([{ FieldName: props.FieldName, isPivotColumn: false, SearchText: '1', Operator: '=', Type: 'boolean' }]);
        }
        if (!selected && notSelected && (props.Filter.length === 0 || props.Filter[0].SearchText !== '0')) {
            props.SetFilter([{ FieldName: props.FieldName, isPivotColumn: false, SearchText: '0', Operator: '=', Type: 'boolean' }]);
        }
        if (selected && notSelected && props.Filter.length > 0)
            props.SetFilter([]);
    }, [selected, notSelected]);
    return React.createElement(React.Fragment, null,
        React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); setSelected(function (s) { return !s; }); } },
            React.createElement("td", null,
                React.createElement("input", { type: "checkbox", checked: selected, onChange: function () { return null; } })),
            React.createElement("td", null, "Selected")),
        React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); setNotSelected(function (v) { return !v; }); } },
            React.createElement("td", null,
                React.createElement("input", { type: "checkbox", checked: notSelected, onChange: function () { return null; } })),
            React.createElement("td", null, "Not Selected")));
}
exports.BooleanFilter = BooleanFilter;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/DateTimeFilters.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/DateTimeFilters.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  DateTimeFilters.tsx - Gbtc
//
//  Copyright © 2022, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/02/2022 - C Lackner
//       Generated original version of source code.
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeFilter = exports.DateFilter = void 0;
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
function DateFilter(props) {
    var _a = React.useState(''), date = _a[0], setDate = _a[1];
    var _b = React.useState(''), secondDate = _b[0], setSecondDate = _b[1];
    var _c = React.useState('after'), operator = _c[0], setOperator = _c[1];
    React.useEffect(function () {
        if (props.Filter.length === 0) {
            setDate('');
            setSecondDate('');
        }
        if (props.Filter.length > 1) {
            var f1 = props.Filter.find(function (f) { return f.Operator === '>' || f.Operator === '>='; });
            if (f1 == null)
                setDate('');
            else
                setDate(f1.SearchText);
            var f2 = props.Filter.find(function (f) { return f.Operator === '<' || f.Operator === '<='; });
            if (f2 == null)
                setSecondDate('');
            else
                setSecondDate(f2.SearchText);
        }
        if (props.Filter.length === 1) {
            setSecondDate('');
            if (props.Filter[0].Operator === '>' || props.Filter[0].Operator === '>=')
                setOperator('after');
            else
                setOperator('before');
            setDate(props.Filter[0].SearchText);
        }
    }, [props.Filter]);
    React.useEffect(function () {
        if (date === '' && secondDate === '' && props.Filter.length !== 0)
            props.SetFilter([]);
        if (date === '' && secondDate === '')
            return;
        if (operator === 'between') {
            props.SetFilter([
                {
                    FieldName: props.FieldName,
                    isPivotColumn: false,
                    Operator: '>=',
                    Type: 'datetime',
                    SearchText: date
                },
                {
                    FieldName: props.FieldName,
                    isPivotColumn: false,
                    Operator: '<=',
                    Type: 'datetime',
                    SearchText: secondDate
                }
            ]);
        }
        else {
            props.SetFilter([{
                    FieldName: props.FieldName,
                    isPivotColumn: false,
                    Operator: (operator === 'after' ? '>' : '<'),
                    Type: 'datetime',
                    SearchText: date
                }]);
        }
    }, [operator, date, secondDate]);
    return React.createElement(React.Fragment, null,
        React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
            React.createElement("td", null,
                React.createElement("select", { className: 'form-control', value: operator, onChange: function (evt) {
                        var value = evt.target.value;
                        setOperator(value);
                    } },
                    React.createElement("option", { value: 'before' }, "Before"),
                    React.createElement("option", { value: 'after' }, "After"),
                    React.createElement("option", { value: 'between' }, "Between")))),
        React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
            React.createElement("td", null,
                React.createElement("input", { type: 'date', className: 'form-control', value: date, onChange: function (evt) {
                        var value = evt.target.value;
                        setDate(value);
                    } }))),
        operator === 'between' ? React.createElement(React.Fragment, null,
            React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
                React.createElement("td", null, "and")),
            React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
                React.createElement("td", null,
                    React.createElement("input", { type: 'date', className: 'form-control', value: secondDate, onChange: function (evt) {
                            var value = evt.target.value;
                            setSecondDate(value);
                        } })))) : null);
}
exports.DateFilter = DateFilter;
function TimeFilter(props) {
    var _a = React.useState(''), time = _a[0], setTime = _a[1];
    var _b = React.useState(''), secondTime = _b[0], setSecondTime = _b[1];
    var _c = React.useState('after'), operator = _c[0], setOperator = _c[1];
    React.useEffect(function () {
        if (props.Filter.length === 0) {
            setTime('');
            setSecondTime('');
        }
        if (props.Filter.length > 1) {
            var f1 = props.Filter.find(function (f) { return f.Operator === '>' || f.Operator === '>='; });
            if (f1 == null)
                setTime('');
            else
                setTime(f1.SearchText);
            var f2 = props.Filter.find(function (f) { return f.Operator === '<' || f.Operator === '<='; });
            if (f2 == null)
                setSecondTime('');
            else
                setSecondTime(f2.SearchText);
        }
        if (props.Filter.length === 1) {
            setSecondTime('');
            if (props.Filter[0].Operator === '>' || props.Filter[0].Operator === '>=')
                setOperator('after');
            else
                setOperator('before');
            setTime(props.Filter[0].SearchText);
        }
    }, [props.Filter]);
    React.useEffect(function () {
        if (time === '' && secondTime === '' && props.Filter.length !== 0)
            props.SetFilter([]);
        if (time === '' && secondTime === '')
            return;
        if (operator === 'between') {
            props.SetFilter([
                {
                    FieldName: props.FieldName,
                    isPivotColumn: false,
                    Operator: '>=',
                    Type: 'datetime',
                    SearchText: time
                },
                {
                    FieldName: props.FieldName,
                    isPivotColumn: false,
                    Operator: '<=',
                    Type: 'datetime',
                    SearchText: secondTime
                }
            ]);
        }
        else {
            props.SetFilter([{
                    FieldName: props.FieldName,
                    isPivotColumn: false,
                    Operator: (operator === 'after' ? '>' : '<'),
                    Type: 'datetime',
                    SearchText: time
                }]);
        }
    }, [operator, time, secondTime]);
    return React.createElement(React.Fragment, null,
        React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
            React.createElement("td", null,
                React.createElement("select", { className: 'form-control', value: operator, onChange: function (evt) {
                        var value = evt.target.value;
                        setOperator(value);
                    } },
                    React.createElement("option", { value: 'before' }, "Before"),
                    React.createElement("option", { value: 'after' }, "After"),
                    React.createElement("option", { value: 'between' }, "Between")))),
        React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
            React.createElement("td", null,
                React.createElement("input", { type: 'time', className: 'form-control', value: time, onChange: function (evt) {
                        var value = evt.target.value;
                        setTime(value);
                    } }))),
        operator === 'between' ? React.createElement(React.Fragment, null,
            React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
                React.createElement("td", null, "and")),
            React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
                React.createElement("td", null,
                    React.createElement("input", { type: 'time', className: 'form-control', value: secondTime, onChange: function (evt) {
                            var value = evt.target.value;
                            setSecondTime(value);
                        } })))) : null);
}
exports.TimeFilter = TimeFilter;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/EnumFilter.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/EnumFilter.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnumFilter = void 0;
// ******************************************************************************************************
//  EnumFilter.tsx - Gbtc
//
//  Copyright © 2022, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/02/2022 - C Lackner
//       Generated original version of source code.
// ******************************************************************************************************
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
function EnumFilter(props) {
    var _a = React.useState([]), options = _a[0], setOptions = _a[1];
    React.useEffect(function () {
        setOptions(props.Options.map(function (item) { return (__assign(__assign({}, item), { Selected: true })); }));
    }, [props.Options]);
    React.useEffect(function () {
        if (props.Filter.length !== 0 && (options.filter(function (x) { return x.Selected; }).length === options.length || options.filter(function (x) { return !x.Selected; }).length === options.length)) {
            props.SetFilter([]);
            return;
        }
        if (options.some(function (item) { return !item.Selected; }))
            props.SetFilter([{
                    FieldName: props.FieldName,
                    isPivotColumn: false,
                    Operator: 'IN',
                    Type: 'enum',
                    SearchText: "(" + options.filter(function (o) { return o.Selected; }).map(function (x) { return x.Value; }).join(',') + ")"
                }]);
    }, [options]);
    React.useEffect(function () {
        if (props.Filter.length === 0)
            setOptions(function (opt) { return opt.map(function (item) { return (__assign(__assign({}, item), { Selected: true })); }); });
        else {
            var list_1 = props.Filter[0].SearchText.replace('(', '').replace(')', '').split(',');
            list_1 = list_1.filter(function (x) { return x !== ""; });
            var hasChanged = options.some(function (item) {
                var i = list_1.findIndex(function (l) { return l === item.Value; });
                if (i < 0 && item.Selected)
                    return true;
                if (i >= 0 && !item.Selected)
                    return true;
                return false;
            });
            if (hasChanged)
                setOptions(function (opt) { return opt.map(function (item) { return (__assign(__assign({}, item), { Selected: list_1.findIndex(function (l) { return l === item.Value; }) >= 0 })); }); });
        }
    }, [props.Filter]);
    return React.createElement(React.Fragment, null,
        React.createElement("tr", { onClick: function (evt) {
                evt.preventDefault();
                var isChecked = options.filter(function (x) { return x.Selected; }).length === options.length;
                setOptions(function (old) { return old.map(function (o) { return (__assign(__assign({}, o), { Selected: !isChecked })); }); });
            } },
            React.createElement("td", null,
                React.createElement("input", { type: "checkbox", checked: options.filter(function (x) { return x.Selected; }).length === options.length, onChange: function () { return null; } })),
            React.createElement("td", null, "All")),
        options.map(function (f, i) { return (React.createElement("tr", { key: i, onClick: function (evt) { setOptions(function (old) { return old.map(function (o) { return (__assign(__assign({}, o), { Selected: (o.Value === f.Value ? !o.Selected : o.Selected) })); }); }); } },
            React.createElement("td", null,
                React.createElement("input", { type: "checkbox", checked: f.Selected, onChange: function () { return null; } })),
            React.createElement("td", null, f.Label))); }));
}
exports.EnumFilter = EnumFilter;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/FilterableTable.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/FilterableTable.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// ******************************************************************************************************
//  FilterableTable.tsx - Gbtc
//
//  Copyright © 2022, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/02/2022 - C. Lackner
//       Generated original version of source code.
// ******************************************************************************************************
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var react_table_1 = __webpack_require__(/*! @gpa-gemstone/react-table */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/index.js");
var gpa_symbols_1 = __webpack_require__(/*! @gpa-gemstone/gpa-symbols */ "./node_modules/@gpa-gemstone/gpa-symbols/lib/index.js");
var BooleanFilter_1 = __webpack_require__(/*! ./BooleanFilter */ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/BooleanFilter.js");
var TextFilter_1 = __webpack_require__(/*! ./TextFilter */ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/TextFilter.js");
var EnumFilter_1 = __webpack_require__(/*! ./EnumFilter */ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/EnumFilter.js");
var NumberFilter_1 = __webpack_require__(/*! ./NumberFilter */ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/NumberFilter.js");
var DateTimeFilters_1 = __webpack_require__(/*! ./DateTimeFilters */ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/DateTimeFilters.js");
/**
 * Table with Filters in the column Headers
 */
function FilterableTable(props) {
    var _a = React.useState((props.DefaultFilter === undefined ? [] : props.DefaultFilter)), filters = _a[0], setFilters = _a[1];
    function updateFilters(flts, fld) {
        setFilters(function (fls) {
            var otherFilters = fls.filter(function (item) { return item.FieldName !== fld; });
            return otherFilters.concat(flts);
        });
    }
    React.useEffect(function () { props.SetFilter(filters); }, [filters]);
    return (React.createElement(React.Fragment, null,
        React.createElement(react_table_1.default, { cols: props.cols.map(function (c) { return (__assign(__assign({}, c), { label: React.createElement(Header, { Label: c.label, Filter: filters.filter(function (f) { var _a; return f.FieldName === ((_a = c.field) === null || _a === void 0 ? void 0 : _a.toString()); }), SetFilter: function (f) { return updateFilters(f, c.field); }, Field: c.field, Type: c.Type, Options: c.Enum }) })); }), data: props.data, onClick: props.onClick, sortKey: props.sortKey, ascending: props.ascending, onSort: props.onSort, tableClass: props.tableClass, tableStyle: props.tableStyle, theadStyle: props.theadStyle, theadClass: props.theadClass, tbodyStyle: props.tbodyStyle, tbodyClass: props.tbodyClass, selected: props.selected, rowStyle: props.rowStyle, keySelector: props.keySelector })));
}
exports["default"] = FilterableTable;
function Header(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var _o = React.useState(false), show = _o[0], setShow = _o[1];
    return React.createElement(React.Fragment, null,
        React.createElement("div", { onMouseEnter: function () { return setShow(true); }, onMouseLeave: function () { return setShow(false); } },
            React.createElement("div", { style: { marginRight: 25 } }, props.Label),
            props.Type !== undefined ? React.createElement(React.Fragment, null,
                React.createElement("div", { style: { width: 25, position: 'absolute', right: 12, top: 12 } }, props.Filter.length > 0 ? gpa_symbols_1.SVGIcons.Filter : null),
                React.createElement("div", { style: {
                        maxHeight: window.innerHeight * 0.50,
                        overflowY: 'auto',
                        padding: '10 5',
                        display: show ? 'block' : 'none',
                        position: 'absolute',
                        backgroundColor: '#fff',
                        boxShadow: '0px 8px 16px 0px rgba(0,0,0,0.2)',
                        zIndex: 401,
                        minWidth: 'calc(100% - 50px)',
                        marginLeft: -25
                    }, onClick: function (evt) { evt.preventDefault(); evt.stopPropagation(); } },
                    React.createElement("table", { className: "table", style: { margin: 0 } },
                        React.createElement("tbody", null,
                            props.Type === 'boolean' ? React.createElement(BooleanFilter_1.BooleanFilter, { SetFilter: props.SetFilter, Filter: props.Filter, FieldName: (_b = (_a = props.Field) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '' }) : null,
                            props.Type === 'string' ? React.createElement(TextFilter_1.TextFilter, { SetFilter: props.SetFilter, Filter: props.Filter, FieldName: (_d = (_c = props.Field) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : '' }) : null,
                            props.Type === 'enum' && props.Options !== undefined ? React.createElement(EnumFilter_1.EnumFilter, { FieldName: (_f = (_e = props.Field) === null || _e === void 0 ? void 0 : _e.toString()) !== null && _f !== void 0 ? _f : '', Filter: props.Filter, SetFilter: props.SetFilter, Options: props.Options }) : null,
                            props.Type === 'date' ? React.createElement(DateTimeFilters_1.DateFilter, { FieldName: (_h = (_g = props.Field) === null || _g === void 0 ? void 0 : _g.toString()) !== null && _h !== void 0 ? _h : '', Filter: props.Filter, SetFilter: props.SetFilter }) : null,
                            props.Type === 'time' ? React.createElement(DateTimeFilters_1.TimeFilter, { FieldName: (_k = (_j = props.Field) === null || _j === void 0 ? void 0 : _j.toString()) !== null && _k !== void 0 ? _k : '', Filter: props.Filter, SetFilter: props.SetFilter }) : null,
                            props.Type === 'number' ? React.createElement(NumberFilter_1.NumberFilter, { FieldName: (_m = (_l = props.Field) === null || _l === void 0 ? void 0 : _l.toString()) !== null && _m !== void 0 ? _m : '', Filter: props.Filter, SetFilter: props.SetFilter }) : null)))) : null));
}


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/NumberFilter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/NumberFilter.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumberFilter = void 0;
// ******************************************************************************************************
//  NumberFilter.tsx - Gbtc
//
//  Copyright © 2022, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/02/2022 - C Lackner
//       Generated original version of source code.
// ******************************************************************************************************
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
function NumberFilter(props) {
    var _a = React.useState(''), value = _a[0], setValue = _a[1];
    var _b = React.useState(''), secondValue = _b[0], setSecondValue = _b[1];
    var _c = React.useState('less than'), operator = _c[0], setOperator = _c[1];
    React.useEffect(function () {
        if (props.Filter.length === 0) {
            setValue('');
            setSecondValue('');
        }
        if (props.Filter.length > 1) {
            var f1 = props.Filter.find(function (f) { return f.Operator === '>' || f.Operator === '>='; });
            if (f1 == null)
                setValue('');
            else
                setValue(f1.SearchText);
            var f2 = props.Filter.find(function (f) { return f.Operator === '<' || f.Operator === '<='; });
            if (f2 == null)
                setSecondValue('');
            else
                setSecondValue(f2.SearchText);
        }
        if (props.Filter.length === 1) {
            setSecondValue('');
            if (props.Filter[0].Operator === '>' || props.Filter[0].Operator === '>=')
                setOperator('greater than');
            else if (props.Filter[0].Operator === '=')
                setOperator('equal to');
            else
                setOperator('less than');
            setValue(props.Filter[0].SearchText);
        }
    }, [props.Filter]);
    React.useEffect(function () {
        if (value === '' && secondValue === '' && props.Filter.length !== 0)
            props.SetFilter([]);
        if (value === '' && secondValue === '')
            return;
        if (operator === 'between') {
            props.SetFilter([
                {
                    FieldName: props.FieldName,
                    isPivotColumn: false,
                    Operator: '>=',
                    Type: 'number',
                    SearchText: value
                },
                {
                    FieldName: props.FieldName,
                    isPivotColumn: false,
                    Operator: '<=',
                    Type: 'number',
                    SearchText: secondValue
                }
            ]);
        }
        else {
            props.SetFilter([{
                    FieldName: props.FieldName,
                    isPivotColumn: false,
                    Operator: transformSymbol(operator),
                    Type: 'number',
                    SearchText: value
                }]);
        }
    }, [operator, value, secondValue]);
    function transformSymbol(s) {
        if (s === 'less than')
            return '<';
        if (s === 'greater than')
            return '>';
        return '=';
    }
    return React.createElement(React.Fragment, null,
        React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
            React.createElement("td", null,
                React.createElement("select", { className: 'form-control', value: operator, onChange: function (evt) {
                        var v = evt.target.value;
                        setOperator(v);
                    } },
                    React.createElement("option", { value: 'less than' },
                        "Less than (",
                        '<',
                        ")"),
                    React.createElement("option", { value: 'equal to' }, "Equal to (=)"),
                    React.createElement("option", { value: 'greater than' },
                        "Greater than (",
                        '>',
                        ")"),
                    React.createElement("option", { value: 'between' }, "In range")))),
        React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
            React.createElement("td", null,
                React.createElement("input", { type: 'number', className: 'form-control', value: value, onChange: function (evt) {
                        var v = evt.target.value;
                        setValue(v);
                    } }))),
        operator === 'between' ? React.createElement(React.Fragment, null,
            React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
                React.createElement("td", null, "and")),
            React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
                React.createElement("td", null,
                    React.createElement("input", { type: 'number', className: 'form-control', value: secondValue, onChange: function (evt) {
                            var v = evt.target.value;
                            setSecondValue(v);
                        } })))) : null);
}
exports.NumberFilter = NumberFilter;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/TextFilter.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/TextFilter.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextFilter = void 0;
// ******************************************************************************************************
//  TextFilter.tsx - Gbtc
//
//  Copyright © 2022, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/02/2022 - C Lackner
//       Generated original version of source code.
// ******************************************************************************************************
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
function TextFilter(props) {
    var _a = React.useState(''), txt = _a[0], setTxt = _a[1];
    React.useEffect(function () {
        if (props.Filter.length === 0) {
            setTxt('');
            return;
        }
        setTxt(props.Filter[0].SearchText);
    }, [props.Filter]);
    React.useEffect(function () {
        if ((txt == null || txt.trim().length === 0) && props.Filter.length !== 0)
            props.SetFilter([]);
        if (txt != null && txt.trim().length > 0 && (props.Filter.length === 0 || props.Filter[0].SearchText !== txt.trim()))
            props.SetFilter([{ FieldName: props.FieldName, isPivotColumn: false, SearchText: txt.trim(), Operator: 'LIKE', Type: 'string' }]);
    }, [txt]);
    return React.createElement(React.Fragment, null,
        React.createElement("tr", { onClick: function (evt) { evt.preventDefault(); } },
            React.createElement("td", null,
                React.createElement("input", { className: 'form-control', value: txt.replace('$_', '_'), placeholder: "Search", onChange: function (evt) {
                        var value = evt.target.value;
                        setTxt(value.replace('_', '$_'));
                    } }))),
        React.createElement("tr", null,
            React.createElement("td", null,
                " ",
                React.createElement("label", null, "Wildcard (*) can be used"),
                " ")));
}
exports.TextFilter = TextFilter;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/GenericSlice.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/GenericSlice.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// ******************************************************************************************************
//  GenericSlice.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  11/04/2020 - Billy Ernest
//       Generated original version of source code.
// ******************************************************************************************************
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var toolkit_1 = __webpack_require__(/*! @reduxjs/toolkit */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
var GenericSlice = /** @class */ (function () {
    /**
     * Creates a new GenericSlice of type T, which can be used to perform basic CRUD operations against
     * a specified web api.
     * @typeParam T - Model of Generic Slice
     * @param {string} name - string defining the name of the slice in the store
     * @param {string} apiPath - string containing relative path to web api
     * @param {keyof T} defaultSort - string showing default sort field
     * @param {boolean} ascending - (optional) default sort direction - defaults to true
     * @returns a new GenericSlice<T>
     */
    function GenericSlice(name, apiPath, defaultSort, ascending) {
        var _this = this;
        if (ascending === void 0) { ascending = true; }
        this.Name = "";
        this.APIPath = "";
        this.Data = function (state) { return state[_this.Name].Data; };
        this.Error = function (state) { return state[_this.Name].Error; };
        this.Datum = function (state, id) { return state[_this.Name].Data.find(function (d) { return d.ID === id; }); };
        this.Status = function (state) { return state[_this.Name].Status; };
        this.SortField = function (state) { return state[_this.Name].SortField; };
        this.Ascending = function (state) { return state[_this.Name].Ascending; };
        this.ParentID = function (state) { return state[_this.Name].ParentID; };
        this.SearchResults = function (state) { return state[_this.Name].SearchResults; };
        this.SearchStatus = function (state) { return state[_this.Name].SearchStatus; };
        this.SearchFilters = function (state) { return state[_this.Name].Filter; };
        this.Name = name;
        this.APIPath = apiPath;
        this.fetchHandle = null;
        this.searchHandle = null;
        var fetch = (0, toolkit_1.createAsyncThunk)(name + "/Fetch" + name, function (parentID, _a) {
            var signal = _a.signal, getState = _a.getState;
            return __awaiter(_this, void 0, void 0, function () {
                var state, handle;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            state = getState()[name];
                            if (this.fetchHandle != null && this.fetchHandle.abort != null)
                                this.fetchHandle.abort('Prev');
                            handle = this.GetRecords(state.Ascending, state.SortField, parentID);
                            this.fetchHandle = handle;
                            signal.addEventListener('abort', function () {
                                if (handle.abort !== undefined)
                                    handle.abort();
                            });
                            return [4 /*yield*/, handle];
                        case 1: return [2 /*return*/, _b.sent()];
                    }
                });
            });
        });
        var dBAction = (0, toolkit_1.createAsyncThunk)(name + "/DBAction" + name, function (args, _a) {
            var signal = _a.signal;
            return __awaiter(_this, void 0, void 0, function () {
                var handle;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            handle = this.Action(args.verb, args.record);
                            signal.addEventListener('abort', function () {
                                if (handle.abort !== undefined)
                                    handle.abort();
                            });
                            return [4 /*yield*/, handle];
                        case 1: return [2 /*return*/, _b.sent()];
                    }
                });
            });
        });
        var dBSearch = (0, toolkit_1.createAsyncThunk)(name + "/Search" + name, function (args, _a) {
            var getState = _a.getState, signal = _a.signal;
            return __awaiter(_this, void 0, void 0, function () {
                var sortfield, asc, handle;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            sortfield = args.sortField;
                            asc = args.ascending;
                            sortfield = sortfield === undefined ? getState()[this.Name].SortField : sortfield;
                            asc = asc === undefined ? getState()[this.Name].Ascending : asc;
                            if (this.searchHandle != null && this.searchHandle.abort != null)
                                this.searchHandle.abort('Prev');
                            handle = this.Search(args.filter, asc, sortfield, getState()[this.Name].ParentID);
                            this.searchHandle = handle;
                            signal.addEventListener('abort', function () {
                                if (handle.abort !== undefined)
                                    handle.abort();
                            });
                            return [4 /*yield*/, handle];
                        case 1: return [2 /*return*/, _b.sent()];
                    }
                });
            });
        });
        var dBSort = (0, toolkit_1.createAsyncThunk)(name + "/DBSort" + name, function (args, _a) {
            var signal = _a.signal, getState = _a.getState, dispatch = _a.dispatch;
            return __awaiter(_this, void 0, void 0, function () {
                var state, sortFld, asc, handle;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            state = getState()[name];
                            sortFld = state.SortField;
                            asc = state.Ascending;
                            if (state.SortField === args.SortField)
                                asc = !args.Ascending;
                            else
                                sortFld = args.SortField;
                            dispatch(dBSearch({ filter: state.Filter, sortField: sortFld, ascending: asc }));
                            if (this.fetchHandle != null && this.fetchHandle.abort != null)
                                this.fetchHandle.abort('Prev');
                            handle = this.GetRecords(asc, sortFld, (state.ParentID != null ? state.ParentID : undefined));
                            this.fetchHandle = handle;
                            signal.addEventListener('abort', function () {
                                if (handle.abort !== undefined)
                                    handle.abort();
                            });
                            return [4 /*yield*/, handle];
                        case 1: return [2 /*return*/, _b.sent()];
                    }
                });
            });
        });
        var slice = (0, toolkit_1.createSlice)({
            name: this.Name,
            initialState: {
                Status: 'unintiated',
                SearchStatus: 'unintiated',
                Error: null,
                Data: [],
                SortField: defaultSort,
                Ascending: ascending,
                ParentID: null,
                SearchResults: [],
                Filter: [],
                ActiveFetchID: [],
                ActiveSearchID: []
            },
            reducers: {},
            extraReducers: function (builder) {
                builder.addCase(fetch.fulfilled, function (state, action) {
                    state.ActiveFetchID = state.ActiveFetchID.filter(function (id) { return id !== action.meta.requestId; });
                    state.Status = 'idle';
                    state.Error = null;
                    state.Data = JSON.parse(action.payload.toString());
                });
                builder.addCase(fetch.pending, function (state, action) {
                    if (state.ParentID !== (action.meta.arg == null ? null : action.meta.arg))
                        state.SearchStatus = 'changed';
                    state.ParentID = (action.meta.arg == null ? null : action.meta.arg);
                    state.Status = 'loading';
                    state.ActiveFetchID.push(action.meta.requestId);
                });
                builder.addCase(fetch.rejected, function (state, action) {
                    state.ActiveFetchID = state.ActiveFetchID.filter(function (id) { return id !== action.meta.requestId; });
                    if (state.ActiveFetchID.length > 0)
                        return;
                    state.Status = 'error';
                    state.Error = {
                        Message: (action.error.message == null ? '' : action.error.message),
                        Verb: 'FETCH',
                        Time: new Date().toString()
                    };
                });
                builder.addCase(dBAction.pending, function (state) {
                    state.Status = 'loading';
                });
                builder.addCase(dBAction.rejected, function (state, action) {
                    state.Status = 'error';
                    state.Error = {
                        Message: (action.error.message == null ? '' : action.error.message),
                        Verb: action.meta.arg.verb,
                        Time: new Date().toString()
                    };
                });
                builder.addCase(dBAction.fulfilled, function (state) {
                    state.Status = 'changed';
                    state.SearchStatus = 'changed';
                    state.Error = null;
                });
                builder.addCase(dBSearch.pending, function (state, action) {
                    state.SearchStatus = 'loading';
                    state.ActiveSearchID.push(action.meta.requestId);
                });
                builder.addCase(dBSearch.rejected, function (state, action) {
                    state.ActiveSearchID = state.ActiveSearchID.filter(function (id) { return id !== action.meta.requestId; });
                    if (state.ActiveSearchID.length > 0)
                        return;
                    state.SearchStatus = 'error';
                    state.Error = {
                        Message: (action.error.message == null ? '' : action.error.message),
                        Verb: 'SEARCH',
                        Time: new Date().toString()
                    };
                });
                builder.addCase(dBSearch.fulfilled, function (state, action) {
                    state.ActiveSearchID = state.ActiveSearchID.filter(function (id) { return id !== action.meta.requestId; });
                    state.SearchStatus = 'idle';
                    state.SearchResults = JSON.parse(action.payload);
                    state.Filter = action.meta.arg.filter;
                });
                builder.addCase(dBSort.pending, function (state, action) {
                    state.Status = 'loading';
                    state.ActiveFetchID.push(action.meta.requestId);
                });
                builder.addCase(dBSort.rejected, function (state, action) {
                    state.ActiveFetchID = state.ActiveFetchID.filter(function (id) { return id !== action.meta.requestId; });
                    if (state.ActiveFetchID.length > 0)
                        return;
                    state.Status = 'error';
                    state.Error = {
                        Message: (action.error.message == null ? '' : action.error.message),
                        Verb: 'FETCH',
                        Time: new Date().toString()
                    };
                });
                builder.addCase(dBSort.fulfilled, function (state, action) {
                    state.ActiveFetchID = state.ActiveFetchID.filter(function (id) { return id !== action.meta.requestId; });
                    state.Status = 'idle';
                    state.Error = null;
                    state.Data = JSON.parse(action.payload.toString());
                    if (state.SortField === action.meta.arg.SortField)
                        state.Ascending = !state.Ascending;
                    else
                        state.SortField = action.meta.arg.SortField;
                });
            }
        });
        this.Fetch = fetch;
        this.DBAction = dBAction;
        this.Slice = slice;
        this.DBSearch = dBSearch;
        this.Sort = dBSort;
        this.Reducer = slice.reducer;
    }
    GenericSlice.prototype.GetRecords = function (ascending, sortField, parentID) {
        return $.ajax({
            type: "GET",
            url: "" + this.APIPath + (parentID != null ? '/' + parentID : '') + "/" + sortField + "/" + (ascending ? '1' : '0'),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
    };
    GenericSlice.prototype.Action = function (verb, record) {
        var action = '';
        if (verb === 'POST')
            action = 'Add';
        else if (verb === 'DELETE')
            action = 'Delete';
        else if (verb === 'PATCH')
            action = 'Update';
        return $.ajax({
            type: verb,
            url: this.APIPath + "/" + action,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            data: JSON.stringify(__assign({}, record)),
            cache: false,
            async: true
        });
    };
    GenericSlice.prototype.Search = function (filter, ascending, sortField, parentID) {
        return $.ajax({
            type: 'POST',
            url: this.APIPath + "/" + (parentID != null ? parentID + "/" : '') + "SearchableList",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            data: JSON.stringify({ Searches: filter, OrderBy: sortField, Ascending: ascending }),
            cache: false,
            async: true
        });
    };
    return GenericSlice;
}());
exports["default"] = GenericSlice;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/LoadingIcon.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/LoadingIcon.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// ******************************************************************************************************
//  LoadingIcon.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  01/11/2020 - Christoph Lackner
//       Generated original version of source code.
// ******************************************************************************************************
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var styled_components_1 = __webpack_require__(/*! styled-components */ "./node_modules/styled-components/dist/styled-components.browser.esm.js");
var spin = (0, styled_components_1.keyframes)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n 0% { transform: rotate(0deg); }\n 100% { transform: rotate(360deg); }\n"], ["\n 0% { transform: rotate(0deg); }\n 100% { transform: rotate(360deg); }\n"])));
var Icon = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n\tanimation: ", " 1s linear infinite;\n\tborder: ", "px solid #f3f3f3;\n\tborder-Top: ", "px solid #555;\n\tborder-Radius: 50%;\n\twidth: ", "px;\n\theight: ", "px\n"], ["\n\tanimation: ", " 1s linear infinite;\n\tborder: ", "px solid #f3f3f3;\n\tborder-Top: ", "px solid #555;\n\tborder-Radius: 50%;\n\twidth: ", "px;\n\theight: ", "px\n"])), spin, function (props) { return props.size / 5; }, function (props) { return props.size / 5; }, function (props) { return props.size; }, function (props) { return props.size; });
var LoadingIcon = function (props) {
    var h = (props.Size === undefined ? 25 : props.Size);
    return (React.createElement("div", null,
        React.createElement("div", { style: { width: (props.Label === undefined ? h : undefined), margin: 'auto' }, hidden: !props.Show },
            React.createElement(Icon, { size: h }),
            props.Label !== undefined ? React.createElement("span", null, props.Label) : null)));
};
exports["default"] = LoadingIcon;
var templateObject_1, templateObject_2;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/LoadingScreen.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/LoadingScreen.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  LoadingScreen.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  01/11/2020 - Christoph Lackner
//       Generated original version of source code.
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var LoadingIcon_1 = __webpack_require__(/*! ./LoadingIcon */ "./node_modules/@gpa-gemstone/react-interactive/lib/LoadingIcon.js");
var LoadingScreen = function (props) {
    var x = window.innerHeight / 2 - 20;
    return (props.Show ? React.createElement("div", { style: {
            width: '100%',
            height: '100%',
            position: 'fixed',
            top: 0,
            left: 0,
            opacity: 0.5,
            backgroundColor: '#000000',
            zIndex: 9980,
        } },
        React.createElement("div", { style: { height: '40px', width: '40px', margin: 'auto', marginTop: x } },
            React.createElement(LoadingIcon_1.default, { Show: true, Size: 40 }))) : null);
};
exports["default"] = LoadingScreen;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Application.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Application.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// ******************************************************************************************************
//  Application.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/13/2022 - C. Lackner
//       Generated original version of source code.
//
// ******************************************************************************************************
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Context_1 = __webpack_require__(/*! ./Context */ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Context.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var react_router_dom_1 = __webpack_require__(/*! react-router-dom */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/react-router-dom/index.js");
var Page_1 = __webpack_require__(/*! ./Page */ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Page.js");
var Section_1 = __webpack_require__(/*! ./Section */ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Section.js");
var LoadingScreen_1 = __webpack_require__(/*! ../LoadingScreen */ "./node_modules/@gpa-gemstone/react-interactive/lib/LoadingScreen.js");
var ServerErrorIcon_1 = __webpack_require__(/*! ../ServerErrorIcon */ "./node_modules/@gpa-gemstone/react-interactive/lib/ServerErrorIcon.js");
var styled_components_1 = __webpack_require__(/*! styled-components */ "./node_modules/styled-components/dist/styled-components.browser.esm.js");
var gpa_symbols_1 = __webpack_require__(/*! @gpa-gemstone/gpa-symbols */ "./node_modules/@gpa-gemstone/gpa-symbols/lib/index.js");
var SidebarNav = styled_components_1.default.nav(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  & {\n    position: fixed;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 100;\n    padding: 48px 0 0;\n    box-shadow: inset -1px 0 0 rgba(0,0,0,.1);\n    width: ", "px;\n  }"], ["\n  & {\n    position: fixed;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 100;\n    padding: 48px 0 0;\n    box-shadow: inset -1px 0 0 rgba(0,0,0,.1);\n    width: ", "px;\n  }"])), function (props) { return props.collapsed ? 50 : 200; });
var SidebarDiv = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  & {\n    position: -webkit-sticky;\n    position: sticky;\n    height: calc( 100% - 35px);\n  }"], ["\n  & {\n    position: -webkit-sticky;\n    position: sticky;\n    height: calc( 100% - 35px);\n  }"])));
var MainDiv = styled_components_1.default.div(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n& {\n    top: 40px;\n    position: absolute;\n    width: calc(100% - ", "px);\n    height: calc(100% - 48px);\n    overflow: hidden;\n    left: ", "px;\n}\n& svg {\n    user-select: none;\n }"], ["\n& {\n    top: 40px;\n    position: absolute;\n    width: calc(100% - ", "px);\n    height: calc(100% - 48px);\n    overflow: hidden;\n    left: ", "px;\n}\n& svg {\n    user-select: none;\n }"])), function (props) { return props.collapsed ? 50 : 200; }, function (props) { return props.collapsed ? 50 : 200; });
var Applications = function (props) {
    var _a = React.useState(false), collapsed = _a[0], setCollapsed = _a[1];
    var showOpen = props.AllowCollapsed !== undefined && props.AllowCollapsed && collapsed;
    var showClose = props.AllowCollapsed !== undefined && props.AllowCollapsed && !collapsed;
    function GetContext() {
        var _a;
        return {
            homePath: props.HomePath,
            userRoles: ((_a = props.UserRoles) !== null && _a !== void 0 ? _a : ['Viewer']),
            collapsed: collapsed
        };
    }
    function CreateRoute(element) {
        if (element.props.RequiredRoles !== undefined && element.props.RequiredRoles.filter(function (r) { return GetContext().userRoles.findIndex(function (i) { return i === r; }) > -1; }).length === 0)
            return React.createElement(react_router_dom_1.Route, { path: "" + props.HomePath + element.props.Name, element: React.createElement(ServerErrorIcon_1.default, { Show: true, Label: 'You are not authorized to view this page' }) });
        return React.createElement(react_router_dom_1.Route, { path: "" + props.HomePath + element.props.Name, element: element.props.children });
    }
    return React.createElement(React.Suspense, { fallback: React.createElement(LoadingScreen_1.default, { Show: true }) },
        React.createElement(Context_1.Context.Provider, { value: GetContext() },
            React.createElement(react_router_dom_1.BrowserRouter, null,
                React.createElement("div", { style: { width: window.innerWidth, height: window.innerHeight, position: "absolute" } },
                    React.createElement("nav", { className: "navbar navbar-dark fixed-top bg-dark flex-md-nowrap p-0 shadow" },
                        showOpen ? React.createElement("a", { style: { color: '#f8f9fa', marginLeft: 15 }, onClick: function () { return setCollapsed(false); } }, gpa_symbols_1.SVGIcons.ArrowForward) : null,
                        showClose ? React.createElement("a", { style: { color: '#f8f9fa', marginLeft: 15 }, onClick: function () { return setCollapsed(true); } }, gpa_symbols_1.SVGIcons.ArrowBackward) : null,
                        props.Logo !== undefined ?
                            React.createElement("a", { className: "navbar-brand col-sm-3 col-md-2 mr-0 mr-auto", href: props.HomePath },
                                React.createElement("img", { style: { maxHeight: 35, margin: -5 }, src: props.Logo })) : null,
                        React.createElement("ul", { className: "navbar-nav px-3 ml-auto" },
                            React.createElement("li", { className: "nav-item text-nowrap" }, props.OnSignOut !== undefined ? React.createElement("a", { className: "nav-link", onClick: props.OnSignOut }, "Sign out") : null))),
                    React.createElement(SidebarNav, { className: "bg-light", collapsed: collapsed },
                        React.createElement(SidebarDiv, null,
                            React.createElement("ul", { className: "navbar-nav px-3" }, React.Children.map(props.children, function (e) {
                                if (!React.isValidElement(e))
                                    return null;
                                if (e.type === Page_1.default)
                                    return e;
                                return null;
                            })),
                            React.Children.map(props.children, function (e) {
                                if (!React.isValidElement(e))
                                    return null;
                                if (e.type === Section_1.default)
                                    return e;
                                return null;
                            })),
                        props.Version !== undefined && !collapsed ?
                            React.createElement("div", { style: { width: '100%', textAlign: 'center', height: 35 } },
                                React.createElement("span", null,
                                    "Version ",
                                    props.Version),
                                React.createElement("br", null),
                                React.createElement("span", null)) : null),
                    React.createElement(MainDiv, { collapsed: collapsed },
                        React.createElement(react_router_dom_1.Routes, null,
                            React.createElement(react_router_dom_1.Route, { path: "" + props.HomePath },
                                React.createElement(react_router_dom_1.Route, { index: true, element: React.createElement(react_router_dom_1.Navigate, { to: "" + props.HomePath + props.DefaultPath }) }),
                                React.Children.map(props.children, function (element) {
                                    if (!React.isValidElement(element))
                                        return null;
                                    if (element.type === Page_1.default && React.Children.count(element.props.children) > 0)
                                        return CreateRoute(element);
                                    if (element.type === Section_1.default)
                                        return React.Children.map(element.props.children, function (e) {
                                            if (!React.isValidElement(e))
                                                return null;
                                            if (e.type === Page_1.default && React.Children.count(e.props.children) > 0)
                                                return CreateRoute(e);
                                            return null;
                                        });
                                    return null;
                                }))))))));
};
exports["default"] = Applications;
var templateObject_1, templateObject_2, templateObject_3;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Context.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Context.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  CirclePlusSVG.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/13/2022 - C. Lackner
//       Generated original version of source code.
//
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = void 0;
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
;
exports.Context = React.createContext({
    homePath: '',
    userRoles: ['Viewer'],
    collapsed: false
});


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Page.js":
/*!************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Page.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  Page.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  10/05/2020 - Billy Ernest
//       Generated original version of source code.
//
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ToolTip_1 = __webpack_require__(/*! ../ToolTip */ "./node_modules/@gpa-gemstone/react-interactive/lib/ToolTip.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var react_router_dom_1 = __webpack_require__(/*! react-router-dom */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/react-router-dom/index.js");
var Context_1 = __webpack_require__(/*! ./Context */ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Context.js");
var Page = function (props) {
    var _a = React.useState(false), hover = _a[0], setHover = _a[1];
    var context = React.useContext(Context_1.Context);
    if (props.RequiredRoles !== undefined && props.RequiredRoles.filter(function (r) { return context.userRoles.findIndex(function (i) { return i === r; }) > -1; }).length === 0)
        return null;
    if (props.Label !== undefined || props.Icon !== undefined)
        return (React.createElement(React.Fragment, null,
            React.createElement("li", { className: "nav-item", style: { position: 'relative' } },
                React.createElement(react_router_dom_1.NavLink, { "data-tooltip": props.Name, className: "nav-link", to: "" + context.homePath + props.Name, style: function (a) { return ({ color: a.isActive ? '#007bff' : '#78828d' }); }, onMouseEnter: function () { return setHover(true); }, onMouseLeave: function () { return setHover(false); } },
                    props.Icon !== undefined ? props.Icon : null,
                    !context.collapsed ? React.createElement("span", null,
                        " ",
                        props.Label) : null)),
            context.collapsed ? React.createElement(ToolTip_1.default, { Target: props.Name, Show: hover, Position: 'right' },
                " ",
                props.Label) : null));
    return null;
};
exports["default"] = Page;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Section.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Section.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  Header.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/13/2022 - C. Lackner
//       Generated original version of source code.
//
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var Context_1 = __webpack_require__(/*! ./Context */ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Context.js");
var Section = function (props) {
    var context = React.useContext(Context_1.Context);
    return (React.createElement(React.Fragment, null,
        React.createElement("hr", null),
        props.Label !== undefined && !context.collapsed ?
            React.createElement(React.Fragment, null,
                React.createElement("h6", { className: "sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted" },
                    React.createElement("span", null, props.Label))) : null,
        React.createElement("ul", { className: "navbar-nav px-3" }, props.children)));
};
exports["default"] = Section;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/Modal.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/Modal.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  Modal.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  12/29/2020 - Christoph Lackner
//       Generated original version of source code.
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var ToolTip_1 = __webpack_require__(/*! ./ToolTip */ "./node_modules/@gpa-gemstone/react-interactive/lib/ToolTip.js");
var helper_functions_1 = __webpack_require__(/*! @gpa-gemstone/helper-functions */ "./node_modules/@gpa-gemstone/helper-functions/lib/index.js");
// Props Description:
// Title => Title of The Modal
// ShowX => show or hide the X button (default true)
// CallBack => Function to be called when closing the Modal either through Cancel (confirmed=false) or Accept Button (confirmed=true)
// Show => Whether to show the modal
// Size => Size of the modal
// ShowCancel => Whether to show the cancel button
// DisableConfirm => Disables the Confirm button
// CancelText => Text on Cancel Button
// Confirm text => Text on Confirm button
// ConfirmBtnClass => Class of the Confirm Button
// CancelBtnClass =>> Class of the Cancel Button
var Modal = function (props) {
    var _a = React.useState('none'), hover = _a[0], setHover = _a[1];
    var _b = React.useState(''), guid = _b[0], setGuid = _b[1];
    React.useEffect(function () {
        setGuid((0, helper_functions_1.CreateGuid)());
    }, []);
    var confirmBtn = (props.ConfirmText === undefined ? 'Save' : props.ConfirmText);
    var cxnBtn = (props.CancelText === undefined ? 'Cancel' : props.CancelText);
    var cxnbtnCls = 'btn ' + (props.CancelBtnClass === undefined ? 'btn-danger' : props.CancelBtnClass);
    var confirmbtnCls = 'btn ' + (props.ConfirmBtnClass === undefined ? 'btn-primary' : props.ConfirmBtnClass);
    var showConfirmToolTip = (props.ConfirmShowToolTip !== undefined && props.ConfirmShowToolTip) && hover === 'confirm';
    var showCxnToolTip = (props.CancelShowToolTip !== undefined && props.CancelShowToolTip) && hover === 'cancel';
    return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: "modal" + (props.Show ? " show" : ''), style: props.Show ? { display: 'block', zIndex: 9990 } : {} },
            React.createElement("div", { className: "modal-dialog" + (props.Size === undefined ? '' : props.Size === 'xlg' ? '' : (" modal-" + props.Size)), style: props.Size === 'xlg' ? { maxWidth: window.innerWidth - 100 } : {} },
                React.createElement("div", { className: "modal-content" },
                    React.createElement("div", { className: "modal-header" },
                        React.createElement("h4", { className: "modal-title" }, props.Title),
                        props.ShowX ? React.createElement("button", { type: "button", className: "close", onClick: function () { return props.CallBack(false, false); } }, "\u00D7") : null),
                    React.createElement("div", { className: "modal-body" }, props.Show ? props.children : null),
                    React.createElement("div", { className: "modal-footer" },
                        React.createElement("button", { type: "button", className: confirmbtnCls + (!(props.DisableConfirm === undefined || !props.DisableConfirm) ? ' disabled' : ''), "data-tooltip": guid + '-confirm', onClick: function () { if (!(props.DisableConfirm === undefined || !props.DisableConfirm))
                                return; props.CallBack(true, true); }, onMouseEnter: function () { return setHover('confirm'); }, onMouseLeave: function () { return setHover('none'); } }, confirmBtn),
                        props.ShowCancel === undefined || props.ShowCancel ?
                            React.createElement("button", { type: "button", className: cxnbtnCls + (!(props.DisableCancel === undefined || !props.DisableCancel) ? ' disabled' : ''), "data-tooltip": guid + '-cancel', onClick: function () { if (!(props.DisableCancel === undefined || !props.DisableCancel))
                                    return; props.CallBack(false, true); }, onMouseEnter: function () { return setHover('cancel'); }, onMouseLeave: function () { return setHover('none'); } }, cxnBtn)
                            : null)))),
        React.createElement(ToolTip_1.default, { Show: showConfirmToolTip, Position: 'top', Theme: 'dark', Target: guid + '-confirm', Zindex: 9999 }, props.ConfirmToolTipContent),
        React.createElement(ToolTip_1.default, { Show: showCxnToolTip, Position: 'top', Theme: 'dark', Target: guid + '-cancel', Zindex: 9999 }, props.CancelToolTipContent),
        props.Show ? React.createElement("div", { style: {
                width: '100%',
                height: '100%',
                position: 'fixed',
                top: 0,
                left: 0,
                opacity: 0.5,
                backgroundColor: '#ffffff',
                zIndex: 9980,
            } }) : null));
};
exports["default"] = Modal;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/SearchBar.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/SearchBar.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// ******************************************************************************************************
//  SearchBar.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  01/06/2020 - Christoph Lackner
//       Generated original version of source code.
// ******************************************************************************************************
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var Modal_1 = __webpack_require__(/*! ./Modal */ "./node_modules/@gpa-gemstone/react-interactive/lib/Modal.js");
var LoadingIcon_1 = __webpack_require__(/*! ./LoadingIcon */ "./node_modules/@gpa-gemstone/react-interactive/lib/LoadingIcon.js");
var react_forms_1 = __webpack_require__(/*! @gpa-gemstone/react-forms */ "./node_modules/@gpa-gemstone/react-forms/lib/index.js");
var gpa_symbols_1 = __webpack_require__(/*! @gpa-gemstone/gpa-symbols */ "./node_modules/@gpa-gemstone/gpa-symbols/lib/index.js");
function SearchBar(props) {
    var _a = React.useState(false), hover = _a[0], setHover = _a[1];
    var _b = React.useState(false), show = _b[0], setShow = _b[1];
    var _c = React.useState(false), isNew = _c[0], setIsNew = _c[1];
    var _d = React.useState([]), filters = _d[0], setFilters = _d[1];
    var _e = React.useState({ FieldName: props.CollumnList[0].key, SearchText: '', Operator: props.CollumnList[0].type === 'string' ? 'LIKE' : '=', Type: props.CollumnList[0].type, isPivotColumn: props.CollumnList[0].isPivotField }), filter = _e[0], setFilter = _e[1];
    var _f = React.useState(""), search = _f[0], setSearch = _f[1];
    var _g = React.useState(null), searchFilter = _g[0], setSearchFilter = _g[1];
    // Update SearchFilter if there are any Character and only do it every 500ms to avoid hammering the server while typing
    React.useEffect(function () {
        var handle = null;
        if (search.length > 0 && props.defaultCollumn !== undefined)
            handle = setTimeout(function () {
                if (props.defaultCollumn !== undefined)
                    setSearchFilter({ FieldName: props.defaultCollumn.key, Operator: 'LIKE', Type: props.defaultCollumn.type, SearchText: ('*' + search + '*'), isPivotColumn: props.defaultCollumn.isPivotField });
            }, 500);
        else
            handle = setTimeout(function () {
                setSearchFilter(null);
            }, 500);
        return function () { if (handle !== null)
            clearTimeout(handle); };
    }, [search]);
    React.useEffect(function () {
        if (searchFilter !== null)
            props.SetFilter(__spreadArray(__spreadArray([], filters, true), [searchFilter], false));
        if (searchFilter === null)
            props.SetFilter(filters);
    }, [searchFilter]);
    function deleteFilter(f) {
        var index = filters.findIndex(function (fs) { return fs === f; });
        var filts = __spreadArray([], filters, true);
        filts.splice(index, 1);
        setFilters(filts);
        setHover(false);
        if (props.defaultCollumn !== undefined && searchFilter !== null)
            props.SetFilter(__spreadArray(__spreadArray([], filts, true), [searchFilter], false));
        else
            props.SetFilter(filts);
    }
    function addFilter() {
        var oldFilters = __spreadArray([], filters, true);
        var adjustedFilter = __assign({}, filter);
        if (adjustedFilter.Type === 'string' && (adjustedFilter.Operator === 'LIKE' || adjustedFilter.Operator === 'NOT LIKE'))
            adjustedFilter.SearchText = '*' + adjustedFilter.SearchText + '*';
        oldFilters.push(adjustedFilter);
        setFilters(oldFilters);
        setFilter({ FieldName: props.CollumnList[0].key, SearchText: '', Operator: props.CollumnList[0].type === 'string' ? 'LIKE' : '=', Type: props.CollumnList[0].type, isPivotColumn: props.CollumnList[0].isPivotField });
        if (props.defaultCollumn !== undefined && searchFilter !== null)
            props.SetFilter(__spreadArray(__spreadArray([], oldFilters, true), [searchFilter], false));
        else
            props.SetFilter(oldFilters);
    }
    function editFilter(index) {
        setIsNew(false);
        var oldFilters = __spreadArray([], filters, true);
        var filt = __assign({}, oldFilters[index]);
        oldFilters.splice(index, 1);
        if (filt.Type === 'string' && (filt.Operator === 'LIKE' || filt.Operator === 'NOT LIKE'))
            filt.SearchText = filt.SearchText.substr(1, filt.SearchText.length - 2);
        setShow(true);
        setFilters(oldFilters);
        setFilter(filt);
        if (props.defaultCollumn !== undefined && searchFilter !== null)
            props.SetFilter(__spreadArray(__spreadArray([], oldFilters, true), [searchFilter], false));
        else
            props.SetFilter(oldFilters);
    }
    ;
    function createFilter() {
        setShow(!show);
        setIsNew(true);
        setFilter({ FieldName: props.CollumnList[0].key, SearchText: '', Operator: props.CollumnList[0].type === 'string' ? 'LIKE' : '=', Type: props.CollumnList[0].type, isPivotColumn: props.CollumnList[0].isPivotField });
    }
    var content = (React.createElement(React.Fragment, null,
        React.createElement("form", null,
            React.createElement("div", { className: "row" },
                props.defaultCollumn !== undefined ?
                    React.createElement("div", { className: "col" },
                        React.createElement("div", { className: "input-group" },
                            React.createElement("input", { className: "form-control mr-sm-2", type: "search", placeholder: "Search " + props.defaultCollumn.label, onChange: function (event) { return setSearch(event.target.value); } }),
                            props.ShowLoading !== undefined && props.ShowLoading ? React.createElement("div", { className: "input-group-append" },
                                " ",
                                React.createElement(LoadingIcon_1.default, { Show: true }),
                                " ") : null),
                        React.createElement("p", { style: { marginTop: 2, marginBottom: 2 } }, props.ResultNote)) : null,
                React.createElement("div", { style: { position: 'relative', display: 'inline-block' }, className: 'col' },
                    React.createElement("button", { className: "btn btn-" + (filters.length > 0 ? "warning" : "primary"), onClick: function (evt) { evt.preventDefault(); createFilter(); }, onMouseEnter: function () { return setHover(true); }, onMouseLeave: function () { return setHover(false); } },
                        "Add Filter",
                        filters.length > 0 ? ("(" + filters.length + ")") : ""),
                    React.createElement("div", { style: { width: window.innerWidth / 3, display: hover ? 'block' : 'none', position: 'absolute', backgroundColor: '#f1f1f1', boxShadow: '0px 8px 16px 0px rgba(0,0,0,0.2)', zIndex: 1, right: (props.Direction === 'right' ? 0 : undefined), left: (props.Direction === 'left' ? 0 : undefined) }, onMouseEnter: function () { return setHover(true); }, onMouseLeave: function () { return setHover(false); } },
                        React.createElement("table", { className: 'table' },
                            React.createElement("thead", null,
                                React.createElement("tr", null,
                                    React.createElement("th", null, "Column"),
                                    React.createElement("th", null, "Operator"),
                                    React.createElement("th", null, "Search Text"),
                                    React.createElement("th", null, "Edit"),
                                    React.createElement("th", null, "Remove"))),
                            React.createElement("tbody", null, filters.map(function (f, i) { return React.createElement("tr", { key: i },
                                React.createElement("td", null, f.FieldName === props.CollumnList[0].key ? props.CollumnList[0].label : f.FieldName),
                                React.createElement("td", null, f.Operator),
                                React.createElement("td", null, f.SearchText),
                                React.createElement("td", null,
                                    React.createElement("button", { type: 'button', className: "btn btn-sm", onClick: function (e) { return editFilter(i); } },
                                        React.createElement("span", null, gpa_symbols_1.Pencil))),
                                React.createElement("td", null,
                                    React.createElement("button", { type: 'button', className: "btn btn-sm", onClick: function (e) { return deleteFilter(f); } },
                                        React.createElement("span", null, gpa_symbols_1.TrashCan)))); })))))))));
    return (React.createElement("div", { style: { width: '100%' } },
        React.createElement("nav", { className: "navbar navbar-expand-lg navbar-light bg-light" },
            React.createElement("div", { className: "collapse navbar-collapse", style: { width: '100%' } },
                React.createElement("ul", { className: "navbar-nav mr-auto", style: { width: '100%' } },
                    props.Direction === 'right' ? props.children : null,
                    props.Label !== undefined ?
                        React.createElement("li", { className: "nav-item", style: { minWidth: (props.Width === undefined ? '150px' : undefined), width: props.Width, paddingRight: 10 } },
                            React.createElement("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                                React.createElement("legend", { className: "w-auto", style: { fontSize: 'large' } },
                                    props.Label,
                                    ":"),
                                content)) :
                        React.createElement("li", { className: "nav-item", style: { minWidth: (props.Width === undefined ? '150px' : undefined), width: props.Width, paddingRight: 10 } }, content),
                    props.Direction === 'left' ? props.children : null))),
        React.createElement(Modal_1.default, { Title: 'Add Filter', Show: show, CallBack: function (conf) { if (conf)
                addFilter(); setShow(false); }, ConfirmText: isNew ? 'Add' : 'Save', CancelText: isNew ? 'Close' : 'Delete' },
            React.createElement(react_forms_1.Select, { Record: filter, Field: 'FieldName', Options: props.CollumnList.map(function (fl) { return ({ Value: fl.key, Label: fl.label }); }), Setter: function (record) {
                    var operator = "IN";
                    var column = props.CollumnList.find(function (fl) { return fl.key === record.FieldName; });
                    if (column !== undefined && column.type === 'string')
                        operator = "LIKE";
                    if (column !== undefined && (column.type === 'number' || column.type === 'integer' || column.type === 'boolean' || column.type === 'datetime'))
                        operator = '=';
                    setFilter(function (prevFilter) { return (__assign(__assign({}, prevFilter), { FieldName: record.FieldName, SearchText: '', Operator: operator, Type: (column !== undefined ? column.type : 'string'), isPivotColumn: (column !== undefined ? column.isPivotField : true) })); });
                }, Label: 'Column' }),
            React.createElement(FilterCreator, { Filter: filter, Field: props.CollumnList.find(function (fl) { return fl.key === filter.FieldName; }), Setter: function (record) { return setFilter(record); }, Enum: (props.GetEnum === undefined ? undefined : props.GetEnum) }))));
}
exports["default"] = SearchBar;
function FilterCreator(props) {
    var _a = React.useState([]), options = _a[0], setOptions = _a[1];
    React.useEffect(function () {
        if (props.Field === undefined)
            return;
        if (props.Field.enum !== undefined)
            setOptions(props.Field.enum);
        if (props.Enum !== undefined)
            return props.Enum(setOptions, props.Field);
        if (props.Field.enum === undefined)
            setOptions([]);
    }, [props.Field, props.Enum]);
    if (props.Field === undefined)
        return null;
    if (props.Field.type === "string") {
        return (React.createElement(React.Fragment, null,
            React.createElement("label", null, "Column type is string. Wildcard (*) can be used with 'LIKE' and 'NOT LIKE'"),
            React.createElement("div", { className: 'row' },
                React.createElement("div", { className: 'col-4' },
                    React.createElement("select", { className: 'form-control', value: props.Filter.Operator, onChange: function (evt) {
                            var value = evt.target.value;
                            props.Setter(function (prevState) { return (__assign(__assign({}, prevState), { Operator: value })); });
                        } },
                        React.createElement("option", { value: 'LIKE' }, "LIKE"),
                        React.createElement("option", { value: '=' }, "="),
                        React.createElement("option", { value: 'NOT LIKE' }, "NOT LIKE"))),
                React.createElement("div", { className: 'col' },
                    React.createElement("input", { className: 'form-control', value: props.Filter.SearchText.replace('$_', '_'), onChange: function (evt) {
                            var value = evt.target.value;
                            props.Setter(function (prevState) { return (__assign(__assign({}, prevState), { SearchText: value.replace('_', '$_') })); });
                        } })))));
    }
    else if (props.Field.type === "integer" || props.Field.type === "number") {
        return (React.createElement(React.Fragment, null,
            React.createElement("label", null,
                "Column type is ",
                props.Field.type,
                "."),
            React.createElement("div", { className: 'row' },
                React.createElement("div", { className: 'col-4' },
                    React.createElement("select", { className: 'form-control', value: props.Filter.Operator, onChange: function (evt) {
                            var value = evt.target.value;
                            props.Setter(function (prevState) { return (__assign(__assign({}, prevState), { Operator: value })); });
                        } },
                        React.createElement("option", { value: '=' }, "="),
                        React.createElement("option", { value: '<>' }, "<>"),
                        React.createElement("option", { value: '>' }, ">"),
                        React.createElement("option", { value: '>=' }, ">="),
                        React.createElement("option", { value: '<' }, "<"),
                        React.createElement("option", { value: '>=' }, ">="))),
                React.createElement("div", { className: 'col' },
                    React.createElement("input", { type: 'number', className: 'form-control', value: props.Filter.SearchText, onChange: function (evt) {
                            var value = evt.target.value;
                            props.Setter(function (prevState) { return (__assign(__assign({}, prevState), { SearchText: value })); });
                        } })))));
    }
    else if (props.Field.type === "datetime") {
        return (React.createElement(React.Fragment, null,
            React.createElement("label", null,
                "Column type is ",
                props.Field.type,
                "."),
            React.createElement("div", { className: 'row' },
                React.createElement("div", { className: 'col-4' },
                    React.createElement("select", { className: 'form-control', value: props.Filter.Operator, onChange: function (evt) {
                            var value = evt.target.value;
                            props.Setter(function (prevState) { return (__assign(__assign({}, prevState), { Operator: value })); });
                        } },
                        React.createElement("option", { value: '=' }, "="),
                        React.createElement("option", { value: '<>' }, "<>"),
                        React.createElement("option", { value: '>' }, ">"),
                        React.createElement("option", { value: '>=' }, ">="),
                        React.createElement("option", { value: '<' }, "<"),
                        React.createElement("option", { value: '>=' }, ">="))),
                React.createElement("div", { className: 'col' },
                    React.createElement("input", { type: 'date', className: 'form-control', value: props.Filter.SearchText.split(' ')[0], onChange: function (evt) {
                            var value = evt.target.value;
                            props.Setter(function (prevState) { return (__assign(__assign({}, prevState), { SearchText: (value + ' ' + (prevState.SearchText.split(' ').length > 1 ? prevState.SearchText.split(' ')[1] : '0:00')) })); });
                        } }),
                    React.createElement("input", { type: 'time', className: 'form-control', value: props.Filter.SearchText.split(' ').length > 1 ? props.Filter.SearchText.split(' ')[1] : '0:00', onChange: function (evt) {
                            var value = evt.target.value;
                            props.Setter(function (prevState) { return (__assign(__assign({}, prevState), { SearchText: (prevState.SearchText.split(' ')[0] + ' ' + value) })); });
                        } })))));
    }
    else if (props.Field.type === "boolean") {
        return React.createElement("div", { className: "form-check" },
            React.createElement("input", { type: "checkbox", className: "form-check-input", style: { zIndex: 1 }, onChange: function (evt) {
                    props.Setter(function (prevFilter) { return (__assign(__assign({}, prevFilter), { Operator: '=', SearchText: evt.target.checked ? "1" : "0" })); });
                }, value: props.Filter.SearchText === "1" ? 'on' : 'off', checked: props.Filter.SearchText === "1" ? true : false }),
            React.createElement("label", { className: "form-check-label" }, "Column type is boolean. Yes/On is checked."));
    }
    else {
        return (React.createElement(React.Fragment, null,
            React.createElement("label", null, "Column type is enumerable. Select from below."),
            React.createElement("ul", { style: { listStyle: 'none' } },
                React.createElement("li", null,
                    React.createElement("div", { className: "form-check" },
                        React.createElement("input", { type: "checkbox", className: "form-check-input", style: { zIndex: 1 }, onChange: function (evt) {
                                if (evt.target.checked)
                                    props.Setter(function (prevSetter) { return (__assign(__assign({}, prevSetter), { SearchText: "(" + options.map(function (x) { return x.Value; }).join(',') + ")" })); });
                                else
                                    props.Setter(function (prevSetter) { return (__assign(__assign({}, prevSetter), { SearchText: '' })); });
                            }, defaultValue: 'off' }),
                        React.createElement("label", { className: "form-check-label" }, "Select All"))),
                options.map(function (vli, index) { return React.createElement("li", { key: index },
                    React.createElement("div", { className: "form-check" },
                        React.createElement("input", { type: "checkbox", className: "form-check-input", style: { zIndex: 1 }, onChange: function (evt) {
                                if (evt.target.checked) {
                                    var list = props.Filter.SearchText.replace('(', '').replace(')', '').split(',');
                                    list = list.filter(function (x) { return x !== ""; });
                                    list.push(vli.Value);
                                    var text_1 = "(" + list.join(',') + ")";
                                    props.Setter(function (prevSetter) { return (__assign(__assign({}, prevSetter), { SearchText: text_1 })); });
                                }
                                else {
                                    var list = props.Filter.SearchText.replace('(', '').replace(')', '').split(',');
                                    list = list.filter(function (x) { return x !== ""; });
                                    list = list.filter(function (x) { return x !== vli.Value; });
                                    var text_2 = "(" + list.join(',') + ")";
                                    props.Setter(function (prevSetter) { return (__assign(__assign({}, prevSetter), { SearchText: text_2 })); });
                                }
                            }, value: props.Filter.SearchText.indexOf(vli.Value) >= 0 ? 'on' : 'off', checked: props.Filter.SearchText.indexOf(vli.Value) >= 0 ? true : false }),
                        React.createElement("label", { className: "form-check-label" }, vli.Label))); }))));
    }
}


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/ServerErrorIcon.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/ServerErrorIcon.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  ServerErrorIcon.tsx - Gbtc
//
//  Copyright © 2021, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  06/19/2021 - Christoph Lackner
//       Generated original version of source code.
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
function ServerErrorIcon(props) {
    var h = (props.Size === undefined ? 25 : props.Size);
    return React.createElement("div", null,
        React.createElement("div", { style: { width: (props.Label === undefined ? h : undefined), margin: 'auto' }, hidden: !props.Show },
            React.createElement("svg", { style: { fill: 'darkred', height: h }, viewBox: '0 0 20 20' },
                React.createElement("path", { d: "M10.185,1.417c-4.741,0-8.583,3.842-8.583,8.583c0,4.74,3.842,8.582,8.583,8.582S18.768,14.74,18.768,10C18.768,5.259,14.926,1.417,10.185,1.417 M10.185,17.68c-4.235,0-7.679-3.445-7.679-7.68c0-4.235,3.444-7.679,7.679-7.679S17.864,5.765,17.864,10C17.864,14.234,14.42,17.68,10.185,17.68 M10.824,10l2.842-2.844c0.178-0.176,0.178-0.46,0-0.637c-0.177-0.178-0.461-0.178-0.637,0l-2.844,2.841L7.341,6.52c-0.176-0.178-0.46-0.178-0.637,0c-0.178,0.176-0.178,0.461,0,0.637L9.546,10l-2.841,2.844c-0.178,0.176-0.178,0.461,0,0.637c0.178,0.178,0.459,0.178,0.637,0l2.844-2.841l2.844,2.841c0.178,0.178,0.459,0.178,0.637,0c0.178-0.176,0.178-0.461,0-0.637L10.824,10z" })),
            props.Label !== undefined ? React.createElement("span", null, props.Label) : null));
}
exports["default"] = ServerErrorIcon;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/TabSelector.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/TabSelector.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  TabSelector.tsx - Gbtc
//
//  Copyright © 2021, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  05/20/2021 - Christoph Lackner
//       Generated original version of source code.
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var helper_functions_1 = __webpack_require__(/*! @gpa-gemstone/helper-functions */ "./node_modules/@gpa-gemstone/helper-functions/lib/index.js");
var TabSelector = function (props) {
    var _a = React.useState(1), nVisible = _a[0], setNVisible = _a[1];
    var _b = React.useState(100), width = _b[0], setWidth = _b[1];
    var _c = React.useState((0, helper_functions_1.CreateGuid)()), guid = _c[0], setGuid = _c[1];
    var _d = React.useState(false), dropDownOpen = _d[0], setDropDownOpen = _d[1];
    React.useEffect(function () {
        setDropDownOpen(false);
    }, [props.CurrentTab]);
    React.useLayoutEffect(function () {
        var target = document.getElementById(guid);
        var w = 100;
        if (target !== undefined)
            w = (0, helper_functions_1.GetNodeSize)(target).width;
        if (w !== width)
            setWidth(w);
    });
    React.useEffect(function () {
        var Wtext = 40;
        var Ntext = 0;
        while (Ntext < props.Tabs.length) {
            var w = 2 * 17 + (0, helper_functions_1.GetTextWidth)("Segoe UI", '14px', props.Tabs[Ntext].Label) + 1;
            if (Wtext + w > (width - 2))
                break;
            Wtext = Wtext + w;
            Ntext = Ntext + 1;
        }
        setNVisible(Ntext);
    }, [width, props.Tabs]);
    var showExp = nVisible < props.Tabs.length;
    if (width < 50)
        return React.createElement("div", { style: { width: '100%' }, id: guid }, " ");
    return React.createElement("div", { style: { width: '100%' }, id: guid },
        React.createElement("ul", { className: "nav nav-tabs", style: { maxHeight: 38 } },
            props.Tabs.map(function (t, i) { return i > (nVisible - 1) ? null :
                React.createElement("li", { className: "nav-item", key: i },
                    React.createElement("a", { className: "nav-link" + (props.CurrentTab === t.Id ? " active" : ""), onClick: function () { return props.SetTab(t.Id); } }, t.Label)); }),
            showExp ?
                React.createElement("li", { className: "nav-item dropdown" + (dropDownOpen ? ' show' : '') },
                    React.createElement("a", { className: "nav-link dropdown-toggle", onClick: function () { return setDropDownOpen(function (s) { return !s; }); } }, "..."),
                    React.createElement("div", { className: "dropdown-menu dropdown-menu-right" + (dropDownOpen ? ' show' : '') }, props.Tabs.map(function (t, i) { return i > (nVisible - 1) ?
                        React.createElement("a", { className: "dropdown-item" + props.CurrentTab === t.Id ? ' active' : '', onClick: function () { return props.SetTab(t.Id); }, key: i }, t.Label) : null; }))) : null));
};
exports["default"] = TabSelector;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/ToolTip.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/ToolTip.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// ******************************************************************************************************
//  ToolTip.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  01/14/2021 - Christoph Lackner
//       Generated original version of source code.
// ******************************************************************************************************
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var styled_components_1 = __webpack_require__(/*! styled-components */ "./node_modules/styled-components/dist/styled-components.browser.esm.js");
var helper_functions_1 = __webpack_require__(/*! @gpa-gemstone/helper-functions */ "./node_modules/@gpa-gemstone/helper-functions/lib/index.js");
var WrapperDiv = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  & {\n    border-radius: 3px;\n    display: inline-block;\n    font-size: 13px;\n    padding: 8px 21px;\n    position: fixed;\n    pointer-events: none;\n    transition: opacity 0.3s ease-out;\n    z-index: ", ";\n    opacity: ", ";\n    color: ", ";\n    background: ", ";\n    top: ", ";\n    left: ", ";\n    border: 1px solid transparent;\n  }\n  ", "\n  ", "\n  ", "\n  ", ""], ["\n  & {\n    border-radius: 3px;\n    display: inline-block;\n    font-size: 13px;\n    padding: 8px 21px;\n    position: fixed;\n    pointer-events: none;\n    transition: opacity 0.3s ease-out;\n    z-index: ", ";\n    opacity: ", ";\n    color: ", ";\n    background: ", ";\n    top: ", ";\n    left: ", ";\n    border: 1px solid transparent;\n  }\n  ", "\n  ", "\n  ", "\n  ", ""
    // The other element needs to be labeld as data-tooltip that will only be used for positioning
])), function (props) { return props.Zindex; }, function (props) { return props.Show ? "0.9" : "0"; }, function (props) { return (props.Theme === 'dark' ? "#fff" : '#222'); }, function (props) { return (props.Theme === 'dark' ? "#222" : '#fff'); }, function (props) { return props.Top + "px"; }, function (props) { return props.Left + "px"; }, function (props) { return (props.Location === 'top' ? "\n    &::after {\n     border-left: 8px solid transparent;\n     border-right: 8px solid transparent;\n     border-top: 8px solid " + (props.Theme === 'dark' ? "#222" : '#fff') + ";\n     left: 50%;\n     bottom: -6px;\n     margin-left: -8px;\n     content: \"\";\n     width: 0px;\n     height: 0px;\n     position: absolute\n    }\n  " : ''); }, function (props) { return (props.Location === 'bottom' ? "\n    &::before {\n     border-left: 8px solid transparent;\n     border-right: 8px solid transparent;\n     border-bottom: 8px solid " + (props.Theme === 'dark' ? "#222" : '#fff') + ";\n     left: 50%;\n     top: -6px;\n     margin-left: -8px;\n     content: \"\";\n     width: 0px;\n     height: 0px;\n     position: absolute\n    }\n  " : ''); }, function (props) { return (props.Location === 'left' ? "\n    &::before {\n     border-top: 8px solid transparent;\n     border-bottom: 8px solid transparent;\n     border-left: 8px solid " + (props.Theme === 'dark' ? "#222" : '#fff') + ";\n     top: 50%;\n     left: 100%;\n     margin-top: -8px;\n     content: \"\";\n     width: 0px;\n     height: 0px;\n     position: absolute\n    }\n  " : ''); }, function (props) { return (props.Location === 'right' ? "\n    &::before {\n     border-top: 8px solid transparent;\n     border-bottom: 8px solid transparent;\n     border-right: 8px solid " + (props.Theme === 'dark' ? "#222" : '#fff') + ";\n     top: 50%;\n     left: -6px;\n     margin-top: -8px;\n     content: \"\";\n     width: 0px;\n     height: 0px;\n     position: absolute\n    }\n  " : ''); });
// The other element needs to be labeld as data-tooltip that will only be used for positioning
var ToolTip = function (props) {
    var _a = React.useState(0), top = _a[0], setTop = _a[1];
    var _b = React.useState(0), left = _b[0], setLeft = _b[1];
    var _c = React.useState(""), guid = _c[0], setGuid = _c[1];
    React.useEffect(function () {
        setGuid((0, helper_functions_1.CreateGuid)());
    }, []);
    React.useLayoutEffect(function () {
        var _a = UpdatePosition(), t = _a[0], l = _a[1];
        if (t !== top)
            setTop(t);
        if (l !== left)
            setLeft(l);
    });
    var zIndex = (props.Zindex === undefined ? 2000 : props.Zindex);
    function UpdatePosition() {
        var target = document.querySelectorAll("[data-tooltip" + (props.Target === undefined ? '' : "=\"" + props.Target + "\"") + "]");
        if (target.length === 0)
            return [-999, -999];
        var targetLocation = (0, helper_functions_1.GetNodeSize)(target[0]);
        var toolTip = document.getElementById(guid);
        if (toolTip === null)
            return [-999, -999];
        var tipLocation = (0, helper_functions_1.GetNodeSize)(toolTip);
        var offset = 5;
        var result = [0, 0];
        if (props.Position === 'left') {
            result[0] = targetLocation.top + 0.5 * targetLocation.height - 0.5 * tipLocation.height;
            result[1] = targetLocation.left - tipLocation.width - offset;
        }
        else if (props.Position === 'right') {
            result[0] = targetLocation.top + 0.5 * targetLocation.height - 0.5 * tipLocation.height;
            result[1] = targetLocation.left + targetLocation.width + offset;
        }
        else if (props.Position === 'top' || props.Position === undefined) {
            result[0] = targetLocation.top - tipLocation.height - offset;
            result[1] = targetLocation.left + 0.5 * targetLocation.width - 0.5 * tipLocation.width;
        }
        else if (props.Position === 'bottom') {
            result[0] = targetLocation.top + targetLocation.height + offset;
            result[1] = targetLocation.left + 0.5 * targetLocation.width - 0.5 * tipLocation.width;
        }
        return result;
    }
    var theme = (props.Theme === undefined ? 'dark' : props.Theme);
    return (React.createElement(WrapperDiv, { Show: props.Show, Theme: theme, Top: top, Left: left, id: guid, Location: props.Position === undefined ? 'top' : props.Position, Zindex: zIndex }, props.children));
};
exports["default"] = ToolTip;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/Warning.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/Warning.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  Warning.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  12/29/2020 - Christoph Lackner
//       Generated original version of source code.
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var Modal_1 = __webpack_require__(/*! ./Modal */ "./node_modules/@gpa-gemstone/react-interactive/lib/Modal.js");
// Usage:
// <Warning Title='This is a Warning' Message={'Are you sure you want to Continue?'} Callback={(canceled) => setShow(false)} Show={show} />
//
// Props Description:
// Title => Title of The Modal
// CallBack => Function to be called when closing the Modal either through Cancel (confirmed=false) or Confirm Button (confirmed=true)
// Show => Whether to show the modal
// Message => The message shown by the Modal
var Warning = function (props) {
    return (React.createElement(Modal_1.default, { Title: props.Title, Show: props.Show, CancelBtnClass: 'btn-danger', CancelText: 'Cancel', ConfirmBtnClass: 'btn-success', ConfirmText: 'Confirm', ShowX: false, ShowCancel: true, Size: 'sm', CallBack: function (confirmed) { return props.CallBack(confirmed); } },
        React.createElement("p", null, props.Message)));
};
exports["default"] = Warning;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  index.tsx - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  12/29/2020 - C. Lackner Ernest
//       Generated original version of source code.
//
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterableTable = exports.Section = exports.Page = exports.Application = exports.ConfigurableTable = exports.GenericSlice = exports.ServerErrorIcon = exports.TabSelector = exports.ToolTip = exports.LoadingIcon = exports.LoadingScreen = exports.SearchBar = exports.Warning = exports.Modal = void 0;
var Modal_1 = __webpack_require__(/*! ./Modal */ "./node_modules/@gpa-gemstone/react-interactive/lib/Modal.js");
exports.Modal = Modal_1.default;
var Warning_1 = __webpack_require__(/*! ./Warning */ "./node_modules/@gpa-gemstone/react-interactive/lib/Warning.js");
exports.Warning = Warning_1.default;
var SearchBar_1 = __webpack_require__(/*! ./SearchBar */ "./node_modules/@gpa-gemstone/react-interactive/lib/SearchBar.js");
exports.SearchBar = SearchBar_1.default;
var LoadingScreen_1 = __webpack_require__(/*! ./LoadingScreen */ "./node_modules/@gpa-gemstone/react-interactive/lib/LoadingScreen.js");
exports.LoadingScreen = LoadingScreen_1.default;
var LoadingIcon_1 = __webpack_require__(/*! ./LoadingIcon */ "./node_modules/@gpa-gemstone/react-interactive/lib/LoadingIcon.js");
exports.LoadingIcon = LoadingIcon_1.default;
var ToolTip_1 = __webpack_require__(/*! ./ToolTip */ "./node_modules/@gpa-gemstone/react-interactive/lib/ToolTip.js");
exports.ToolTip = ToolTip_1.default;
var TabSelector_1 = __webpack_require__(/*! ./TabSelector */ "./node_modules/@gpa-gemstone/react-interactive/lib/TabSelector.js");
exports.TabSelector = TabSelector_1.default;
var ServerErrorIcon_1 = __webpack_require__(/*! ./ServerErrorIcon */ "./node_modules/@gpa-gemstone/react-interactive/lib/ServerErrorIcon.js");
exports.ServerErrorIcon = ServerErrorIcon_1.default;
var GenericSlice_1 = __webpack_require__(/*! ./GenericSlice */ "./node_modules/@gpa-gemstone/react-interactive/lib/GenericSlice.js");
exports.GenericSlice = GenericSlice_1.default;
var ConfigurableTable_1 = __webpack_require__(/*! ./ConfigurableTable */ "./node_modules/@gpa-gemstone/react-interactive/lib/ConfigurableTable.js");
exports.ConfigurableTable = ConfigurableTable_1.default;
var Application_1 = __webpack_require__(/*! ./Menue/Application */ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Application.js");
exports.Application = Application_1.default;
var Page_1 = __webpack_require__(/*! ./Menue/Page */ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Page.js");
exports.Page = Page_1.default;
var Section_1 = __webpack_require__(/*! ./Menue/Section */ "./node_modules/@gpa-gemstone/react-interactive/lib/Menue/Section.js");
exports.Section = Section_1.default;
var FilterableTable_1 = __webpack_require__(/*! ./FilterableTable/FilterableTable */ "./node_modules/@gpa-gemstone/react-interactive/lib/FilterableTable/FilterableTable.js");
exports.FilterableTable = FilterableTable_1.default;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/DynamicTable.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/DynamicTable.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  DynamicTable.tsx - Gbtc
//
//  Copyright © 2021, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  07/26/2021 - Billy Ernest
//       Generated original version of source code.
//
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicTable = void 0;
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var Table_1 = __webpack_require__(/*! ./Table */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/Table.js");
function DynamicTable(props) {
    if (props.data.length <= 0)
        return null;
    var cols = [];
    var keys = Object.keys(props.data[0]);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        cols.push({ key: key, label: key, field: key });
    }
    return (React.createElement("table", { className: props.tableClass !== undefined ? props.tableClass : '', style: props.tableStyle },
        React.createElement(Table_1.Header, { Class: props.theadClass, Style: props.theadStyle, Cols: cols, SortKey: props.sortKey, Ascending: props.ascending, Click: function (d, e) { return handleSort(d, e); } }),
        React.createElement(Table_1.Rows, { Data: props.data, Cols: cols, RowStyle: props.rowStyle, BodyStyle: props.tbodyStyle, BodyClass: props.tbodyClass, Click: function (data, e) { return props.onClick(data, e); }, Selected: props.selected, KeySelector: props.keySelector })));
    function handleSort(data, event) {
        if (data.colKey !== null)
            props.onSort(data);
    }
}
exports.DynamicTable = DynamicTable;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/SearchableTable.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/SearchableTable.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// ******************************************************************************************************
//  SearchableTable.tsx - Gbtc
//
//  Copyright © 2021, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  07/12/2021 - C. Lackner
//       Generated original version of source code.
//
// ******************************************************************************************************
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchableTable = void 0;
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var Table_1 = __webpack_require__(/*! ./Table */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/Table.js");
/**
 * A Table with an input Field to search on top
 */
function SearchableTable(props) {
    var _a = React.useState(props.data), data = _a[0], setData = _a[1];
    var _b = React.useState(''), searchTextAS = _b[0], setSearchTextAS = _b[1];
    React.useEffect(function () {
        setData(props.data.filter(function (s) { return props.matchSearch(s, searchTextAS); }));
    }, [props.data, searchTextAS]);
    return React.createElement(React.Fragment, null,
        React.createElement("input", { className: "form-control", placeholder: "Search filter for select box ...", value: searchTextAS, onChange: function (e) { return setSearchTextAS(e.target.value); } }),
        React.createElement(Table_1.default, __assign({}, props, { data: data })));
}
exports.SearchableTable = SearchableTable;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/SelectTable.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/SelectTable.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// ******************************************************************************************************
//  SelectTable.tsx - Gbtc
//
//  Copyright © 2021, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  01/22/2021 - C. Lackner
//       Generated original version of source code.
//
// ******************************************************************************************************
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectTable = void 0;
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var Table_1 = __webpack_require__(/*! ./Table */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/Table.js");
function SelectTable(props) {
    var didMountRef = React.useRef(false);
    var _a = React.useState(props.data), data = _a[0], setData = _a[1];
    var _b = React.useState([]), selected = _b[0], setSelected = _b[1];
    var _c = React.useState(props.sortKey), sortKey = _c[0], setSortKey = _c[1];
    var _d = React.useState(props.ascending), ascending = _d[0], setAscending = _d[1];
    React.useEffect(function () {
        if (didMountRef.current)
            selectAll();
        else
            didMountRef.current = true;
    }, [props.selectAllCounter]);
    React.useEffect(function () {
        if (props.data.length !== data.length)
            setData(props.data);
    }, [props.data]);
    React.useEffect(function () {
        setSelected(function (d) { return d.filter(function (keyItem) { return data.findIndex(function (item) { return item[props.KeyField] === keyItem; }) > -1; }); });
    }, [data]);
    React.useEffect(function () {
        var sortColumn = props.cols.filter(function (col) { return col.key === sortKey; })[0];
        if (sortColumn === undefined || sortColumn.field === undefined)
            return;
        var sortField = sortColumn.field;
        setData(function (lst) { return (_.orderBy(lst, [sortField], [(ascending ? "asc" : "desc")])); });
    }, [ascending, sortKey]);
    React.useEffect(function () {
        props.onSelection(data.filter(function (item) { return selected.findIndex(function (key) { return key === item[props.KeyField]; }) > -1; }));
    }, [selected]);
    function handleClick(d, event) {
        var sIndex = selected.findIndex(function (item) { return item === d.row[props.KeyField]; });
        if (sIndex === -1)
            setSelected(function (od) { return __spreadArray(__spreadArray([], od, true), [d.row[props.KeyField]], false); });
        else
            setSelected(function (od) { return od.filter(function (item) { return item !== d.row[props.KeyField]; }); });
    }
    function selectAll() {
        setSelected(function (d) { if (d.length === data.length)
            return [];
        else
            return data.map(function (row) { return row[props.KeyField]; }); });
    }
    function handleSort(d) {
        if (d.colKey === sortKey)
            setAscending(!ascending);
        else
            setSortKey(d.colKey);
    }
    var tableProps = {
        cols: __spreadArray([
            { key: 'gemstone-checkbox', field: props.KeyField, label: '', headerStyle: { width: '4em' }, rowStyle: { width: '4em' }, content: function (item, key, field, style) {
                    var index = selected.findIndex(function (i) { return i === item[props.KeyField]; });
                    if (index > -1)
                        return React.createElement("div", { style: { marginTop: '16px', textAlign: 'center' } },
                            React.createElement("i", { className: "fa fa-check-square-o fa-3x" }));
                    return null;
                } }
        ], props.cols, true),
        data: data,
        onClick: handleClick,
        sortKey: sortKey,
        ascending: ascending,
        onSort: handleSort,
        tableClass: props.tableClass,
        tableStyle: props.tableStyle,
        theadStyle: props.theadStyle,
        theadClass: props.theadClass,
        tbodyStyle: props.tbodyStyle,
        tbodyClass: props.tbodyClass,
        selected: function (d) { return false; },
        rowStyle: props.rowStyle
    };
    return React.createElement(Table_1.default, __assign({}, tableProps));
}
exports.SelectTable = SelectTable;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/Table.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/Table.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


//  ******************************************************************************************************
//  Table.tsx - Gbtc
//
//  Copyright © 2018, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/02/2018 - Billy Ernest
//       Generated original version of source code.
//
//  ******************************************************************************************************
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Header = exports.Rows = void 0;
var gpa_symbols_1 = __webpack_require__(/*! @gpa-gemstone/gpa-symbols */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/node_modules/@gpa-gemstone/gpa-symbols/lib/index.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
function Table(props) {
    return (React.createElement("table", { className: props.tableClass !== undefined ? props.tableClass : '', style: props.tableStyle },
        React.createElement(Header, { Class: props.theadClass, Style: props.theadStyle, Cols: props.cols, SortKey: props.sortKey, Ascending: props.ascending, Click: function (d, e) { return handleSort(d, e); } }),
        React.createElement(Rows, { Data: props.data, Cols: props.cols, RowStyle: props.rowStyle, BodyStyle: props.tbodyStyle, BodyClass: props.tbodyClass, Click: function (data, e) { return (props.onClick === undefined ? null : props.onClick(data, e)); }, Selected: props.selected, KeySelector: props.keySelector })));
    function handleSort(data, event) {
        if (data.colKey !== null)
            props.onSort(data);
    }
}
exports["default"] = Table;
function Rows(props) {
    if (props.Data.length === 0)
        return null;
    var rows = props.Data.map(function (item, rowIndex) {
        var cells = props.Cols.map(function (colData) {
            return React.createElement(Cell, { key: colData.key, Style: colData.rowStyle, DataKey: colData.key, DataField: colData.field, Object: item, RowIndex: rowIndex, Content: colData.content, Click: function (data, e) { return props.Click(data, e); } });
        });
        var style = (props.RowStyle !== undefined) ? __assign({}, props.RowStyle) : {};
        if (style.cursor === undefined)
            style.cursor = 'pointer';
        if (props.Selected !== undefined && props.Selected(item))
            style.backgroundColor = 'yellow';
        function ToKey(index, data) {
            if (props.KeySelector === undefined)
                return index.toString();
            return props.KeySelector(data);
        }
        return (React.createElement("tr", { style: style, key: ToKey(rowIndex, item) }, cells));
    });
    return (React.createElement("tbody", { style: props.BodyStyle, className: props.BodyClass }, rows));
}
exports.Rows = Rows;
function Cell(props) {
    var css = (props.Style !== undefined) ? __assign({}, props.Style) : {};
    var getFieldValue = function () { return props.DataField !== undefined ? props.Object[props.DataField] : null; };
    var getFieldContent = function () { return props.Content !== undefined ? props.Content(props.Object, props.DataKey, props.DataField, css, props.RowIndex) : getFieldValue(); };
    return (React.createElement("td", { style: css, onClick: function (e) { return props.Click({ colKey: props.DataKey, colField: props.DataField, row: props.Object, data: getFieldValue(), index: props.RowIndex }, e); } }, getFieldContent()));
}
function Header(props) {
    return (React.createElement("thead", { className: props.Class, style: props.Style },
        React.createElement("tr", null, props.Cols.map(function (col) { return React.createElement(HeaderCell, { key: col.key, HeaderStyle: col.headerStyle, DataKey: col.key, Click: function (e) { return props.Click({ colKey: col.key, colField: col.field, ascending: props.Ascending }, e); }, Label: col.label, SortKey: props.SortKey, Ascending: props.Ascending }); }))));
}
exports.Header = Header;
function HeaderCell(props) {
    var style = (props.HeaderStyle !== undefined) ? props.HeaderStyle : {};
    if (style.cursor === undefined && props.DataKey !== null) {
        style.cursor = 'pointer';
    }
    if (style.position === undefined) {
        style.position = 'relative';
    }
    return (React.createElement("th", { style: style, onClick: function (e) { return props.Click(e); } },
        React.createElement("div", { style: { position: 'absolute', width: 25 } },
            React.createElement(RenderAngleIcon, { SortKey: props.SortKey, Key: props.DataKey, Ascending: props.Ascending })),
        React.createElement("div", { style: { marginLeft: 25 } }, props.Label)));
}
function RenderAngleIcon(props) {
    var AngleIcon = function (a) { return a.ascending ? gpa_symbols_1.SVGIcons.ArrowDropUp : gpa_symbols_1.SVGIcons.ArrowDropDown; };
    if (props.SortKey === null)
        return null;
    if (props.SortKey !== props.Key)
        return null;
    return React.createElement(AngleIcon, { ascending: props.Ascending });
}
;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/index.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/index.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


//  ******************************************************************************************************
//  index.tsx - Gbtc
//
//  Copyright © 2018, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/02/2018 - Billy Ernest
//       Generated original version of source code.
//  02/12/2021 - C. lackner
//       Moved table to seperate File.
//
//  ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rows = exports.DynamicTable = exports.SearchableTable = exports.SelectTable = void 0;
var Table_1 = __webpack_require__(/*! ./Table */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/Table.js");
Object.defineProperty(exports, "Rows", ({ enumerable: true, get: function () { return Table_1.Rows; } }));
var SelectTable_1 = __webpack_require__(/*! ./SelectTable */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/SelectTable.js");
Object.defineProperty(exports, "SelectTable", ({ enumerable: true, get: function () { return SelectTable_1.SelectTable; } }));
var SearchableTable_1 = __webpack_require__(/*! ./SearchableTable */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/SearchableTable.js");
Object.defineProperty(exports, "SearchableTable", ({ enumerable: true, get: function () { return SearchableTable_1.SearchableTable; } }));
var DynamicTable_1 = __webpack_require__(/*! ./DynamicTable */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/lib/DynamicTable.js");
Object.defineProperty(exports, "DynamicTable", ({ enumerable: true, get: function () { return DynamicTable_1.DynamicTable; } }));
exports["default"] = Table_1.default;


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/node_modules/@gpa-gemstone/gpa-symbols/lib/SVGIcons.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/node_modules/@gpa-gemstone/gpa-symbols/lib/SVGIcons.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SVGIcons = void 0;
// ******************************************************************************************************
//  SVGIcons.tsx - Gbtc
//
//  Copyright © 2022, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/17/2022 - C Lackner
//       Generated original version of source code.
//
// ******************************************************************************************************
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var SVGIcons;
(function (SVGIcons) {
    SVGIcons.DataContainer = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-file" },
        React.createElement("path", { d: "M 3,4.5 a 9,4.5 0,0,0 18 3 a 9,4.5 0,0,0 -18 0 l 0,11 a 9,4.5 0,0,0 18 0 l 0,-11" }));
    SVGIcons.Cube = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-file" },
        React.createElement("rect", { x: "1", y: "8", width: "15", height: "15" }),
        React.createElement("rect", { x: "6", y: "3", width: "15", height: "15" }),
        React.createElement("line", { x1: "1", x2: "6", y1: "8", y2: "3" }),
        React.createElement("line", { x1: "16", x2: "21", y1: "8", y2: "3" }),
        React.createElement("line", { x1: "16", x2: "21", y1: "23", y2: "18" }),
        React.createElement("line", { x1: "1", x2: "6", y1: "23", y2: "18" }));
    SVGIcons.House = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-home" },
        React.createElement("path", { d: "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" }),
        React.createElement("polyline", { points: "9 22 9 12 15 12 15 22" }));
    SVGIcons.Document = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-file-text" },
        React.createElement("path", { d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" }),
        React.createElement("polyline", { points: "14 2 14 8 20 8" }),
        React.createElement("line", { x1: "16", y1: "13", x2: "8", y2: "13" }),
        React.createElement("line", { x1: "16", y1: "17", x2: "8", y2: "17" }),
        React.createElement("polyline", { points: "10 9 9 9 8 9" }));
    SVGIcons.ArrowForward = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "currentColor", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-file-text" },
        React.createElement("polygon", { points: "6.23,20.23 8,22 18,12 8,2 6.23,3.77 14.46,12" }));
    SVGIcons.ArrowBackward = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "currentColor", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-file-text" },
        React.createElement("polygon", { points: "17.77,3.77 16,2 6,12 16,22 17.77,20.23 9.54,12" }));
    SVGIcons.ArrowDropUp = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "currentColor", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-file-text" },
        React.createElement("path", { d: "M7 14l5-5 5 5z" }));
    SVGIcons.ArrowDropDown = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "currentColor", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-file-text" },
        React.createElement("path", { d: "M7 10l5 5 5-5z" }));
    SVGIcons.Settings = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-file-text" },
        React.createElement("path", { d: "M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z" }));
    SVGIcons.Filter = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-file-text" },
        React.createElement("path", { d: "M4.25,5.61C6.27,8.2,10,13,10,13v6c0,0.55,0.45,1,1,1h2c0.55,0,1-0.45,1-1v-6c0,0,3.72-4.8,5.74-7.39 C20.25,4.95,19.78,4,18.95,4H5.04C4.21,4,3.74,4.95,4.25,5.61z" }));
})(SVGIcons = exports.SVGIcons || (exports.SVGIcons = {}));


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/node_modules/@gpa-gemstone/gpa-symbols/lib/index.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/node_modules/@gpa-gemstone/gpa-symbols/lib/index.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// ******************************************************************************************************
//  index.tsx - Gbtc
//
//  Copyright © 2021, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  09/30/2020 - Billy Ernest
//       Generated original version of source code.
//
// ******************************************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SVGIcons = exports.Questionmark = exports.RewindButton = exports.FastForwardButton = exports.PauseButton = exports.StopButton = exports.PlayButton = exports.Scroll = exports.House = exports.MagnifyingGlass = exports.FourWayArrow = exports.InputNumbers = exports.DNA = exports.DownArrow = exports.RightArrow = exports.LeftArrow = exports.UpArrow = exports.Flag = exports.Wrench = exports.Spinner = exports.Warning = exports.Plus = exports.CrossMark = exports.TrashCan = exports.Pencil = exports.HeavyCheckMark = void 0;
var SVGIcons_1 = __webpack_require__(/*! ./SVGIcons */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@gpa-gemstone/react-table/node_modules/@gpa-gemstone/gpa-symbols/lib/SVGIcons.js");
Object.defineProperty(exports, "SVGIcons", ({ enumerable: true, get: function () { return SVGIcons_1.SVGIcons; } }));
exports.HeavyCheckMark = '✔️';
exports.Pencil = '✏️';
exports.TrashCan = '🗑️';
exports.CrossMark = '❌';
exports.Plus = '➕';
exports.Warning = '⚠️';
exports.Spinner = '🔄';
exports.Wrench = '🔧';
exports.Flag = '🚩';
exports.UpArrow = '⬆️';
exports.LeftArrow = '⬅';
exports.RightArrow = '➡';
exports.DownArrow = '⬇️';
exports.DNA = '🧬';
exports.InputNumbers = '🔢';
exports.FourWayArrow = '☩';
exports.MagnifyingGlass = '🔍';
exports.House = '🏠';
exports.Scroll = '📜';
exports.PlayButton = '▶️';
exports.StopButton = '⏹️';
exports.PauseButton = '⏸️';
exports.FastForwardButton = '⏩';
exports.RewindButton = '⏪';
exports.Questionmark = '?';


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MiddlewareArray": () => (/* binding */ MiddlewareArray),
/* harmony export */   "__DO_NOT_USE__ActionTypes": () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),
/* harmony export */   "applyMiddleware": () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),
/* harmony export */   "bindActionCreators": () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),
/* harmony export */   "combineReducers": () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),
/* harmony export */   "compose": () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),
/* harmony export */   "configureStore": () => (/* binding */ configureStore),
/* harmony export */   "createAction": () => (/* binding */ createAction),
/* harmony export */   "createAsyncThunk": () => (/* binding */ createAsyncThunk),
/* harmony export */   "createDraftSafeSelector": () => (/* binding */ createDraftSafeSelector),
/* harmony export */   "createEntityAdapter": () => (/* binding */ createEntityAdapter),
/* harmony export */   "createImmutableStateInvariantMiddleware": () => (/* binding */ createImmutableStateInvariantMiddleware),
/* harmony export */   "createNextState": () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "createReducer": () => (/* binding */ createReducer),
/* harmony export */   "createSelector": () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),
/* harmony export */   "createSerializableStateInvariantMiddleware": () => (/* binding */ createSerializableStateInvariantMiddleware),
/* harmony export */   "createSlice": () => (/* binding */ createSlice),
/* harmony export */   "createStore": () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),
/* harmony export */   "current": () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),
/* harmony export */   "findNonSerializableValue": () => (/* binding */ findNonSerializableValue),
/* harmony export */   "freeze": () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),
/* harmony export */   "getDefaultMiddleware": () => (/* binding */ getDefaultMiddleware),
/* harmony export */   "getType": () => (/* binding */ getType),
/* harmony export */   "isAllOf": () => (/* binding */ isAllOf),
/* harmony export */   "isAnyOf": () => (/* binding */ isAnyOf),
/* harmony export */   "isAsyncThunkAction": () => (/* binding */ isAsyncThunkAction),
/* harmony export */   "isDraft": () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),
/* harmony export */   "isFulfilled": () => (/* binding */ isFulfilled),
/* harmony export */   "isImmutableDefault": () => (/* binding */ isImmutableDefault),
/* harmony export */   "isPending": () => (/* binding */ isPending),
/* harmony export */   "isPlain": () => (/* binding */ isPlain),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isRejected": () => (/* binding */ isRejected),
/* harmony export */   "isRejectedWithValue": () => (/* binding */ isRejectedWithValue),
/* harmony export */   "legacy_createStore": () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),
/* harmony export */   "miniSerializeError": () => (/* binding */ miniSerializeError),
/* harmony export */   "nanoid": () => (/* binding */ nanoid),
/* harmony export */   "original": () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),
/* harmony export */   "unwrapResult": () => (/* binding */ unwrapResult)
/* harmony export */ });
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ "./node_modules/redux/es/redux.js");
/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ "./node_modules/immer/dist/immer.esm.mjs");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ "./node_modules/reselect/es/index.js");
/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ "./node_modules/redux-thunk/es/index.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __defProp = Object.defineProperty;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = function (obj, key, value) { return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value }) : obj[key] = value; };
var __objSpread = function (a, b) {
    for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var _i = 0, _b = __getOwnPropSymbols(b); _i < _b.length; _i++) {
            var prop = _b[_i];
            if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
var __async = function (__this, __arguments, generator) {
    return new Promise(function (resolve, reject) {
        var fulfilled = function (value) {
            try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            }
        };
        var rejected = function (value) {
            try {
                step(generator.throw(value));
            }
            catch (e) {
                reject(e);
            }
        };
        var step = function (x) { return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected); };
        step((generator = generator.apply(__this, __arguments)).next());
    });
};
// src/index.ts



// src/createDraftSafeSelector.ts


var createDraftSafeSelector = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var selector = reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector.apply(void 0, args);
    var wrappedSelector = function (value) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        return selector.apply(void 0, __spreadArray([(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value], rest));
    };
    return wrappedSelector;
};
// src/configureStore.ts

// src/devtoolsExtension.ts

var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
    if (arguments.length === 0)
        return void 0;
    if (typeof arguments[0] === "object")
        return redux__WEBPACK_IMPORTED_MODULE_0__.compose;
    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function () {
    return function (noop) {
        return noop;
    };
};
// src/isPlainObject.ts
function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
        return false;
    var proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
}
// src/getDefaultMiddleware.ts

// src/utils.ts
function getTimeMeasureUtils(maxDelay, fnName) {
    var elapsed = 0;
    return {
        measureTime: function (fn) {
            var started = Date.now();
            try {
                return fn();
            }
            finally {
                var finished = Date.now();
                elapsed += finished - started;
            }
        },
        warnIfExceeded: function () {
            if (elapsed > maxDelay) {
                console.warn(fnName + " took " + elapsed + "ms, which is more than the warning threshold of " + maxDelay + "ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.");
            }
        }
    };
}
var MiddlewareArray = /** @class */ (function (_super) {
    __extends(MiddlewareArray, _super);
    function MiddlewareArray() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, args) || this;
        Object.setPrototypeOf(_this, MiddlewareArray.prototype);
        return _this;
    }
    Object.defineProperty(MiddlewareArray, Symbol.species, {
        get: function () {
            return MiddlewareArray;
        },
        enumerable: false,
        configurable: true
    });
    MiddlewareArray.prototype.concat = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        return _super.prototype.concat.apply(this, arr);
    };
    MiddlewareArray.prototype.prepend = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        if (arr.length === 1 && Array.isArray(arr[0])) {
            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr[0].concat(this))))();
        }
        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr.concat(this))))();
    };
    return MiddlewareArray;
}(Array));
// src/immutableStateInvariantMiddleware.ts
var isProduction = "development" === "production";
var prefix = "Invariant failed";
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    throw new Error(prefix + ": " + (message || ""));
}
function stringify(obj, serializer, indent, decycler) {
    return JSON.stringify(obj, getSerialize(serializer, decycler), indent);
}
function getSerialize(serializer, decycler) {
    var stack = [], keys = [];
    if (!decycler)
        decycler = function (_, value) {
            if (stack[0] === value)
                return "[Circular ~]";
            return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        };
    return function (key, value) {
        if (stack.length > 0) {
            var thisPos = stack.indexOf(this);
            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
            if (~stack.indexOf(value))
                value = decycler.call(this, key, value);
        }
        else
            stack.push(value);
        return serializer == null ? value : serializer.call(this, key, value);
    };
}
function isImmutableDefault(value) {
    return typeof value !== "object" || value === null || typeof value === "undefined" || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
    var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
    return {
        detectMutations: function () {
            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
        }
    };
}
function trackProperties(isImmutable, ignorePaths, obj, path) {
    if (ignorePaths === void 0) { ignorePaths = []; }
    if (path === void 0) { path = ""; }
    var tracked = { value: obj };
    if (!isImmutable(obj)) {
        tracked.children = {};
        for (var key in obj) {
            var childPath = path ? path + "." + key : key;
            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
                continue;
            }
            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
        }
    }
    return tracked;
}
function detectMutations(isImmutable, ignorePaths, trackedProperty, obj, sameParentRef, path) {
    if (ignorePaths === void 0) { ignorePaths = []; }
    if (sameParentRef === void 0) { sameParentRef = false; }
    if (path === void 0) { path = ""; }
    var prevObj = trackedProperty ? trackedProperty.value : void 0;
    var sameRef = prevObj === obj;
    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
        return { wasMutated: true, path: path };
    }
    if (isImmutable(prevObj) || isImmutable(obj)) {
        return { wasMutated: false };
    }
    var keysToDetect = {};
    for (var key in trackedProperty.children) {
        keysToDetect[key] = true;
    }
    for (var key in obj) {
        keysToDetect[key] = true;
    }
    for (var key in keysToDetect) {
        var childPath = path ? path + "." + key : key;
        if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
            continue;
        }
        var result = detectMutations(isImmutable, ignorePaths, trackedProperty.children[key], obj[key], sameRef, childPath);
        if (result.wasMutated) {
            return result;
        }
    }
    return { wasMutated: false };
}
function createImmutableStateInvariantMiddleware(options) {
    if (options === void 0) { options = {}; }
    if (false) {}
    var _b = options.isImmutable, isImmutable = _b === void 0 ? isImmutableDefault : _b, ignoredPaths = options.ignoredPaths, _c = options.warnAfter, warnAfter = _c === void 0 ? 32 : _c, ignore = options.ignore;
    ignoredPaths = ignoredPaths || ignore;
    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);
    return function (_b) {
        var getState = _b.getState;
        var state = getState();
        var tracker = track(state);
        var result;
        return function (next) { return function (action) {
            var measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
            measureUtils.measureTime(function () {
                state = getState();
                result = tracker.detectMutations();
                tracker = track(state);
                invariant(!result.wasMutated, "A state mutation was detected between dispatches, in the path '" + (result.path || "") + "'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
            });
            var dispatchedAction = next(action);
            measureUtils.measureTime(function () {
                state = getState();
                result = tracker.detectMutations();
                tracker = track(state);
                result.wasMutated && invariant(!result.wasMutated, "A state mutation was detected inside a dispatch, in the path: " + (result.path || "") + ". Take a look at the reducer(s) handling the action " + stringify(action) + ". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
            });
            measureUtils.warnIfExceeded();
            return dispatchedAction;
        }; };
    };
}
// src/serializableStateInvariantMiddleware.ts
function isPlain(val) {
    var type = typeof val;
    return type === "undefined" || val === null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
}
function findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths) {
    if (path === void 0) { path = ""; }
    if (isSerializable === void 0) { isSerializable = isPlain; }
    if (ignoredPaths === void 0) { ignoredPaths = []; }
    var foundNestedSerializable;
    if (!isSerializable(value)) {
        return {
            keyPath: path || "<root>",
            value: value
        };
    }
    if (typeof value !== "object" || value === null) {
        return false;
    }
    var entries = getEntries != null ? getEntries(value) : Object.entries(value);
    var hasIgnoredPaths = ignoredPaths.length > 0;
    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var _b = entries_1[_i], key = _b[0], nestedValue = _b[1];
        var nestedPath = path ? path + "." + key : key;
        if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath) >= 0) {
            continue;
        }
        if (!isSerializable(nestedValue)) {
            return {
                keyPath: nestedPath,
                value: nestedValue
            };
        }
        if (typeof nestedValue === "object") {
            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths);
            if (foundNestedSerializable) {
                return foundNestedSerializable;
            }
        }
    }
    return false;
}
function createSerializableStateInvariantMiddleware(options) {
    if (options === void 0) { options = {}; }
    if (false) {}
    var _b = options.isSerializable, isSerializable = _b === void 0 ? isPlain : _b, getEntries = options.getEntries, _c = options.ignoredActions, ignoredActions = _c === void 0 ? [] : _c, _d = options.ignoredActionPaths, ignoredActionPaths = _d === void 0 ? ["meta.arg", "meta.baseQueryMeta"] : _d, _e = options.ignoredPaths, ignoredPaths = _e === void 0 ? [] : _e, _f = options.warnAfter, warnAfter = _f === void 0 ? 32 : _f, _g = options.ignoreState, ignoreState = _g === void 0 ? false : _g;
    return function (storeAPI) { return function (next) { return function (action) {
        if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {
            return next(action);
        }
        var measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
        measureUtils.measureTime(function () {
            var foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths);
            if (foundActionNonSerializableValue) {
                var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;
                console.error("A non-serializable value was detected in an action, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
            }
        });
        var result = next(action);
        if (!ignoreState) {
            measureUtils.measureTime(function () {
                var state = storeAPI.getState();
                var foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths);
                if (foundStateNonSerializableValue) {
                    var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;
                    console.error("A non-serializable value was detected in the state, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the reducer(s) handling this action type: " + action.type + ".\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)");
                }
            });
            measureUtils.warnIfExceeded();
        }
        return result;
    }; }; };
}
// src/getDefaultMiddleware.ts
function isBoolean(x) {
    return typeof x === "boolean";
}
function curryGetDefaultMiddleware() {
    return function curriedGetDefaultMiddleware(options) {
        return getDefaultMiddleware(options);
    };
}
function getDefaultMiddleware(options) {
    if (options === void 0) { options = {}; }
    var _b = options.thunk, thunk = _b === void 0 ? true : _b, _c = options.immutableCheck, immutableCheck = _c === void 0 ? true : _c, _d = options.serializableCheck, serializableCheck = _d === void 0 ? true : _d;
    var middlewareArray = new MiddlewareArray();
    if (thunk) {
        if (isBoolean(thunk)) {
            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__["default"]);
        }
        else {
            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__["default"].withExtraArgument(thunk.extraArgument));
        }
    }
    if (true) {
        if (immutableCheck) {
            var immutableOptions = {};
            if (!isBoolean(immutableCheck)) {
                immutableOptions = immutableCheck;
            }
            middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
        }
        if (serializableCheck) {
            var serializableOptions = {};
            if (!isBoolean(serializableCheck)) {
                serializableOptions = serializableCheck;
            }
            middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
        }
    }
    return middlewareArray;
}
// src/configureStore.ts
var IS_PRODUCTION = "development" === "production";
function configureStore(options) {
    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
    var _b = options || {}, _c = _b.reducer, reducer = _c === void 0 ? void 0 : _c, _d = _b.middleware, middleware = _d === void 0 ? curriedGetDefaultMiddleware() : _d, _e = _b.devTools, devTools = _e === void 0 ? true : _e, _f = _b.preloadedState, preloadedState = _f === void 0 ? void 0 : _f, _g = _b.enhancers, enhancers = _g === void 0 ? void 0 : _g;
    var rootReducer;
    if (typeof reducer === "function") {
        rootReducer = reducer;
    }
    else if (isPlainObject(reducer)) {
        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);
    }
    else {
        throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
    }
    var finalMiddleware = middleware;
    if (typeof finalMiddleware === "function") {
        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {
            throw new Error("when using a middleware builder function, an array of middleware must be returned");
        }
    }
    if (!IS_PRODUCTION && finalMiddleware.some(function (item) { return typeof item !== "function"; })) {
        throw new Error("each middleware provided to configureStore must be a function");
    }
    var middlewareEnhancer = redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware.apply(void 0, finalMiddleware);
    var finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;
    if (devTools) {
        finalCompose = composeWithDevTools(__objSpread({
            trace: !IS_PRODUCTION
        }, typeof devTools === "object" && devTools));
    }
    var storeEnhancers = [middlewareEnhancer];
    if (Array.isArray(enhancers)) {
        storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
    }
    else if (typeof enhancers === "function") {
        storeEnhancers = enhancers(storeEnhancers);
    }
    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);
}
// src/createAction.ts
function createAction(type, prepareAction) {
    function actionCreator() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (prepareAction) {
            var prepared = prepareAction.apply(void 0, args);
            if (!prepared) {
                throw new Error("prepareAction did not return an object");
            }
            return __objSpread(__objSpread({
                type: type,
                payload: prepared.payload
            }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
        }
        return { type: type, payload: args[0] };
    }
    actionCreator.toString = function () { return "" + type; };
    actionCreator.type = type;
    actionCreator.match = function (action) { return action.type === type; };
    return actionCreator;
}
function isFSA(action) {
    return isPlainObject(action) && typeof action.type === "string" && Object.keys(action).every(isValidKey);
}
function isValidKey(key) {
    return ["type", "payload", "error", "meta"].indexOf(key) > -1;
}
function getType(actionCreator) {
    return "" + actionCreator;
}
// src/createReducer.ts

// src/mapBuilders.ts
function executeReducerBuilderCallback(builderCallback) {
    var actionsMap = {};
    var actionMatchers = [];
    var defaultCaseReducer;
    var builder = {
        addCase: function (typeOrActionCreator, reducer) {
            if (true) {
                if (actionMatchers.length > 0) {
                    throw new Error("`builder.addCase` should only be called before calling `builder.addMatcher`");
                }
                if (defaultCaseReducer) {
                    throw new Error("`builder.addCase` should only be called before calling `builder.addDefaultCase`");
                }
            }
            var type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
            if (type in actionsMap) {
                throw new Error("addCase cannot be called with two reducers for the same action type");
            }
            actionsMap[type] = reducer;
            return builder;
        },
        addMatcher: function (matcher, reducer) {
            if (true) {
                if (defaultCaseReducer) {
                    throw new Error("`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
                }
            }
            actionMatchers.push({ matcher: matcher, reducer: reducer });
            return builder;
        },
        addDefaultCase: function (reducer) {
            if (true) {
                if (defaultCaseReducer) {
                    throw new Error("`builder.addDefaultCase` can only be called once");
                }
            }
            defaultCaseReducer = reducer;
            return builder;
        }
    };
    builderCallback(builder);
    return [actionsMap, actionMatchers, defaultCaseReducer];
}
// src/createReducer.ts
function createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
    if (actionMatchers === void 0) { actionMatchers = []; }
    (0,immer__WEBPACK_IMPORTED_MODULE_2__.enableES5)();
    var _b = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _b[0], finalActionMatchers = _b[1], finalDefaultCaseReducer = _b[2];
    var frozenInitialState = (0,immer__WEBPACK_IMPORTED_MODULE_2__["default"])(initialState, function () {
    });
    return function (state, action) {
        if (state === void 0) { state = frozenInitialState; }
        var caseReducers = __spreadArray([
            actionsMap[action.type]
        ], finalActionMatchers.filter(function (_b) {
            var matcher = _b.matcher;
            return matcher(action);
        }).map(function (_b) {
            var reducer = _b.reducer;
            return reducer;
        }));
        if (caseReducers.filter(function (cr) { return !!cr; }).length === 0) {
            caseReducers = [finalDefaultCaseReducer];
        }
        return caseReducers.reduce(function (previousState, caseReducer) {
            if (caseReducer) {
                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {
                    var draft = previousState;
                    var result = caseReducer(draft, action);
                    if (typeof result === "undefined") {
                        return previousState;
                    }
                    return result;
                }
                else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {
                    var result = caseReducer(previousState, action);
                    if (typeof result === "undefined") {
                        if (previousState === null) {
                            return previousState;
                        }
                        throw Error("A case reducer on a non-draftable value must not return undefined");
                    }
                    return result;
                }
                else {
                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__["default"])(previousState, function (draft) {
                        return caseReducer(draft, action);
                    });
                }
            }
            return previousState;
        }, state);
    };
}
// src/createSlice.ts
function getType2(slice, actionKey) {
    return slice + "/" + actionKey;
}
function createSlice(options) {
    var name = options.name, initialState = options.initialState;
    if (!name) {
        throw new Error("`name` is a required option for createSlice");
    }
    var reducers = options.reducers || {};
    var _b = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _c = _b[0], extraReducers = _c === void 0 ? {} : _c, _d = _b[1], actionMatchers = _d === void 0 ? [] : _d, _e = _b[2], defaultCaseReducer = _e === void 0 ? void 0 : _e;
    var reducerNames = Object.keys(reducers);
    var sliceCaseReducersByName = {};
    var sliceCaseReducersByType = {};
    var actionCreators = {};
    reducerNames.forEach(function (reducerName) {
        var maybeReducerWithPrepare = reducers[reducerName];
        var type = getType2(name, reducerName);
        var caseReducer;
        var prepareCallback;
        if ("reducer" in maybeReducerWithPrepare) {
            caseReducer = maybeReducerWithPrepare.reducer;
            prepareCallback = maybeReducerWithPrepare.prepare;
        }
        else {
            caseReducer = maybeReducerWithPrepare;
        }
        sliceCaseReducersByName[reducerName] = caseReducer;
        sliceCaseReducersByType[type] = caseReducer;
        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
    });
    var finalCaseReducers = __objSpread(__objSpread({}, extraReducers), sliceCaseReducersByType);
    var reducer = createReducer(initialState, finalCaseReducers, actionMatchers, defaultCaseReducer);
    return {
        name: name,
        reducer: reducer,
        actions: actionCreators,
        caseReducers: sliceCaseReducersByName
    };
}
// src/entities/entity_state.ts
function getInitialEntityState() {
    return {
        ids: [],
        entities: {}
    };
}
function createInitialStateFactory() {
    function getInitialState(additionalState) {
        if (additionalState === void 0) { additionalState = {}; }
        return Object.assign(getInitialEntityState(), additionalState);
    }
    return { getInitialState: getInitialState };
}
// src/entities/state_selectors.ts
function createSelectorsFactory() {
    function getSelectors(selectState) {
        var selectIds = function (state) { return state.ids; };
        var selectEntities = function (state) { return state.entities; };
        var selectAll = createDraftSafeSelector(selectIds, selectEntities, function (ids, entities) { return ids.map(function (id) { return entities[id]; }); });
        var selectId = function (_, id) { return id; };
        var selectById = function (entities, id) { return entities[id]; };
        var selectTotal = createDraftSafeSelector(selectIds, function (ids) { return ids.length; });
        if (!selectState) {
            return {
                selectIds: selectIds,
                selectEntities: selectEntities,
                selectAll: selectAll,
                selectTotal: selectTotal,
                selectById: createDraftSafeSelector(selectEntities, selectId, selectById)
            };
        }
        var selectGlobalizedEntities = createDraftSafeSelector(selectState, selectEntities);
        return {
            selectIds: createDraftSafeSelector(selectState, selectIds),
            selectEntities: selectGlobalizedEntities,
            selectAll: createDraftSafeSelector(selectState, selectAll),
            selectTotal: createDraftSafeSelector(selectState, selectTotal),
            selectById: createDraftSafeSelector(selectGlobalizedEntities, selectId, selectById)
        };
    }
    return { getSelectors: getSelectors };
}
// src/entities/state_adapter.ts

function createSingleArgumentStateOperator(mutator) {
    var operator = createStateOperator(function (_, state) { return mutator(state); });
    return function operation(state) {
        return operator(state, void 0);
    };
}
function createStateOperator(mutator) {
    return function operation(state, arg) {
        function isPayloadActionArgument(arg2) {
            return isFSA(arg2);
        }
        var runMutator = function (draft) {
            if (isPayloadActionArgument(arg)) {
                mutator(arg.payload, draft);
            }
            else {
                mutator(arg, draft);
            }
        };
        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(state)) {
            runMutator(state);
            return state;
        }
        else {
            return (0,immer__WEBPACK_IMPORTED_MODULE_2__["default"])(state, runMutator);
        }
    };
}
// src/entities/utils.ts
function selectIdValue(entity, selectId) {
    var key = selectId(entity);
    if ( true && key === void 0) {
        console.warn("The entity passed to the `selectId` implementation returned undefined.", "You should probably provide your own `selectId` implementation.", "The entity that was passed:", entity, "The `selectId` implementation:", selectId.toString());
    }
    return key;
}
function ensureEntitiesArray(entities) {
    if (!Array.isArray(entities)) {
        entities = Object.values(entities);
    }
    return entities;
}
function splitAddedUpdatedEntities(newEntities, selectId, state) {
    newEntities = ensureEntitiesArray(newEntities);
    var added = [];
    var updated = [];
    for (var _i = 0, newEntities_1 = newEntities; _i < newEntities_1.length; _i++) {
        var entity = newEntities_1[_i];
        var id = selectIdValue(entity, selectId);
        if (id in state.entities) {
            updated.push({ id: id, changes: entity });
        }
        else {
            added.push(entity);
        }
    }
    return [added, updated];
}
// src/entities/unsorted_state_adapter.ts
function createUnsortedStateAdapter(selectId) {
    function addOneMutably(entity, state) {
        var key = selectIdValue(entity, selectId);
        if (key in state.entities) {
            return;
        }
        state.ids.push(key);
        state.entities[key] = entity;
    }
    function addManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        for (var _i = 0, newEntities_2 = newEntities; _i < newEntities_2.length; _i++) {
            var entity = newEntities_2[_i];
            addOneMutably(entity, state);
        }
    }
    function setOneMutably(entity, state) {
        var key = selectIdValue(entity, selectId);
        if (!(key in state.entities)) {
            state.ids.push(key);
        }
        state.entities[key] = entity;
    }
    function setManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        for (var _i = 0, newEntities_3 = newEntities; _i < newEntities_3.length; _i++) {
            var entity = newEntities_3[_i];
            setOneMutably(entity, state);
        }
    }
    function setAllMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        state.ids = [];
        state.entities = {};
        addManyMutably(newEntities, state);
    }
    function removeOneMutably(key, state) {
        return removeManyMutably([key], state);
    }
    function removeManyMutably(keys, state) {
        var didMutate = false;
        keys.forEach(function (key) {
            if (key in state.entities) {
                delete state.entities[key];
                didMutate = true;
            }
        });
        if (didMutate) {
            state.ids = state.ids.filter(function (id) { return id in state.entities; });
        }
    }
    function removeAllMutably(state) {
        Object.assign(state, {
            ids: [],
            entities: {}
        });
    }
    function takeNewKey(keys, update, state) {
        var original2 = state.entities[update.id];
        var updated = Object.assign({}, original2, update.changes);
        var newKey = selectIdValue(updated, selectId);
        var hasNewKey = newKey !== update.id;
        if (hasNewKey) {
            keys[update.id] = newKey;
            delete state.entities[update.id];
        }
        state.entities[newKey] = updated;
        return hasNewKey;
    }
    function updateOneMutably(update, state) {
        return updateManyMutably([update], state);
    }
    function updateManyMutably(updates, state) {
        var newKeys = {};
        var updatesPerEntity = {};
        updates.forEach(function (update) {
            if (update.id in state.entities) {
                updatesPerEntity[update.id] = {
                    id: update.id,
                    changes: __objSpread(__objSpread({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)
                };
            }
        });
        updates = Object.values(updatesPerEntity);
        var didMutateEntities = updates.length > 0;
        if (didMutateEntities) {
            var didMutateIds = updates.filter(function (update) { return takeNewKey(newKeys, update, state); }).length > 0;
            if (didMutateIds) {
                state.ids = state.ids.map(function (id) { return newKeys[id] || id; });
            }
        }
    }
    function upsertOneMutably(entity, state) {
        return upsertManyMutably([entity], state);
    }
    function upsertManyMutably(newEntities, state) {
        var _b = splitAddedUpdatedEntities(newEntities, selectId, state), added = _b[0], updated = _b[1];
        updateManyMutably(updated, state);
        addManyMutably(added, state);
    }
    return {
        removeAll: createSingleArgumentStateOperator(removeAllMutably),
        addOne: createStateOperator(addOneMutably),
        addMany: createStateOperator(addManyMutably),
        setOne: createStateOperator(setOneMutably),
        setMany: createStateOperator(setManyMutably),
        setAll: createStateOperator(setAllMutably),
        updateOne: createStateOperator(updateOneMutably),
        updateMany: createStateOperator(updateManyMutably),
        upsertOne: createStateOperator(upsertOneMutably),
        upsertMany: createStateOperator(upsertManyMutably),
        removeOne: createStateOperator(removeOneMutably),
        removeMany: createStateOperator(removeManyMutably)
    };
}
// src/entities/sorted_state_adapter.ts
function createSortedStateAdapter(selectId, sort) {
    var _b = createUnsortedStateAdapter(selectId), removeOne = _b.removeOne, removeMany = _b.removeMany, removeAll = _b.removeAll;
    function addOneMutably(entity, state) {
        return addManyMutably([entity], state);
    }
    function addManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        var models = newEntities.filter(function (model) { return !(selectIdValue(model, selectId) in state.entities); });
        if (models.length !== 0) {
            merge(models, state);
        }
    }
    function setOneMutably(entity, state) {
        return setManyMutably([entity], state);
    }
    function setManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        if (newEntities.length !== 0) {
            merge(newEntities, state);
        }
    }
    function setAllMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        state.entities = {};
        state.ids = [];
        addManyMutably(newEntities, state);
    }
    function updateOneMutably(update, state) {
        return updateManyMutably([update], state);
    }
    function takeUpdatedModel(models, update, state) {
        if (!(update.id in state.entities)) {
            return false;
        }
        var original2 = state.entities[update.id];
        var updated = Object.assign({}, original2, update.changes);
        var newKey = selectIdValue(updated, selectId);
        delete state.entities[update.id];
        models.push(updated);
        return newKey !== update.id;
    }
    function updateManyMutably(updates, state) {
        var models = [];
        updates.forEach(function (update) { return takeUpdatedModel(models, update, state); });
        if (models.length !== 0) {
            merge(models, state);
        }
    }
    function upsertOneMutably(entity, state) {
        return upsertManyMutably([entity], state);
    }
    function upsertManyMutably(newEntities, state) {
        var _b = splitAddedUpdatedEntities(newEntities, selectId, state), added = _b[0], updated = _b[1];
        updateManyMutably(updated, state);
        addManyMutably(added, state);
    }
    function areArraysEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length && i < b.length; i++) {
            if (a[i] === b[i]) {
                continue;
            }
            return false;
        }
        return true;
    }
    function merge(models, state) {
        models.forEach(function (model) {
            state.entities[selectId(model)] = model;
        });
        var allEntities = Object.values(state.entities);
        allEntities.sort(sort);
        var newSortedIds = allEntities.map(selectId);
        var ids = state.ids;
        if (!areArraysEqual(ids, newSortedIds)) {
            state.ids = newSortedIds;
        }
    }
    return {
        removeOne: removeOne,
        removeMany: removeMany,
        removeAll: removeAll,
        addOne: createStateOperator(addOneMutably),
        updateOne: createStateOperator(updateOneMutably),
        upsertOne: createStateOperator(upsertOneMutably),
        setOne: createStateOperator(setOneMutably),
        setMany: createStateOperator(setManyMutably),
        setAll: createStateOperator(setAllMutably),
        addMany: createStateOperator(addManyMutably),
        updateMany: createStateOperator(updateManyMutably),
        upsertMany: createStateOperator(upsertManyMutably)
    };
}
// src/entities/create_adapter.ts
function createEntityAdapter(options) {
    if (options === void 0) { options = {}; }
    var _b = __objSpread({
        sortComparer: false,
        selectId: function (instance) { return instance.id; }
    }, options), selectId = _b.selectId, sortComparer = _b.sortComparer;
    var stateFactory = createInitialStateFactory();
    var selectorsFactory = createSelectorsFactory();
    var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
    return __objSpread(__objSpread(__objSpread({
        selectId: selectId,
        sortComparer: sortComparer
    }, stateFactory), selectorsFactory), stateAdapter);
}
// src/nanoid.ts
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = function (size) {
    if (size === void 0) { size = 21; }
    var id = "";
    var i = size;
    while (i--) {
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};
// src/createAsyncThunk.ts
var commonProperties = [
    "name",
    "message",
    "stack",
    "code"
];
var RejectWithValue = /** @class */ (function () {
    function RejectWithValue(payload, meta) {
        this.payload = payload;
        this.meta = meta;
    }
    return RejectWithValue;
}());
var FulfillWithMeta = /** @class */ (function () {
    function FulfillWithMeta(payload, meta) {
        this.payload = payload;
        this.meta = meta;
    }
    return FulfillWithMeta;
}());
var miniSerializeError = function (value) {
    if (typeof value === "object" && value !== null) {
        var simpleError = {};
        for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
            var property = commonProperties_1[_i];
            if (typeof value[property] === "string") {
                simpleError[property] = value[property];
            }
        }
        return simpleError;
    }
    return { message: String(value) };
};
function createAsyncThunk(typePrefix, payloadCreator, options) {
    var fulfilled = createAction(typePrefix + "/fulfilled", function (payload, requestId, arg, meta) { return ({
        payload: payload,
        meta: __objSpread(__objSpread({}, meta || {}), {
            arg: arg,
            requestId: requestId,
            requestStatus: "fulfilled"
        })
    }); });
    var pending = createAction(typePrefix + "/pending", function (requestId, arg, meta) { return ({
        payload: void 0,
        meta: __objSpread(__objSpread({}, meta || {}), {
            arg: arg,
            requestId: requestId,
            requestStatus: "pending"
        })
    }); });
    var rejected = createAction(typePrefix + "/rejected", function (error, requestId, arg, payload, meta) { return ({
        payload: payload,
        error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
        meta: __objSpread(__objSpread({}, meta || {}), {
            arg: arg,
            requestId: requestId,
            rejectedWithValue: !!payload,
            requestStatus: "rejected",
            aborted: (error == null ? void 0 : error.name) === "AbortError",
            condition: (error == null ? void 0 : error.name) === "ConditionError"
        })
    }); });
    var displayedWarning = false;
    var AC = typeof AbortController !== "undefined" ? AbortController : /** @class */ (function () {
        function class_1() {
            this.signal = {
                aborted: false,
                addEventListener: function () {
                },
                dispatchEvent: function () {
                    return false;
                },
                onabort: function () {
                },
                removeEventListener: function () {
                }
            };
        }
        class_1.prototype.abort = function () {
            if (true) {
                if (!displayedWarning) {
                    displayedWarning = true;
                    console.info("This platform does not implement AbortController. \nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.");
                }
            }
        };
        return class_1;
    }());
    function actionCreator(arg) {
        return function (dispatch, getState, extra) {
            var _a;
            var requestId = ((_a = options == null ? void 0 : options.idGenerator) != null ? _a : nanoid)();
            var abortController = new AC();
            var abortReason;
            var abortedPromise = new Promise(function (_, reject) { return abortController.signal.addEventListener("abort", function () { return reject({ name: "AbortError", message: abortReason || "Aborted" }); }); });
            var started = false;
            function abort(reason) {
                if (started) {
                    abortReason = reason;
                    abortController.abort();
                }
            }
            var promise = function () {
                return __async(this, null, function () {
                    var _a2, finalAction, err_1, skipDispatch;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _b.trys.push([0, 2, , 3]);
                                if (options && options.condition && options.condition(arg, { getState: getState, extra: extra }) === false) {
                                    throw {
                                        name: "ConditionError",
                                        message: "Aborted due to condition callback returning false."
                                    };
                                }
                                started = true;
                                dispatch(pending(requestId, arg, (_a2 = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _a2.call(options, { requestId: requestId, arg: arg }, { getState: getState, extra: extra })));
                                return [4 /*yield*/, Promise.race([
                                        abortedPromise,
                                        Promise.resolve(payloadCreator(arg, {
                                            dispatch: dispatch,
                                            getState: getState,
                                            extra: extra,
                                            requestId: requestId,
                                            signal: abortController.signal,
                                            rejectWithValue: function (value, meta) {
                                                return new RejectWithValue(value, meta);
                                            },
                                            fulfillWithValue: function (value, meta) {
                                                return new FulfillWithMeta(value, meta);
                                            }
                                        })).then(function (result) {
                                            if (result instanceof RejectWithValue) {
                                                throw result;
                                            }
                                            if (result instanceof FulfillWithMeta) {
                                                return fulfilled(result.payload, requestId, arg, result.meta);
                                            }
                                            return fulfilled(result, requestId, arg);
                                        })
                                    ])];
                            case 1:
                                finalAction = _b.sent();
                                return [3 /*break*/, 3];
                            case 2:
                                err_1 = _b.sent();
                                finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                                return [3 /*break*/, 3];
                            case 3:
                                skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                                if (!skipDispatch) {
                                    dispatch(finalAction);
                                }
                                return [2 /*return*/, finalAction];
                        }
                    });
                });
            }();
            return Object.assign(promise, {
                abort: abort,
                requestId: requestId,
                arg: arg,
                unwrap: function () {
                    return promise.then(unwrapResult);
                }
            });
        };
    }
    return Object.assign(actionCreator, {
        pending: pending,
        rejected: rejected,
        fulfilled: fulfilled,
        typePrefix: typePrefix
    });
}
function unwrapResult(action) {
    if (action.meta && action.meta.rejectedWithValue) {
        throw action.payload;
    }
    if (action.error) {
        throw action.error;
    }
    return action.payload;
}
// src/tsHelpers.ts
var hasMatchFunction = function (v) {
    return v && typeof v.match === "function";
};
// src/matchers.ts
var matches = function (matcher, action) {
    if (hasMatchFunction(matcher)) {
        return matcher.match(action);
    }
    else {
        return matcher(action);
    }
};
function isAnyOf() {
    var matchers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        matchers[_i] = arguments[_i];
    }
    return function (action) {
        return matchers.some(function (matcher) { return matches(matcher, action); });
    };
}
function isAllOf() {
    var matchers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        matchers[_i] = arguments[_i];
    }
    return function (action) {
        return matchers.every(function (matcher) { return matches(matcher, action); });
    };
}
function hasExpectedRequestMetadata(action, validStatus) {
    if (!action || !action.meta)
        return false;
    var hasValidRequestId = typeof action.meta.requestId === "string";
    var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
    return hasValidRequestId && hasValidRequestStatus;
}
function isAsyncThunkArray(a) {
    return typeof a[0] === "function" && "pending" in a[0] && "fulfilled" in a[0] && "rejected" in a[0];
}
function isPending() {
    var asyncThunks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
    }
    if (asyncThunks.length === 0) {
        return function (action) { return hasExpectedRequestMetadata(action, ["pending"]); };
    }
    if (!isAsyncThunkArray(asyncThunks)) {
        return isPending()(asyncThunks[0]);
    }
    return function (action) {
        var matchers = asyncThunks.map(function (asyncThunk) { return asyncThunk.pending; });
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
    };
}
function isRejected() {
    var asyncThunks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
    }
    if (asyncThunks.length === 0) {
        return function (action) { return hasExpectedRequestMetadata(action, ["rejected"]); };
    }
    if (!isAsyncThunkArray(asyncThunks)) {
        return isRejected()(asyncThunks[0]);
    }
    return function (action) {
        var matchers = asyncThunks.map(function (asyncThunk) { return asyncThunk.rejected; });
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
    };
}
function isRejectedWithValue() {
    var asyncThunks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
    }
    var hasFlag = function (action) {
        return action && action.meta && action.meta.rejectedWithValue;
    };
    if (asyncThunks.length === 0) {
        return function (action) {
            var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);
            return combinedMatcher(action);
        };
    }
    if (!isAsyncThunkArray(asyncThunks)) {
        return isRejectedWithValue()(asyncThunks[0]);
    }
    return function (action) {
        var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);
        return combinedMatcher(action);
    };
}
function isFulfilled() {
    var asyncThunks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
    }
    if (asyncThunks.length === 0) {
        return function (action) { return hasExpectedRequestMetadata(action, ["fulfilled"]); };
    }
    if (!isAsyncThunkArray(asyncThunks)) {
        return isFulfilled()(asyncThunks[0]);
    }
    return function (action) {
        var matchers = asyncThunks.map(function (asyncThunk) { return asyncThunk.fulfilled; });
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
    };
}
function isAsyncThunkAction() {
    var asyncThunks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
    }
    if (asyncThunks.length === 0) {
        return function (action) { return hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]); };
    }
    if (!isAsyncThunkArray(asyncThunks)) {
        return isAsyncThunkAction()(asyncThunks[0]);
    }
    return function (action) {
        var matchers = [];
        for (var _i = 0, asyncThunks_1 = asyncThunks; _i < asyncThunks_1.length; _i++) {
            var asyncThunk = asyncThunks_1[_i];
            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);
        }
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
    };
}

//# sourceMappingURL=module.js.map

/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/node_modules/react-router-dom/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/node_modules/react-router-dom/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserRouter": () => (/* binding */ BrowserRouter),
/* harmony export */   "HashRouter": () => (/* binding */ HashRouter),
/* harmony export */   "Link": () => (/* binding */ Link),
/* harmony export */   "MemoryRouter": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.MemoryRouter),
/* harmony export */   "NavLink": () => (/* binding */ NavLink),
/* harmony export */   "Navigate": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Navigate),
/* harmony export */   "Outlet": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Outlet),
/* harmony export */   "Route": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Route),
/* harmony export */   "Router": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Router),
/* harmony export */   "Routes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Routes),
/* harmony export */   "UNSAFE_LocationContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_LocationContext),
/* harmony export */   "UNSAFE_NavigationContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_NavigationContext),
/* harmony export */   "UNSAFE_RouteContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_RouteContext),
/* harmony export */   "createRoutesFromChildren": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.createRoutesFromChildren),
/* harmony export */   "createSearchParams": () => (/* binding */ createSearchParams),
/* harmony export */   "generatePath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),
/* harmony export */   "matchPath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),
/* harmony export */   "matchRoutes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),
/* harmony export */   "renderMatches": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.renderMatches),
/* harmony export */   "resolvePath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),
/* harmony export */   "unstable_HistoryRouter": () => (/* binding */ HistoryRouter),
/* harmony export */   "useHref": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useHref),
/* harmony export */   "useInRouterContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useInRouterContext),
/* harmony export */   "useLinkClickHandler": () => (/* binding */ useLinkClickHandler),
/* harmony export */   "useLocation": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation),
/* harmony export */   "useMatch": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useMatch),
/* harmony export */   "useNavigate": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate),
/* harmony export */   "useNavigationType": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigationType),
/* harmony export */   "useOutlet": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useOutlet),
/* harmony export */   "useOutletContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useOutletContext),
/* harmony export */   "useParams": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useParams),
/* harmony export */   "useResolvedPath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath),
/* harmony export */   "useRoutes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useRoutes),
/* harmony export */   "useSearchParams": () => (/* binding */ useSearchParams)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! history */ "./node_modules/history/index.js");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-router */ "./node_modules/@gpa-gemstone/react-interactive/node_modules/react-router-dom/node_modules/react-router/index.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
/**
 * React Router DOM v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */





function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

const _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"],
      _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
} ////////////////////////////////////////////////////////////////////////////////
// COMPONENTS
////////////////////////////////////////////////////////////////////////////////

/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    window
  } = _ref;
  let historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({
      window
    });
  }

  let history = historyRef.current;
  let [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */
function HashRouter(_ref2) {
  let {
    basename,
    children,
    window
  } = _ref2;
  let historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({
      window
    });
  }

  let history = historyRef.current;
  let [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

/**
 * The public API for rendering a history-aware <a>.
 */
const Link = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to
  } = _ref4,
      rest = _objectWithoutPropertiesLoose(_ref4, _excluded);

  let href = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useHref)(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target
  });

  function handleClick(event) {
    if (onClick) onClick(event);

    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }

  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("a", _extends({}, rest, {
      href: href,
      onClick: handleClick,
      ref: ref,
      target: target
    }))
  );
});

if (true) {
  Link.displayName = "Link";
}

/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
const NavLink = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5,
      rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);

  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath)(to);
  let locationPathname = location.pathname;
  let toPathname = path.pathname;

  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }

  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : undefined;
  let className;

  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }

  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Link, _extends({}, rest, {
    "aria-current": ariaCurrent,
    className: className,
    ref: ref,
    style: style,
    to: to
  }), typeof children === "function" ? children({
    isActive
  }) : children);
});

if (true) {
  NavLink.displayName = "NavLink";
} ////////////////////////////////////////////////////////////////////////////////
// HOOKS
////////////////////////////////////////////////////////////////////////////////

/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */


function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp;
  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate)();
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath)(to);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(event => {
    if (event.button === 0 && ( // Ignore everything but left clicks
    !target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event) // Ignore clicks with modifier keys
    ) {
      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here.

      let replace = !!replaceProp || (0,history__WEBPACK_IMPORTED_MODULE_2__.createPath)(location) === (0,history__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}
/**
 * A convenient wrapper for reading and writing search parameters via the
 * URLSearchParams interface.
 */

function useSearchParams(defaultInit) {
   true ? warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not " + "support the URLSearchParams API. If you need to support Internet " + "Explorer 11, we recommend you load a polyfill such as " + "https://github.com/ungap/url-search-params\n\n" + "If you're unsure how to load polyfills, we recommend you check out " + "https://polyfill.io/v3/ which provides some recommendations about how " + "to load polyfills only for users that need them, instead of for every " + "user.") : 0;
  let defaultSearchParamsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(createSearchParams(defaultInit));
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  let searchParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    let searchParams = createSearchParams(location.search);

    for (let key of defaultSearchParamsRef.current.keys()) {
      if (!searchParams.has(key)) {
        defaultSearchParamsRef.current.getAll(key).forEach(value => {
          searchParams.append(key, value);
        });
      }
    }

    return searchParams;
  }, [location.search]);
  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate)();
  let setSearchParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nextInit, navigateOptions) => {
    navigate("?" + createSearchParams(nextInit), navigateOptions);
  }, [navigate]);
  return [searchParams, setSearchParams];
}

/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */
function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }

  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
  }, []));
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@gpa-gemstone/react-interactive/node_modules/react-router-dom/node_modules/react-router/index.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@gpa-gemstone/react-interactive/node_modules/react-router-dom/node_modules/react-router/index.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MemoryRouter": () => (/* binding */ MemoryRouter),
/* harmony export */   "Navigate": () => (/* binding */ Navigate),
/* harmony export */   "Outlet": () => (/* binding */ Outlet),
/* harmony export */   "Route": () => (/* binding */ Route),
/* harmony export */   "Router": () => (/* binding */ Router),
/* harmony export */   "Routes": () => (/* binding */ Routes),
/* harmony export */   "UNSAFE_LocationContext": () => (/* binding */ LocationContext),
/* harmony export */   "UNSAFE_NavigationContext": () => (/* binding */ NavigationContext),
/* harmony export */   "UNSAFE_RouteContext": () => (/* binding */ RouteContext),
/* harmony export */   "createRoutesFromChildren": () => (/* binding */ createRoutesFromChildren),
/* harmony export */   "generatePath": () => (/* binding */ generatePath),
/* harmony export */   "matchPath": () => (/* binding */ matchPath),
/* harmony export */   "matchRoutes": () => (/* binding */ matchRoutes),
/* harmony export */   "renderMatches": () => (/* binding */ renderMatches),
/* harmony export */   "resolvePath": () => (/* binding */ resolvePath),
/* harmony export */   "useHref": () => (/* binding */ useHref),
/* harmony export */   "useInRouterContext": () => (/* binding */ useInRouterContext),
/* harmony export */   "useLocation": () => (/* binding */ useLocation),
/* harmony export */   "useMatch": () => (/* binding */ useMatch),
/* harmony export */   "useNavigate": () => (/* binding */ useNavigate),
/* harmony export */   "useNavigationType": () => (/* binding */ useNavigationType),
/* harmony export */   "useOutlet": () => (/* binding */ useOutlet),
/* harmony export */   "useOutletContext": () => (/* binding */ useOutletContext),
/* harmony export */   "useParams": () => (/* binding */ useParams),
/* harmony export */   "useResolvedPath": () => (/* binding */ useResolvedPath),
/* harmony export */   "useRoutes": () => (/* binding */ useRoutes)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! history */ "./node_modules/history/index.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



function invariant(cond, message) {
  if (!cond) throw new Error(message);
}

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}

const alreadyWarned = {};

function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
     true ? warning(false, message) : 0;
  }
} ///////////////////////////////////////////////////////////////////////////////
// CONTEXT
///////////////////////////////////////////////////////////////////////////////

/**
 * A Navigator is a "location changer"; it's how you get to different locations.
 *
 * Every history instance conforms to the Navigator interface, but the
 * distinction is useful primarily when it comes to the low-level <Router> API
 * where both the location and a navigator must be provided separately in order
 * to avoid "tearing" that may occur in a suspense-enabled app if the action
 * and/or location were to be read directly from the history instance.
 */


const NavigationContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);

if (true) {
  NavigationContext.displayName = "Navigation";
}

const LocationContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);

if (true) {
  LocationContext.displayName = "Location";
}

const RouteContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  outlet: null,
  matches: []
});

if (true) {
  RouteContext.displayName = "Route";
} ///////////////////////////////////////////////////////////////////////////////
// COMPONENTS
///////////////////////////////////////////////////////////////////////////////


/**
 * A <Router> that stores all entries in memory.
 *
 * @see https://reactrouter.com/docs/en/v6/api#memoryrouter
 */
function MemoryRouter(_ref) {
  let {
    basename,
    children,
    initialEntries,
    initialIndex
  } = _ref;
  let historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({
      initialEntries,
      initialIndex
    });
  }

  let history = historyRef.current;
  let [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/docs/en/v6/api#navigate
 */
function Navigate(_ref2) {
  let {
    to,
    replace,
    state
  } = _ref2;
  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of
  // the router loaded. We can help them understand how to avoid that.
  "<Navigate> may be used only in the context of a <Router> component.") : 0 : void 0;
   true ? warning(!(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. " + "This is a no-op, but you should modify your code so the <Navigate> is " + "only ever rendered in response to some user interaction or state change.") : 0;
  let navigate = useNavigate();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    navigate(to, {
      replace,
      state
    });
  });
  return null;
}

/**
 * Renders the child route's element, if there is one.
 *
 * @see https://reactrouter.com/docs/en/v6/api#outlet
 */
function Outlet(props) {
  return useOutlet(props.context);
}

/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/docs/en/v6/api#route
 */
function Route(_props) {
    true ? invariant(false, "A <Route> is only ever to be used as the child of <Routes> element, " + "never rendered directly. Please wrap your <Route> in a <Routes>.") : 0 ;
}

/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a <Router> directly. Instead, you'll render a
 * router that is more specific to your environment such as a <BrowserRouter>
 * in web browsers or a <StaticRouter> for server rendering.
 *
 * @see https://reactrouter.com/docs/en/v6/api#router
 */
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = history__WEBPACK_IMPORTED_MODULE_1__.Action.Pop,
    navigator,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ?  true ? invariant(false, "You cannot render a <Router> inside another <Router>." + " You should never have more than one in your app.") : 0 : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);

  if (typeof locationProp === "string") {
    locationProp = (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationProp);
  }

  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);

    if (trailingPathname == null) {
      return null;
    }

    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
   true ? warning(location != null, "<Router basename=\"" + basename + "\"> is not able to match the URL " + ("\"" + pathname + search + hash + "\" because it does not start with the ") + "basename, so the <Router> won't render anything.") : 0;

  if (location == null) {
    return null;
  }

  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LocationContext.Provider, {
    children: children,
    value: {
      location,
      navigationType
    }
  }));
}

/**
 * A container for a nested tree of <Route> elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#routes
 */
function Routes(_ref4) {
  let {
    children,
    location
  } = _ref4;
  return useRoutes(createRoutesFromChildren(children), location);
} ///////////////////////////////////////////////////////////////////////////////
// HOOKS
///////////////////////////////////////////////////////////////////////////////

/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usehref
 */

function useHref(to) {
  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useHref() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    basename,
    navigator
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;

  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }

  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
/**
 * Returns true if this component is a descendant of a <Router>.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext
 */

function useInRouterContext() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LocationContext) != null;
}
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/docs/en/v6/api#uselocation
 */

function useLocation() {
  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useLocation() may be used only in the context of a <Router> component.") : 0 : void 0;
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LocationContext).location;
}

/**
 * Returns the current navigation action which describes how the router came to
 * the current location, either by a pop, push, or replace on the history stack.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype
 */
function useNavigationType() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LocationContext).navigationType;
}
/**
 * Returns true if the URL for the given "to" value matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * <NavLink>.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usematch
 */

function useMatch(pattern) {
  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useMatch() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    pathname
  } = useLocation();
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => matchPath(pattern, pathname), [pathname, pattern]);
}
/**
 * The interface for the navigate() function returned from useNavigate().
 */

/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usenavigate
 */
function useNavigate() {
  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useNavigate() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    basename,
    navigator
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext);
  let {
    matches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map(match => match.pathnameBase));
  let activeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    activeRef.current = true;
  });
  let navigate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (to, options) {
    if (options === void 0) {
      options = {};
    }

     true ? warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when " + "your component is first rendered.") : 0;
    if (!activeRef.current) return;

    if (typeof to === "number") {
      navigator.go(to);
      return;
    }

    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);

    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }

    (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
const OutletContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
/**
 * Returns the context (if provided) for the child route at this level of the route
 * hierarchy.
 * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext
 */

function useOutletContext() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(OutletContext);
}
/**
 * Returns the element for the child route at this level of the route
 * hierarchy. Used internally by <Outlet> to render child routes.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useoutlet
 */

function useOutlet(context) {
  let outlet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext).outlet;

  if (outlet) {
    return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(OutletContext.Provider, {
      value: context
    }, outlet);
  }

  return outlet;
}
/**
 * Returns an object of key/value pairs of the dynamic params from the current
 * URL that were matched by the route path.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useparams
 */

function useParams() {
  let {
    matches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath
 */

function useResolvedPath(to) {
  let {
    matches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map(match => match.pathnameBase));
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an <Outlet> to render their child route's
 * element.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useroutes
 */

function useRoutes(routes, locationArg) {
  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useRoutes() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    matches: parentMatches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;

  if (true) {
    // You won't get a warning about 2 different <Routes> under a <Route>
    // without a trailing *, but this is a best-effort warning anyway since we
    // cannot even give the warning unless they land at the parent route.
    //
    // Example:
    //
    // <Routes>
    //   {/* This route path MUST end with /* because otherwise
    //       it will never match /blog/post/123 */}
    //   <Route path="blog" element={<Blog />} />
    //   <Route path="blog/feed" element={<BlogFeed />} />
    // </Routes>
    //
    // function Blog() {
    //   return (
    //     <Routes>
    //       <Route path="post/:id" element={<Post />} />
    //     </Routes>
    //   );
    // }
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ("\"" + parentPathname + "\" (under <Route path=\"" + parentPath + "\">) but the ") + "parent route path has no trailing \"*\". This means if you navigate " + "deeper, the parent won't match anymore and therefore the child " + "routes will never render.\n\n" + ("Please change the parent <Route path=\"" + parentPath + "\"> to <Route ") + ("path=\"" + (parentPath === "/" ? "*" : parentPath + "/*") + "\">."));
  }

  let locationFromContext = useLocation();
  let location;

  if (locationArg) {
    var _parsedLocationArg$pa;

    let parsedLocationArg = typeof locationArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, " + "the location pathname must begin with the portion of the URL pathname that was " + ("matched by all parent routes. The current pathname base is \"" + parentPathnameBase + "\" ") + ("but pathname \"" + parsedLocationArg.pathname + "\" was given in the `location` prop.")) : 0 : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }

  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });

  if (true) {
     true ? warning(parentRoute || matches != null, "No routes matched location \"" + location.pathname + location.search + location.hash + "\" ") : 0;
     true ? warning(matches == null || matches[matches.length - 1].route.element !== undefined, "Matched leaf route at location \"" + location.pathname + location.search + location.hash + "\" does not have an element. " + "This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.") : 0;
  }

  return _renderMatches(matches && matches.map(match => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
} ///////////////////////////////////////////////////////////////////////////////
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren
 */

function createRoutesFromChildren(children) {
  let routes = [];
  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, element => {
    if (! /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }

    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children));
      return;
    }

    !(element.type === Route) ?  true ? invariant(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : 0 : void 0;
    let route = {
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path
    };

    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children);
    }

    routes.push(route);
  });
  return routes;
}
/**
 * The parameters that were parsed from the URL path.
 */

/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/docs/en/v6/api#generatepath
 */
function generatePath(path, params) {
  if (params === void 0) {
    params = {};
  }

  return path.replace(/:(\w+)/g, (_, key) => {
    !(params[key] != null) ?  true ? invariant(false, "Missing \":" + key + "\" param") : 0 : void 0;
    return params[key];
  }).replace(/\/*\*$/, _ => params["*"] == null ? "" : params["*"].replace(/^\/*/, "/"));
}
/**
 * A RouteMatch contains info about how a route matched a URL.
 */

/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/docs/en/v6/api#matchroutes
 */
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }

  let location = typeof locationArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);

  if (pathname == null) {
    return null;
  }

  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;

  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }

  return matches;
}

function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }

  if (parentsMeta === void 0) {
    parentsMeta = [];
  }

  if (parentPath === void 0) {
    parentPath = "";
  }

  routes.forEach((route, index) => {
    let meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };

    if (meta.relativePath.startsWith("/")) {
      !meta.relativePath.startsWith(parentPath) ?  true ? invariant(false, "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.") : 0 : void 0;
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }

    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children && route.children.length > 0) {
      !(route.index !== true) ?  true ? invariant(false, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\".")) : 0 : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    } // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.


    if (route.path == null && !route.index) {
      return;
    }

    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}

function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}

const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;

const isSplat = s => s === "*";

function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;

  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }

  if (index) {
    initialScore += indexRouteValue;
  }

  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}

function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}

function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];

  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
      route
    });

    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }

  return matches;
}
/**
 * Renders the result of `matchRoutes()` into a React element.
 */


function renderMatches(matches) {
  return _renderMatches(matches);
}

function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }

  if (matches == null) return null;
  return matches.reduceRight((outlet, match, index) => {
    return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(RouteContext.Provider, {
      children: match.route.element !== undefined ? match.route.element : /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Outlet, null),
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index + 1))
      }
    });
  }, null);
}
/**
 * A PathPattern is used to match on some portion of a URL pathname.
 */


/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/docs/en/v6/api#matchpath
 */
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }

  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }

    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}

function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }

  if (end === void 0) {
    end = true;
  }

   true ? warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\".")) : 0;
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });

  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else {
    regexpSource += end ? "\\/*$" // When matching to the end, ignore trailing slashes
    : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts
    // parent routes to matching only their own words and nothing more, e.g. parent
    // route "/home" should not match "/home2".
    "(?:\\b|\\/|$)";
  }

  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}

function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
     true ? warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ").")) : 0;
    return value;
  }
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/docs/en/v6/api#resolvepath
 */


function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }

  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}

function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}

function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(toArg) : toArg;
  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname; // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  let from;

  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;

    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }

      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.


    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }

  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original to value had one.

  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }

  return path;
}

function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(to).pathname : to.pathname;
}

function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;

  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }

  let nextChar = pathname.charAt(basename.length);

  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }

  return pathname.slice(basename.length) || "/";
}

const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");

const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");

const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;

const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash; ///////////////////////////////////////////////////////////////////////////////


//# sourceMappingURL=index.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZ3BhLWdlbXN0b25lX3JlYWN0LWludGVyYWN0aXZlX2xpYl9pbmRleF9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLG1CQUFPLENBQUMsNENBQU87QUFDM0IsY0FBYyxtQkFBTyxDQUFDLDRFQUFTO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLHFJQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RSwwREFBMEQscURBQXFELHFCQUFxQjtBQUNwSSwrRkFBK0YscUJBQXFCLFVBQVU7QUFDOUg7QUFDQTtBQUNBLHdEQUF3RCxxREFBcUQscUJBQXFCLGlHQUFpRyxxQkFBcUIsVUFBVTtBQUNsUSxLQUFLO0FBQ0w7QUFDQSxpREFBaUQsZUFBZTtBQUNoRSxLQUFLO0FBQ0w7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FLEtBQUs7QUFDTDtBQUNBLHFDQUFxQywrQkFBK0IsZ0NBQWdDLElBQUk7QUFDeEc7QUFDQTtBQUNBLHFEQUFxRCwwREFBMEQsd0RBQXdELFNBQVMsbUJBQW1CLHVDQUF1QyxvRUFBb0UsY0FBYyx5QkFBeUIsZ0lBQWdJO0FBQ3JkO0FBQ0E7QUFDQSxrQ0FBa0MsMFFBQTBRO0FBQzVTLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsZ0VBQWdFLHFEQUFxRCxxQkFBcUI7QUFDMUksK0dBQStHLHFCQUFxQixVQUFVO0FBQzlJLGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7QUFDQSxnREFBZ0Qs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QTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFLGtEQUFTO0FBQ25GOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUdBQXFHOztBQUUrVTtBQUNwYiIsInNvdXJjZXMiOlsid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9saWIvQ29uZmlndXJhYmxlVGFibGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL2xpYi9GaWx0ZXJhYmxlVGFibGUvQm9vbGVhbkZpbHRlci5qcyIsIndlYnBhY2s6Ly90cmVuZGFwLy4vbm9kZV9tb2R1bGVzL0BncGEtZ2Vtc3RvbmUvcmVhY3QtaW50ZXJhY3RpdmUvbGliL0ZpbHRlcmFibGVUYWJsZS9EYXRlVGltZUZpbHRlcnMuanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL2xpYi9GaWx0ZXJhYmxlVGFibGUvRW51bUZpbHRlci5qcyIsIndlYnBhY2s6Ly90cmVuZGFwLy4vbm9kZV9tb2R1bGVzL0BncGEtZ2Vtc3RvbmUvcmVhY3QtaW50ZXJhY3RpdmUvbGliL0ZpbHRlcmFibGVUYWJsZS9GaWx0ZXJhYmxlVGFibGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL2xpYi9GaWx0ZXJhYmxlVGFibGUvTnVtYmVyRmlsdGVyLmpzIiwid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9saWIvRmlsdGVyYWJsZVRhYmxlL1RleHRGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL2xpYi9HZW5lcmljU2xpY2UuanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL2xpYi9Mb2FkaW5nSWNvbi5qcyIsIndlYnBhY2s6Ly90cmVuZGFwLy4vbm9kZV9tb2R1bGVzL0BncGEtZ2Vtc3RvbmUvcmVhY3QtaW50ZXJhY3RpdmUvbGliL0xvYWRpbmdTY3JlZW4uanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL2xpYi9NZW51ZS9BcHBsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly90cmVuZGFwLy4vbm9kZV9tb2R1bGVzL0BncGEtZ2Vtc3RvbmUvcmVhY3QtaW50ZXJhY3RpdmUvbGliL01lbnVlL0NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL2xpYi9NZW51ZS9QYWdlLmpzIiwid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9saWIvTWVudWUvU2VjdGlvbi5qcyIsIndlYnBhY2s6Ly90cmVuZGFwLy4vbm9kZV9tb2R1bGVzL0BncGEtZ2Vtc3RvbmUvcmVhY3QtaW50ZXJhY3RpdmUvbGliL01vZGFsLmpzIiwid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9saWIvU2VhcmNoQmFyLmpzIiwid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9saWIvU2VydmVyRXJyb3JJY29uLmpzIiwid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9saWIvVGFiU2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL2xpYi9Ub29sVGlwLmpzIiwid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9saWIvV2FybmluZy5qcyIsIndlYnBhY2s6Ly90cmVuZGFwLy4vbm9kZV9tb2R1bGVzL0BncGEtZ2Vtc3RvbmUvcmVhY3QtaW50ZXJhY3RpdmUvbGliL2luZGV4LmpzIiwid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC10YWJsZS9saWIvRHluYW1pY1RhYmxlLmpzIiwid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC10YWJsZS9saWIvU2VhcmNoYWJsZVRhYmxlLmpzIiwid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC10YWJsZS9saWIvU2VsZWN0VGFibGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LXRhYmxlL2xpYi9UYWJsZS5qcyIsIndlYnBhY2s6Ly90cmVuZGFwLy4vbm9kZV9tb2R1bGVzL0BncGEtZ2Vtc3RvbmUvcmVhY3QtaW50ZXJhY3RpdmUvbm9kZV9tb2R1bGVzL0BncGEtZ2Vtc3RvbmUvcmVhY3QtdGFibGUvbGliL2luZGV4LmpzIiwid2VicGFjazovL3RyZW5kYXAvLi9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC1pbnRlcmFjdGl2ZS9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9yZWFjdC10YWJsZS9ub2RlX21vZHVsZXMvQGdwYS1nZW1zdG9uZS9ncGEtc3ltYm9scy9saWIvU1ZHSWNvbnMuanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LXRhYmxlL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL2dwYS1zeW1ib2xzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGFwLy4vbm9kZV9tb2R1bGVzL0BncGEtZ2Vtc3RvbmUvcmVhY3QtaW50ZXJhY3RpdmUvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0LmVzbS5qcyIsIndlYnBhY2s6Ly90cmVuZGFwLy4vbm9kZV9tb2R1bGVzL0BncGEtZ2Vtc3RvbmUvcmVhY3QtaW50ZXJhY3RpdmUvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRhcC8uL25vZGVfbW9kdWxlcy9AZ3BhLWdlbXN0b25lL3JlYWN0LWludGVyYWN0aXZlL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgQ29uZmlndXJhYmxlVGFibGUudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjEsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDA5LzE1LzIwMjEgLSBDaHJpc3RvcGggTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgTW9kYWxfMSA9IHJlcXVpcmUoXCIuL01vZGFsXCIpO1xyXG52YXIgcmVhY3RfdGFibGVfMSA9IHJlcXVpcmUoXCJAZ3BhLWdlbXN0b25lL3JlYWN0LXRhYmxlXCIpO1xyXG4vKipcclxuICogVGFibGUgd2l0aCBtb2RhbCB0byBzaG93IGFuZCBoaWRlIGNvbGx1bW5zXHJcbiAqL1xyXG5mdW5jdGlvbiBDb25maWd1cmFibGVUYWJsZShwcm9wcykge1xyXG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLCBzaG93U2V0dGluZ3MgPSBfYVswXSwgc2V0U2hvd1NldHRpbmdzID0gX2FbMV07XHJcbiAgICB2YXIgX2IgPSBSZWFjdC51c2VTdGF0ZShwcm9wcy5jb2xzKSwgY29sbHVtbnMgPSBfYlswXSwgc2V0Q29sbHVtbnMgPSBfYlsxXTtcclxuICAgIHZhciBfYyA9IFJlYWN0LnVzZVN0YXRlKHByb3BzLmNvbHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmtleTsgfSkpLCBjb2xLZXlzID0gX2NbMF0sIHNldENvbEtleXMgPSBfY1sxXTtcclxuICAgIHZhciBfZCA9IFJlYWN0LnVzZVN0YXRlKHByb3BzLmNvbHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBwcm9wcy5kZWZhdWx0Q29sdW1ucy5maW5kSW5kZXgoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgPT09IGQua2V5OyB9KSA+IC0xIHx8XHJcbiAgICAgICAgKHByb3BzLnJlcXVpcmVkQ29sdW1ucyAhPT0gdW5kZWZpbmVkICYmIHByb3BzLnJlcXVpcmVkQ29sdW1ucy5maW5kSW5kZXgoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgPT09IGQua2V5OyB9KSA+IC0xKTsgfSkpLCBjb2xFbmFibGVkID0gX2RbMF0sIHNldENvbEVuYWJsZWQgPSBfZFsxXTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHByb3BzLmNvbHMubGVuZ3RoICE9PSBjb2xFbmFibGVkLmxlbmd0aClcclxuICAgICAgICAgICAgc2V0Q29sRW5hYmxlZChwcm9wcy5jb2xzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gcHJvcHMuZGVmYXVsdENvbHVtbnMuZmluZEluZGV4KGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ID09PSBkLmtleTsgfSkgPiAtMSB8fCAocHJvcHMucmVxdWlyZWRDb2x1bW5zICE9PSB1bmRlZmluZWQgJiYgcHJvcHMucmVxdWlyZWRDb2x1bW5zLmZpbmRJbmRleChmdW5jdGlvbiAodikgeyByZXR1cm4gdiA9PT0gZC5rZXk7IH0pID4gLTEpOyB9KSk7XHJcbiAgICB9LCBbcHJvcHMuY29sc10pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZXRDb2xLZXlzKHByb3BzLmNvbHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmtleTsgfSkpO1xyXG4gICAgfSwgW3Byb3BzLmNvbHNdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0Q29sbHVtbnMocHJvcHMuY29scy5maWx0ZXIoZnVuY3Rpb24gKGMsIGkpIHsgcmV0dXJuIGNvbEVuYWJsZWRbaV07IH0pKTtcclxuICAgIH0sIFtjb2xFbmFibGVkXSk7XHJcbiAgICBmdW5jdGlvbiBjaGFuZ2VDb2xsdW1zKGluZGV4KSB7XHJcbiAgICAgICAgc2V0Q29sRW5hYmxlZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5tYXAoZnVuY3Rpb24gKGMsIGkpIHsgcmV0dXJuIChpID09PSBpbmRleCA/ICFjIDogYyk7IH0pOyB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0X3RhYmxlXzEuZGVmYXVsdCwgeyBjb2xzOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGNvbGx1bW5zLCB0cnVlKSwgW3sga2V5OiAnU2V0dGluZ3NDb2cnLCBsYWJlbDogUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IG1hcmdpbkxlZnQ6IC0yNSB9IH0sIFwiU1ZHSWNvbnMuU2V0dGluZ3NcIiksIGhlYWRlclN0eWxlOiB7IHdpZHRoOiAzMCwgcGFkZGluZzogMCwgdmVydGljYWxBbGlnbjogJ21pZGRsZScsIHRleHRBbGlnbjogJ3JpZ2h0JyB9LCByb3dTdHlsZTogeyBwYWRkaW5nOiAwLCB3aWR0aDogMzAgfSB9XSwgZmFsc2UpLCBkYXRhOiBwcm9wcy5kYXRhLCBvbkNsaWNrOiBwcm9wcy5vbkNsaWNrLCBzb3J0S2V5OiBwcm9wcy5zb3J0S2V5LCBhc2NlbmRpbmc6IHByb3BzLmFzY2VuZGluZywgb25Tb3J0OiBmdW5jdGlvbiAoZCkgeyBpZiAoZC5jb2xLZXkgPT09ICdTZXR0aW5nc0NvZycpXHJcbiAgICAgICAgICAgICAgICBzZXRTaG93U2V0dGluZ3ModHJ1ZSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uU29ydChkKTsgfSwgdGFibGVDbGFzczogcHJvcHMudGFibGVDbGFzcywgdGFibGVTdHlsZTogcHJvcHMudGFibGVTdHlsZSwgdGhlYWRTdHlsZTogcHJvcHMudGhlYWRTdHlsZSwgdGhlYWRDbGFzczogcHJvcHMudGhlYWRDbGFzcywgdGJvZHlTdHlsZTogcHJvcHMudGJvZHlTdHlsZSwgdGJvZHlDbGFzczogcHJvcHMudGJvZHlDbGFzcywgc2VsZWN0ZWQ6IHByb3BzLnNlbGVjdGVkLCByb3dTdHlsZTogcHJvcHMucm93U3R5bGUsIGtleVNlbGVjdG9yOiBwcm9wcy5rZXlTZWxlY3RvciB9KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1vZGFsXzEuZGVmYXVsdCwgeyBUaXRsZTogJ1RhYmxlIENvbHVtbnMnLCBTaG93OiBzaG93U2V0dGluZ3MsIFNob3dYOiB0cnVlLCBTaG93Q2FuY2VsOiBmYWxzZSwgQ2FsbEJhY2s6IGZ1bmN0aW9uIChjb25mKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTaG93U2V0dGluZ3MoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmYpXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29sRW5hYmxlZChwcm9wcy5jb2xzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gcHJvcHMuZGVmYXVsdENvbHVtbnMuZmluZEluZGV4KGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ID09PSBkLmtleTsgfSkgPiAtMSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocHJvcHMucmVxdWlyZWRDb2x1bW5zICE9PSB1bmRlZmluZWQgJiYgcHJvcHMucmVxdWlyZWRDb2x1bW5zLmZpbmRJbmRleChmdW5jdGlvbiAodikgeyByZXR1cm4gdiA9PT0gZC5rZXk7IH0pID4gLTEpOyB9KSk7XHJcbiAgICAgICAgICAgIH0sIENvbmZpcm1UZXh0OiAnUmVzZXQgRGVmYXVsdHMnIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgc3R5bGU6IHsgbGlzdFN0eWxlVHlwZTogJ25vbmUnLCBwYWRkaW5nOiAwLCB3aWR0aDogJzEwMCUnLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6ICdsZWZ0JyB9IH0sIGNvbEtleXMubWFwKGZ1bmN0aW9uIChrLCBpKSB7IHJldHVybiAocHJvcHMucmVxdWlyZWRDb2x1bW5zID09PSB1bmRlZmluZWQgfHwgcHJvcHMucmVxdWlyZWRDb2x1bW5zLmZpbmRJbmRleChmdW5jdGlvbiAodikgeyByZXR1cm4gdiA9PT0gazsgfSkgPT09IC0xID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIHsga2V5OiBrIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgeyB0eXBlOiBcImNoZWNrYm94XCIsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFuZ2VDb2xsdW1zKGkpOyB9LCBjaGVja2VkOiBjb2xFbmFibGVkW2ldIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCIpKSA6IG51bGwpOyB9KSkpKSkpKTtcclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBDb25maWd1cmFibGVUYWJsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Cb29sZWFuRmlsdGVyID0gdm9pZCAwO1xyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIEJvb2xlYW5GaWx0ZXIudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjIsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDAzLzAyLzIwMjIgLSBDLiBMYWNrbmVyXHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG5mdW5jdGlvbiBCb29sZWFuRmlsdGVyKHByb3BzKSB7XHJcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksIHNlbGVjdGVkID0gX2FbMF0sIHNldFNlbGVjdGVkID0gX2FbMV07XHJcbiAgICB2YXIgX2IgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksIG5vdFNlbGVjdGVkID0gX2JbMF0sIHNldE5vdFNlbGVjdGVkID0gX2JbMV07XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChwcm9wcy5GaWx0ZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHNldFNlbGVjdGVkKHRydWUpO1xyXG4gICAgICAgICAgICBzZXROb3RTZWxlY3RlZCh0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRTZWxlY3RlZChwcm9wcy5GaWx0ZXJbMF0uU2VhcmNoVGV4dCA9PT0gJzEnKTtcclxuICAgICAgICBzZXROb3RTZWxlY3RlZChwcm9wcy5GaWx0ZXJbMF0uU2VhcmNoVGV4dCAhPT0gJzEnKTtcclxuICAgIH0sIFtwcm9wcy5GaWx0ZXJdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFzZWxlY3RlZCAmJiAhbm90U2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgc2V0U2VsZWN0ZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIHNldE5vdFNlbGVjdGVkKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtzZWxlY3RlZCwgbm90U2VsZWN0ZWRdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkICYmICFub3RTZWxlY3RlZCAmJiAocHJvcHMuRmlsdGVyLmxlbmd0aCA9PT0gMCB8fCBwcm9wcy5GaWx0ZXJbMF0uU2VhcmNoVGV4dCAhPT0gJzEnKSkge1xyXG4gICAgICAgICAgICBwcm9wcy5TZXRGaWx0ZXIoW3sgRmllbGROYW1lOiBwcm9wcy5GaWVsZE5hbWUsIGlzUGl2b3RDb2x1bW46IGZhbHNlLCBTZWFyY2hUZXh0OiAnMScsIE9wZXJhdG9yOiAnPScsIFR5cGU6ICdib29sZWFuJyB9XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc2VsZWN0ZWQgJiYgbm90U2VsZWN0ZWQgJiYgKHByb3BzLkZpbHRlci5sZW5ndGggPT09IDAgfHwgcHJvcHMuRmlsdGVyWzBdLlNlYXJjaFRleHQgIT09ICcwJykpIHtcclxuICAgICAgICAgICAgcHJvcHMuU2V0RmlsdGVyKFt7IEZpZWxkTmFtZTogcHJvcHMuRmllbGROYW1lLCBpc1Bpdm90Q29sdW1uOiBmYWxzZSwgU2VhcmNoVGV4dDogJzAnLCBPcGVyYXRvcjogJz0nLCBUeXBlOiAnYm9vbGVhbicgfV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgbm90U2VsZWN0ZWQgJiYgcHJvcHMuRmlsdGVyLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHByb3BzLlNldEZpbHRlcihbXSk7XHJcbiAgICB9LCBbc2VsZWN0ZWQsIG5vdFNlbGVjdGVkXSk7XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgeyBvbkNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7IGV2dC5wcmV2ZW50RGVmYXVsdCgpOyBzZXRTZWxlY3RlZChmdW5jdGlvbiAocykgeyByZXR1cm4gIXM7IH0pOyB9IH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgdHlwZTogXCJjaGVja2JveFwiLCBjaGVja2VkOiBzZWxlY3RlZCwgb25DaGFuZ2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0gfSkpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCwgXCJTZWxlY3RlZFwiKSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsgb25DbGljazogZnVuY3Rpb24gKGV2dCkgeyBldnQucHJldmVudERlZmF1bHQoKTsgc2V0Tm90U2VsZWN0ZWQoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICF2OyB9KTsgfSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IHR5cGU6IFwiY2hlY2tib3hcIiwgY2hlY2tlZDogbm90U2VsZWN0ZWQsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9IH0pKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwsIFwiTm90IFNlbGVjdGVkXCIpKSk7XHJcbn1cclxuZXhwb3J0cy5Cb29sZWFuRmlsdGVyID0gQm9vbGVhbkZpbHRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgRGF0ZVRpbWVGaWx0ZXJzLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIyLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwMy8wMi8yMDIyIC0gQyBMYWNrbmVyXHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlRpbWVGaWx0ZXIgPSBleHBvcnRzLkRhdGVGaWx0ZXIgPSB2b2lkIDA7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxuZnVuY3Rpb24gRGF0ZUZpbHRlcihwcm9wcykge1xyXG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoJycpLCBkYXRlID0gX2FbMF0sIHNldERhdGUgPSBfYVsxXTtcclxuICAgIHZhciBfYiA9IFJlYWN0LnVzZVN0YXRlKCcnKSwgc2Vjb25kRGF0ZSA9IF9iWzBdLCBzZXRTZWNvbmREYXRlID0gX2JbMV07XHJcbiAgICB2YXIgX2MgPSBSZWFjdC51c2VTdGF0ZSgnYWZ0ZXInKSwgb3BlcmF0b3IgPSBfY1swXSwgc2V0T3BlcmF0b3IgPSBfY1sxXTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHByb3BzLkZpbHRlci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgc2V0RGF0ZSgnJyk7XHJcbiAgICAgICAgICAgIHNldFNlY29uZERhdGUoJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcHMuRmlsdGVyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdmFyIGYxID0gcHJvcHMuRmlsdGVyLmZpbmQoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuT3BlcmF0b3IgPT09ICc+JyB8fCBmLk9wZXJhdG9yID09PSAnPj0nOyB9KTtcclxuICAgICAgICAgICAgaWYgKGYxID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBzZXREYXRlKCcnKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc2V0RGF0ZShmMS5TZWFyY2hUZXh0KTtcclxuICAgICAgICAgICAgdmFyIGYyID0gcHJvcHMuRmlsdGVyLmZpbmQoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuT3BlcmF0b3IgPT09ICc8JyB8fCBmLk9wZXJhdG9yID09PSAnPD0nOyB9KTtcclxuICAgICAgICAgICAgaWYgKGYyID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBzZXRTZWNvbmREYXRlKCcnKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc2V0U2Vjb25kRGF0ZShmMi5TZWFyY2hUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLkZpbHRlci5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgc2V0U2Vjb25kRGF0ZSgnJyk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5GaWx0ZXJbMF0uT3BlcmF0b3IgPT09ICc+JyB8fCBwcm9wcy5GaWx0ZXJbMF0uT3BlcmF0b3IgPT09ICc+PScpXHJcbiAgICAgICAgICAgICAgICBzZXRPcGVyYXRvcignYWZ0ZXInKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc2V0T3BlcmF0b3IoJ2JlZm9yZScpO1xyXG4gICAgICAgICAgICBzZXREYXRlKHByb3BzLkZpbHRlclswXS5TZWFyY2hUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbcHJvcHMuRmlsdGVyXSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChkYXRlID09PSAnJyAmJiBzZWNvbmREYXRlID09PSAnJyAmJiBwcm9wcy5GaWx0ZXIubGVuZ3RoICE9PSAwKVxyXG4gICAgICAgICAgICBwcm9wcy5TZXRGaWx0ZXIoW10pO1xyXG4gICAgICAgIGlmIChkYXRlID09PSAnJyAmJiBzZWNvbmREYXRlID09PSAnJylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2JldHdlZW4nKSB7XHJcbiAgICAgICAgICAgIHByb3BzLlNldEZpbHRlcihbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmllbGROYW1lOiBwcm9wcy5GaWVsZE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNQaXZvdENvbHVtbjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgT3BlcmF0b3I6ICc+PScsXHJcbiAgICAgICAgICAgICAgICAgICAgVHlwZTogJ2RhdGV0aW1lJyxcclxuICAgICAgICAgICAgICAgICAgICBTZWFyY2hUZXh0OiBkYXRlXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpZWxkTmFtZTogcHJvcHMuRmllbGROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUGl2b3RDb2x1bW46IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIE9wZXJhdG9yOiAnPD0nLFxyXG4gICAgICAgICAgICAgICAgICAgIFR5cGU6ICdkYXRldGltZScsXHJcbiAgICAgICAgICAgICAgICAgICAgU2VhcmNoVGV4dDogc2Vjb25kRGF0ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHByb3BzLlNldEZpbHRlcihbe1xyXG4gICAgICAgICAgICAgICAgICAgIEZpZWxkTmFtZTogcHJvcHMuRmllbGROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUGl2b3RDb2x1bW46IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIE9wZXJhdG9yOiAob3BlcmF0b3IgPT09ICdhZnRlcicgPyAnPicgOiAnPCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIFR5cGU6ICdkYXRldGltZScsXHJcbiAgICAgICAgICAgICAgICAgICAgU2VhcmNoVGV4dDogZGF0ZVxyXG4gICAgICAgICAgICAgICAgfV0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtvcGVyYXRvciwgZGF0ZSwgc2Vjb25kRGF0ZV0pO1xyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsgb25DbGljazogZnVuY3Rpb24gKGV2dCkgeyBldnQucHJldmVudERlZmF1bHQoKTsgfSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiwgeyBjbGFzc05hbWU6ICdmb3JtLWNvbnRyb2wnLCB2YWx1ZTogb3BlcmF0b3IsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV2dC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE9wZXJhdG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnYmVmb3JlJyB9LCBcIkJlZm9yZVwiKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsgdmFsdWU6ICdhZnRlcicgfSwgXCJBZnRlclwiKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsgdmFsdWU6ICdiZXR3ZWVuJyB9LCBcIkJldHdlZW5cIikpKSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsgb25DbGljazogZnVuY3Rpb24gKGV2dCkgeyBldnQucHJldmVudERlZmF1bHQoKTsgfSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IHR5cGU6ICdkYXRlJywgY2xhc3NOYW1lOiAnZm9ybS1jb250cm9sJywgdmFsdWU6IGRhdGUsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV2dC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldERhdGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gfSkpKSxcclxuICAgICAgICBvcGVyYXRvciA9PT0gJ2JldHdlZW4nID8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsgb25DbGljazogZnVuY3Rpb24gKGV2dCkgeyBldnQucHJldmVudERlZmF1bHQoKTsgfSB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwsIFwiYW5kXCIpKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsgb25DbGljazogZnVuY3Rpb24gKGV2dCkgeyBldnQucHJldmVudERlZmF1bHQoKTsgfSB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgdHlwZTogJ2RhdGUnLCBjbGFzc05hbWU6ICdmb3JtLWNvbnRyb2wnLCB2YWx1ZTogc2Vjb25kRGF0ZSwgb25DaGFuZ2U6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV2dC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWNvbmREYXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSkpKSA6IG51bGwpO1xyXG59XHJcbmV4cG9ydHMuRGF0ZUZpbHRlciA9IERhdGVGaWx0ZXI7XHJcbmZ1bmN0aW9uIFRpbWVGaWx0ZXIocHJvcHMpIHtcclxuICAgIHZhciBfYSA9IFJlYWN0LnVzZVN0YXRlKCcnKSwgdGltZSA9IF9hWzBdLCBzZXRUaW1lID0gX2FbMV07XHJcbiAgICB2YXIgX2IgPSBSZWFjdC51c2VTdGF0ZSgnJyksIHNlY29uZFRpbWUgPSBfYlswXSwgc2V0U2Vjb25kVGltZSA9IF9iWzFdO1xyXG4gICAgdmFyIF9jID0gUmVhY3QudXNlU3RhdGUoJ2FmdGVyJyksIG9wZXJhdG9yID0gX2NbMF0sIHNldE9wZXJhdG9yID0gX2NbMV07XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChwcm9wcy5GaWx0ZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWUoJycpO1xyXG4gICAgICAgICAgICBzZXRTZWNvbmRUaW1lKCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLkZpbHRlci5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHZhciBmMSA9IHByb3BzLkZpbHRlci5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLk9wZXJhdG9yID09PSAnPicgfHwgZi5PcGVyYXRvciA9PT0gJz49JzsgfSk7XHJcbiAgICAgICAgICAgIGlmIChmMSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgc2V0VGltZSgnJyk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHNldFRpbWUoZjEuU2VhcmNoVGV4dCk7XHJcbiAgICAgICAgICAgIHZhciBmMiA9IHByb3BzLkZpbHRlci5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLk9wZXJhdG9yID09PSAnPCcgfHwgZi5PcGVyYXRvciA9PT0gJzw9JzsgfSk7XHJcbiAgICAgICAgICAgIGlmIChmMiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgc2V0U2Vjb25kVGltZSgnJyk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHNldFNlY29uZFRpbWUoZjIuU2VhcmNoVGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5GaWx0ZXIubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHNldFNlY29uZFRpbWUoJycpO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuRmlsdGVyWzBdLk9wZXJhdG9yID09PSAnPicgfHwgcHJvcHMuRmlsdGVyWzBdLk9wZXJhdG9yID09PSAnPj0nKVxyXG4gICAgICAgICAgICAgICAgc2V0T3BlcmF0b3IoJ2FmdGVyJyk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHNldE9wZXJhdG9yKCdiZWZvcmUnKTtcclxuICAgICAgICAgICAgc2V0VGltZShwcm9wcy5GaWx0ZXJbMF0uU2VhcmNoVGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3Byb3BzLkZpbHRlcl0pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGltZSA9PT0gJycgJiYgc2Vjb25kVGltZSA9PT0gJycgJiYgcHJvcHMuRmlsdGVyLmxlbmd0aCAhPT0gMClcclxuICAgICAgICAgICAgcHJvcHMuU2V0RmlsdGVyKFtdKTtcclxuICAgICAgICBpZiAodGltZSA9PT0gJycgJiYgc2Vjb25kVGltZSA9PT0gJycpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdiZXR3ZWVuJykge1xyXG4gICAgICAgICAgICBwcm9wcy5TZXRGaWx0ZXIoW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpZWxkTmFtZTogcHJvcHMuRmllbGROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUGl2b3RDb2x1bW46IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIE9wZXJhdG9yOiAnPj0nLFxyXG4gICAgICAgICAgICAgICAgICAgIFR5cGU6ICdkYXRldGltZScsXHJcbiAgICAgICAgICAgICAgICAgICAgU2VhcmNoVGV4dDogdGltZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaWVsZE5hbWU6IHByb3BzLkZpZWxkTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBpc1Bpdm90Q29sdW1uOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBPcGVyYXRvcjogJzw9JyxcclxuICAgICAgICAgICAgICAgICAgICBUeXBlOiAnZGF0ZXRpbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgIFNlYXJjaFRleHQ6IHNlY29uZFRpbWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9wcy5TZXRGaWx0ZXIoW3tcclxuICAgICAgICAgICAgICAgICAgICBGaWVsZE5hbWU6IHByb3BzLkZpZWxkTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBpc1Bpdm90Q29sdW1uOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBPcGVyYXRvcjogKG9wZXJhdG9yID09PSAnYWZ0ZXInID8gJz4nIDogJzwnKSxcclxuICAgICAgICAgICAgICAgICAgICBUeXBlOiAnZGF0ZXRpbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgIFNlYXJjaFRleHQ6IHRpbWVcclxuICAgICAgICAgICAgICAgIH1dKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbb3BlcmF0b3IsIHRpbWUsIHNlY29uZFRpbWVdKTtcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IG9uQ2xpY2s6IGZ1bmN0aW9uIChldnQpIHsgZXZ0LnByZXZlbnREZWZhdWx0KCk7IH0gfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHsgY2xhc3NOYW1lOiAnZm9ybS1jb250cm9sJywgdmFsdWU6IG9wZXJhdG9yLCBvbkNoYW5nZTogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBldnQudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPcGVyYXRvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwgeyB2YWx1ZTogJ2JlZm9yZScgfSwgXCJCZWZvcmVcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnYWZ0ZXInIH0sIFwiQWZ0ZXJcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnYmV0d2VlbicgfSwgXCJCZXR3ZWVuXCIpKSkpLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IG9uQ2xpY2s6IGZ1bmN0aW9uIChldnQpIHsgZXZ0LnByZXZlbnREZWZhdWx0KCk7IH0gfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgeyB0eXBlOiAndGltZScsIGNsYXNzTmFtZTogJ2Zvcm0tY29udHJvbCcsIHZhbHVlOiB0aW1lLCBvbkNoYW5nZTogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBldnQudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IH0pKSksXHJcbiAgICAgICAgb3BlcmF0b3IgPT09ICdiZXR3ZWVuJyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IG9uQ2xpY2s6IGZ1bmN0aW9uIChldnQpIHsgZXZ0LnByZXZlbnREZWZhdWx0KCk7IH0gfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLCBcImFuZFwiKSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IG9uQ2xpY2s6IGZ1bmN0aW9uIChldnQpIHsgZXZ0LnByZXZlbnREZWZhdWx0KCk7IH0gfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IHR5cGU6ICd0aW1lJywgY2xhc3NOYW1lOiAnZm9ybS1jb250cm9sJywgdmFsdWU6IHNlY29uZFRpbWUsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBldnQudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2Vjb25kVGltZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpKSkgOiBudWxsKTtcclxufVxyXG5leHBvcnRzLlRpbWVGaWx0ZXIgPSBUaW1lRmlsdGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuRW51bUZpbHRlciA9IHZvaWQgMDtcclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBFbnVtRmlsdGVyLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIyLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwMy8wMi8yMDIyIC0gQyBMYWNrbmVyXHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG5mdW5jdGlvbiBFbnVtRmlsdGVyKHByb3BzKSB7XHJcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZShbXSksIG9wdGlvbnMgPSBfYVswXSwgc2V0T3B0aW9ucyA9IF9hWzFdO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZXRPcHRpb25zKHByb3BzLk9wdGlvbnMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGl0ZW0pLCB7IFNlbGVjdGVkOiB0cnVlIH0pKTsgfSkpO1xyXG4gICAgfSwgW3Byb3BzLk9wdGlvbnNdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHByb3BzLkZpbHRlci5sZW5ndGggIT09IDAgJiYgKG9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LlNlbGVjdGVkOyB9KS5sZW5ndGggPT09IG9wdGlvbnMubGVuZ3RoIHx8IG9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiAheC5TZWxlY3RlZDsgfSkubGVuZ3RoID09PSBvcHRpb25zLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgcHJvcHMuU2V0RmlsdGVyKFtdKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5zb21lKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAhaXRlbS5TZWxlY3RlZDsgfSkpXHJcbiAgICAgICAgICAgIHByb3BzLlNldEZpbHRlcihbe1xyXG4gICAgICAgICAgICAgICAgICAgIEZpZWxkTmFtZTogcHJvcHMuRmllbGROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUGl2b3RDb2x1bW46IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIE9wZXJhdG9yOiAnSU4nLFxyXG4gICAgICAgICAgICAgICAgICAgIFR5cGU6ICdlbnVtJyxcclxuICAgICAgICAgICAgICAgICAgICBTZWFyY2hUZXh0OiBcIihcIiArIG9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7IHJldHVybiBvLlNlbGVjdGVkOyB9KS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguVmFsdWU7IH0pLmpvaW4oJywnKSArIFwiKVwiXHJcbiAgICAgICAgICAgICAgICB9XSk7XHJcbiAgICB9LCBbb3B0aW9uc10pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocHJvcHMuRmlsdGVyLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgc2V0T3B0aW9ucyhmdW5jdGlvbiAob3B0KSB7IHJldHVybiBvcHQubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGl0ZW0pLCB7IFNlbGVjdGVkOiB0cnVlIH0pKTsgfSk7IH0pO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGlzdF8xID0gcHJvcHMuRmlsdGVyWzBdLlNlYXJjaFRleHQucmVwbGFjZSgnKCcsICcnKS5yZXBsYWNlKCcpJywgJycpLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgIGxpc3RfMSA9IGxpc3RfMS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IFwiXCI7IH0pO1xyXG4gICAgICAgICAgICB2YXIgaGFzQ2hhbmdlZCA9IG9wdGlvbnMuc29tZShmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBsaXN0XzEuZmluZEluZGV4KGZ1bmN0aW9uIChsKSB7IHJldHVybiBsID09PSBpdGVtLlZhbHVlOyB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgMCAmJiBpdGVtLlNlbGVjdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gMCAmJiAhaXRlbS5TZWxlY3RlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChoYXNDaGFuZ2VkKVxyXG4gICAgICAgICAgICAgICAgc2V0T3B0aW9ucyhmdW5jdGlvbiAob3B0KSB7IHJldHVybiBvcHQubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGl0ZW0pLCB7IFNlbGVjdGVkOiBsaXN0XzEuZmluZEluZGV4KGZ1bmN0aW9uIChsKSB7IHJldHVybiBsID09PSBpdGVtLlZhbHVlOyB9KSA+PSAwIH0pKTsgfSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtwcm9wcy5GaWx0ZXJdKTtcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IG9uQ2xpY2s6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQ2hlY2tlZCA9IG9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LlNlbGVjdGVkOyB9KS5sZW5ndGggPT09IG9wdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgc2V0T3B0aW9ucyhmdW5jdGlvbiAob2xkKSB7IHJldHVybiBvbGQubWFwKGZ1bmN0aW9uIChvKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIG8pLCB7IFNlbGVjdGVkOiAhaXNDaGVja2VkIH0pKTsgfSk7IH0pO1xyXG4gICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgdHlwZTogXCJjaGVja2JveFwiLCBjaGVja2VkOiBvcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5TZWxlY3RlZDsgfSkubGVuZ3RoID09PSBvcHRpb25zLmxlbmd0aCwgb25DaGFuZ2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0gfSkpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCwgXCJBbGxcIikpLFxyXG4gICAgICAgIG9wdGlvbnMubWFwKGZ1bmN0aW9uIChmLCBpKSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsga2V5OiBpLCBvbkNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7IHNldE9wdGlvbnMoZnVuY3Rpb24gKG9sZCkgeyByZXR1cm4gb2xkLm1hcChmdW5jdGlvbiAobykgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvKSwgeyBTZWxlY3RlZDogKG8uVmFsdWUgPT09IGYuVmFsdWUgPyAhby5TZWxlY3RlZCA6IG8uU2VsZWN0ZWQpIH0pKTsgfSk7IH0pOyB9IH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgdHlwZTogXCJjaGVja2JveFwiLCBjaGVja2VkOiBmLlNlbGVjdGVkLCBvbkNoYW5nZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSB9KSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLCBmLkxhYmVsKSkpOyB9KSk7XHJcbn1cclxuZXhwb3J0cy5FbnVtRmlsdGVyID0gRW51bUZpbHRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgRmlsdGVyYWJsZVRhYmxlLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIyLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwMy8wMi8yMDIyIC0gQy4gTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciByZWFjdF90YWJsZV8xID0gcmVxdWlyZShcIkBncGEtZ2Vtc3RvbmUvcmVhY3QtdGFibGVcIik7XHJcbnZhciBncGFfc3ltYm9sc18xID0gcmVxdWlyZShcIkBncGEtZ2Vtc3RvbmUvZ3BhLXN5bWJvbHNcIik7XHJcbnZhciBCb29sZWFuRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9Cb29sZWFuRmlsdGVyXCIpO1xyXG52YXIgVGV4dEZpbHRlcl8xID0gcmVxdWlyZShcIi4vVGV4dEZpbHRlclwiKTtcclxudmFyIEVudW1GaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL0VudW1GaWx0ZXJcIik7XHJcbnZhciBOdW1iZXJGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL051bWJlckZpbHRlclwiKTtcclxudmFyIERhdGVUaW1lRmlsdGVyc18xID0gcmVxdWlyZShcIi4vRGF0ZVRpbWVGaWx0ZXJzXCIpO1xyXG4vKipcclxuICogVGFibGUgd2l0aCBGaWx0ZXJzIGluIHRoZSBjb2x1bW4gSGVhZGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gRmlsdGVyYWJsZVRhYmxlKHByb3BzKSB7XHJcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZSgocHJvcHMuRGVmYXVsdEZpbHRlciA9PT0gdW5kZWZpbmVkID8gW10gOiBwcm9wcy5EZWZhdWx0RmlsdGVyKSksIGZpbHRlcnMgPSBfYVswXSwgc2V0RmlsdGVycyA9IF9hWzFdO1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlRmlsdGVycyhmbHRzLCBmbGQpIHtcclxuICAgICAgICBzZXRGaWx0ZXJzKGZ1bmN0aW9uIChmbHMpIHtcclxuICAgICAgICAgICAgdmFyIG90aGVyRmlsdGVycyA9IGZscy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uRmllbGROYW1lICE9PSBmbGQ7IH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXJGaWx0ZXJzLmNvbmNhdChmbHRzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHByb3BzLlNldEZpbHRlcihmaWx0ZXJzKTsgfSwgW2ZpbHRlcnNdKTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0X3RhYmxlXzEuZGVmYXVsdCwgeyBjb2xzOiBwcm9wcy5jb2xzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBjKSwgeyBsYWJlbDogUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkZXIsIHsgTGFiZWw6IGMubGFiZWwsIEZpbHRlcjogZmlsdGVycy5maWx0ZXIoZnVuY3Rpb24gKGYpIHsgdmFyIF9hOyByZXR1cm4gZi5GaWVsZE5hbWUgPT09ICgoX2EgPSBjLmZpZWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSk7IH0pLCBTZXRGaWx0ZXI6IGZ1bmN0aW9uIChmKSB7IHJldHVybiB1cGRhdGVGaWx0ZXJzKGYsIGMuZmllbGQpOyB9LCBGaWVsZDogYy5maWVsZCwgVHlwZTogYy5UeXBlLCBPcHRpb25zOiBjLkVudW0gfSkgfSkpOyB9KSwgZGF0YTogcHJvcHMuZGF0YSwgb25DbGljazogcHJvcHMub25DbGljaywgc29ydEtleTogcHJvcHMuc29ydEtleSwgYXNjZW5kaW5nOiBwcm9wcy5hc2NlbmRpbmcsIG9uU29ydDogcHJvcHMub25Tb3J0LCB0YWJsZUNsYXNzOiBwcm9wcy50YWJsZUNsYXNzLCB0YWJsZVN0eWxlOiBwcm9wcy50YWJsZVN0eWxlLCB0aGVhZFN0eWxlOiBwcm9wcy50aGVhZFN0eWxlLCB0aGVhZENsYXNzOiBwcm9wcy50aGVhZENsYXNzLCB0Ym9keVN0eWxlOiBwcm9wcy50Ym9keVN0eWxlLCB0Ym9keUNsYXNzOiBwcm9wcy50Ym9keUNsYXNzLCBzZWxlY3RlZDogcHJvcHMuc2VsZWN0ZWQsIHJvd1N0eWxlOiBwcm9wcy5yb3dTdHlsZSwga2V5U2VsZWN0b3I6IHByb3BzLmtleVNlbGVjdG9yIH0pKSk7XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRmlsdGVyYWJsZVRhYmxlO1xyXG5mdW5jdGlvbiBIZWFkZXIocHJvcHMpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tO1xyXG4gICAgdmFyIF9vID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLCBzaG93ID0gX29bMF0sIHNldFNob3cgPSBfb1sxXTtcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldFNob3codHJ1ZSk7IH0sIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0U2hvdyhmYWxzZSk7IH0gfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IG1hcmdpblJpZ2h0OiAyNSB9IH0sIHByb3BzLkxhYmVsKSxcclxuICAgICAgICAgICAgcHJvcHMuVHlwZSAhPT0gdW5kZWZpbmVkID8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogeyB3aWR0aDogMjUsIHBvc2l0aW9uOiAnYWJzb2x1dGUnLCByaWdodDogMTIsIHRvcDogMTIgfSB9LCBwcm9wcy5GaWx0ZXIubGVuZ3RoID4gMCA/IGdwYV9zeW1ib2xzXzEuU1ZHSWNvbnMuRmlsdGVyIDogbnVsbCksXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgKiAwLjUwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzEwIDUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBzaG93ID8gJ2Jsb2NrJyA6ICdub25lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZmYnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwcHggOHB4IDE2cHggMHB4IHJnYmEoMCwwLDAsMC4yKScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogNDAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogJ2NhbGMoMTAwJSAtIDUwcHgpJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogLTI1XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgb25DbGljazogZnVuY3Rpb24gKGV2dCkgeyBldnQucHJldmVudERlZmF1bHQoKTsgZXZ0LnN0b3BQcm9wYWdhdGlvbigpOyB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgY2xhc3NOYW1lOiBcInRhYmxlXCIsIHN0eWxlOiB7IG1hcmdpbjogMCB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuVHlwZSA9PT0gJ2Jvb2xlYW4nID8gUmVhY3QuY3JlYXRlRWxlbWVudChCb29sZWFuRmlsdGVyXzEuQm9vbGVhbkZpbHRlciwgeyBTZXRGaWx0ZXI6IHByb3BzLlNldEZpbHRlciwgRmlsdGVyOiBwcm9wcy5GaWx0ZXIsIEZpZWxkTmFtZTogKF9iID0gKF9hID0gcHJvcHMuRmllbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyB9KSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5UeXBlID09PSAnc3RyaW5nJyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dEZpbHRlcl8xLlRleHRGaWx0ZXIsIHsgU2V0RmlsdGVyOiBwcm9wcy5TZXRGaWx0ZXIsIEZpbHRlcjogcHJvcHMuRmlsdGVyLCBGaWVsZE5hbWU6IChfZCA9IChfYyA9IHByb3BzLkZpZWxkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJycgfSkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuVHlwZSA9PT0gJ2VudW0nICYmIHByb3BzLk9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRW51bUZpbHRlcl8xLkVudW1GaWx0ZXIsIHsgRmllbGROYW1lOiAoX2YgPSAoX2UgPSBwcm9wcy5GaWVsZCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6ICcnLCBGaWx0ZXI6IHByb3BzLkZpbHRlciwgU2V0RmlsdGVyOiBwcm9wcy5TZXRGaWx0ZXIsIE9wdGlvbnM6IHByb3BzLk9wdGlvbnMgfSkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuVHlwZSA9PT0gJ2RhdGUnID8gUmVhY3QuY3JlYXRlRWxlbWVudChEYXRlVGltZUZpbHRlcnNfMS5EYXRlRmlsdGVyLCB7IEZpZWxkTmFtZTogKF9oID0gKF9nID0gcHJvcHMuRmllbGQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAnJywgRmlsdGVyOiBwcm9wcy5GaWx0ZXIsIFNldEZpbHRlcjogcHJvcHMuU2V0RmlsdGVyIH0pIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLlR5cGUgPT09ICd0aW1lJyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0ZVRpbWVGaWx0ZXJzXzEuVGltZUZpbHRlciwgeyBGaWVsZE5hbWU6IChfayA9IChfaiA9IHByb3BzLkZpZWxkKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogJycsIEZpbHRlcjogcHJvcHMuRmlsdGVyLCBTZXRGaWx0ZXI6IHByb3BzLlNldEZpbHRlciB9KSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5UeXBlID09PSAnbnVtYmVyJyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoTnVtYmVyRmlsdGVyXzEuTnVtYmVyRmlsdGVyLCB7IEZpZWxkTmFtZTogKF9tID0gKF9sID0gcHJvcHMuRmllbGQpID09PSBudWxsIHx8IF9sID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbC50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiAnJywgRmlsdGVyOiBwcm9wcy5GaWx0ZXIsIFNldEZpbHRlcjogcHJvcHMuU2V0RmlsdGVyIH0pIDogbnVsbCkpKSkgOiBudWxsKSk7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5OdW1iZXJGaWx0ZXIgPSB2b2lkIDA7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgTnVtYmVyRmlsdGVyLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIyLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwMy8wMi8yMDIyIC0gQyBMYWNrbmVyXHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG5mdW5jdGlvbiBOdW1iZXJGaWx0ZXIocHJvcHMpIHtcclxuICAgIHZhciBfYSA9IFJlYWN0LnVzZVN0YXRlKCcnKSwgdmFsdWUgPSBfYVswXSwgc2V0VmFsdWUgPSBfYVsxXTtcclxuICAgIHZhciBfYiA9IFJlYWN0LnVzZVN0YXRlKCcnKSwgc2Vjb25kVmFsdWUgPSBfYlswXSwgc2V0U2Vjb25kVmFsdWUgPSBfYlsxXTtcclxuICAgIHZhciBfYyA9IFJlYWN0LnVzZVN0YXRlKCdsZXNzIHRoYW4nKSwgb3BlcmF0b3IgPSBfY1swXSwgc2V0T3BlcmF0b3IgPSBfY1sxXTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHByb3BzLkZpbHRlci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgc2V0VmFsdWUoJycpO1xyXG4gICAgICAgICAgICBzZXRTZWNvbmRWYWx1ZSgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5GaWx0ZXIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB2YXIgZjEgPSBwcm9wcy5GaWx0ZXIuZmluZChmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5PcGVyYXRvciA9PT0gJz4nIHx8IGYuT3BlcmF0b3IgPT09ICc+PSc7IH0pO1xyXG4gICAgICAgICAgICBpZiAoZjEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHNldFZhbHVlKCcnKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc2V0VmFsdWUoZjEuU2VhcmNoVGV4dCk7XHJcbiAgICAgICAgICAgIHZhciBmMiA9IHByb3BzLkZpbHRlci5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLk9wZXJhdG9yID09PSAnPCcgfHwgZi5PcGVyYXRvciA9PT0gJzw9JzsgfSk7XHJcbiAgICAgICAgICAgIGlmIChmMiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgc2V0U2Vjb25kVmFsdWUoJycpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzZXRTZWNvbmRWYWx1ZShmMi5TZWFyY2hUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLkZpbHRlci5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgc2V0U2Vjb25kVmFsdWUoJycpO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuRmlsdGVyWzBdLk9wZXJhdG9yID09PSAnPicgfHwgcHJvcHMuRmlsdGVyWzBdLk9wZXJhdG9yID09PSAnPj0nKVxyXG4gICAgICAgICAgICAgICAgc2V0T3BlcmF0b3IoJ2dyZWF0ZXIgdGhhbicpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5GaWx0ZXJbMF0uT3BlcmF0b3IgPT09ICc9JylcclxuICAgICAgICAgICAgICAgIHNldE9wZXJhdG9yKCdlcXVhbCB0bycpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzZXRPcGVyYXRvcignbGVzcyB0aGFuJyk7XHJcbiAgICAgICAgICAgIHNldFZhbHVlKHByb3BzLkZpbHRlclswXS5TZWFyY2hUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbcHJvcHMuRmlsdGVyXSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycgJiYgc2Vjb25kVmFsdWUgPT09ICcnICYmIHByb3BzLkZpbHRlci5sZW5ndGggIT09IDApXHJcbiAgICAgICAgICAgIHByb3BzLlNldEZpbHRlcihbXSk7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJyAmJiBzZWNvbmRWYWx1ZSA9PT0gJycpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdiZXR3ZWVuJykge1xyXG4gICAgICAgICAgICBwcm9wcy5TZXRGaWx0ZXIoW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpZWxkTmFtZTogcHJvcHMuRmllbGROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUGl2b3RDb2x1bW46IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIE9wZXJhdG9yOiAnPj0nLFxyXG4gICAgICAgICAgICAgICAgICAgIFR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIFNlYXJjaFRleHQ6IHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpZWxkTmFtZTogcHJvcHMuRmllbGROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUGl2b3RDb2x1bW46IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIE9wZXJhdG9yOiAnPD0nLFxyXG4gICAgICAgICAgICAgICAgICAgIFR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIFNlYXJjaFRleHQ6IHNlY29uZFZhbHVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJvcHMuU2V0RmlsdGVyKFt7XHJcbiAgICAgICAgICAgICAgICAgICAgRmllbGROYW1lOiBwcm9wcy5GaWVsZE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNQaXZvdENvbHVtbjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgT3BlcmF0b3I6IHRyYW5zZm9ybVN5bWJvbChvcGVyYXRvciksXHJcbiAgICAgICAgICAgICAgICAgICAgVHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgU2VhcmNoVGV4dDogdmFsdWVcclxuICAgICAgICAgICAgICAgIH1dKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbb3BlcmF0b3IsIHZhbHVlLCBzZWNvbmRWYWx1ZV0pO1xyXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtU3ltYm9sKHMpIHtcclxuICAgICAgICBpZiAocyA9PT0gJ2xlc3MgdGhhbicpXHJcbiAgICAgICAgICAgIHJldHVybiAnPCc7XHJcbiAgICAgICAgaWYgKHMgPT09ICdncmVhdGVyIHRoYW4nKVxyXG4gICAgICAgICAgICByZXR1cm4gJz4nO1xyXG4gICAgICAgIHJldHVybiAnPSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgeyBvbkNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7IGV2dC5wcmV2ZW50RGVmYXVsdCgpOyB9IH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCB7IGNsYXNzTmFtZTogJ2Zvcm0tY29udHJvbCcsIHZhbHVlOiBvcGVyYXRvciwgb25DaGFuZ2U6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBldnQudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPcGVyYXRvcih2KTtcclxuICAgICAgICAgICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnbGVzcyB0aGFuJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkxlc3MgdGhhbiAoXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCIpXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwgeyB2YWx1ZTogJ2VxdWFsIHRvJyB9LCBcIkVxdWFsIHRvICg9KVwiKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsgdmFsdWU6ICdncmVhdGVyIHRoYW4nIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiR3JlYXRlciB0aGFuIChcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgJz4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIilcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnYmV0d2VlbicgfSwgXCJJbiByYW5nZVwiKSkpKSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgeyBvbkNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7IGV2dC5wcmV2ZW50RGVmYXVsdCgpOyB9IH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgdHlwZTogJ251bWJlcicsIGNsYXNzTmFtZTogJ2Zvcm0tY29udHJvbCcsIHZhbHVlOiB2YWx1ZSwgb25DaGFuZ2U6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBldnQudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSh2KTtcclxuICAgICAgICAgICAgICAgICAgICB9IH0pKSksXHJcbiAgICAgICAgb3BlcmF0b3IgPT09ICdiZXR3ZWVuJyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IG9uQ2xpY2s6IGZ1bmN0aW9uIChldnQpIHsgZXZ0LnByZXZlbnREZWZhdWx0KCk7IH0gfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLCBcImFuZFwiKSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IG9uQ2xpY2s6IGZ1bmN0aW9uIChldnQpIHsgZXZ0LnByZXZlbnREZWZhdWx0KCk7IH0gfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IHR5cGU6ICdudW1iZXInLCBjbGFzc05hbWU6ICdmb3JtLWNvbnRyb2wnLCB2YWx1ZTogc2Vjb25kVmFsdWUsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGV2dC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWNvbmRWYWx1ZSh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSkpKSA6IG51bGwpO1xyXG59XHJcbmV4cG9ydHMuTnVtYmVyRmlsdGVyID0gTnVtYmVyRmlsdGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlRleHRGaWx0ZXIgPSB2b2lkIDA7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgVGV4dEZpbHRlci50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMiwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDMvMDIvMjAyMiAtIEMgTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxuZnVuY3Rpb24gVGV4dEZpbHRlcihwcm9wcykge1xyXG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoJycpLCB0eHQgPSBfYVswXSwgc2V0VHh0ID0gX2FbMV07XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChwcm9wcy5GaWx0ZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHNldFR4dCgnJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VHh0KHByb3BzLkZpbHRlclswXS5TZWFyY2hUZXh0KTtcclxuICAgIH0sIFtwcm9wcy5GaWx0ZXJdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCh0eHQgPT0gbnVsbCB8fCB0eHQudHJpbSgpLmxlbmd0aCA9PT0gMCkgJiYgcHJvcHMuRmlsdGVyLmxlbmd0aCAhPT0gMClcclxuICAgICAgICAgICAgcHJvcHMuU2V0RmlsdGVyKFtdKTtcclxuICAgICAgICBpZiAodHh0ICE9IG51bGwgJiYgdHh0LnRyaW0oKS5sZW5ndGggPiAwICYmIChwcm9wcy5GaWx0ZXIubGVuZ3RoID09PSAwIHx8IHByb3BzLkZpbHRlclswXS5TZWFyY2hUZXh0ICE9PSB0eHQudHJpbSgpKSlcclxuICAgICAgICAgICAgcHJvcHMuU2V0RmlsdGVyKFt7IEZpZWxkTmFtZTogcHJvcHMuRmllbGROYW1lLCBpc1Bpdm90Q29sdW1uOiBmYWxzZSwgU2VhcmNoVGV4dDogdHh0LnRyaW0oKSwgT3BlcmF0b3I6ICdMSUtFJywgVHlwZTogJ3N0cmluZycgfV0pO1xyXG4gICAgfSwgW3R4dF0pO1xyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsgb25DbGljazogZnVuY3Rpb24gKGV2dCkgeyBldnQucHJldmVudERlZmF1bHQoKTsgfSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IGNsYXNzTmFtZTogJ2Zvcm0tY29udHJvbCcsIHZhbHVlOiB0eHQucmVwbGFjZSgnJF8nLCAnXycpLCBwbGFjZWhvbGRlcjogXCJTZWFyY2hcIiwgb25DaGFuZ2U6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZXZ0LnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VHh0KHZhbHVlLnJlcGxhY2UoJ18nLCAnJF8nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSkpLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIG51bGwsIFwiV2lsZGNhcmQgKCopIGNhbiBiZSB1c2VkXCIpLFxyXG4gICAgICAgICAgICAgICAgXCIgXCIpKSk7XHJcbn1cclxuZXhwb3J0cy5UZXh0RmlsdGVyID0gVGV4dEZpbHRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgR2VuZXJpY1NsaWNlLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIwLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAxMS8wNC8yMDIwIC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdG9vbGtpdF8xID0gcmVxdWlyZShcIkByZWR1eGpzL3Rvb2xraXRcIik7XHJcbnZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcclxudmFyIEdlbmVyaWNTbGljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHZW5lcmljU2xpY2Ugb2YgdHlwZSBULCB3aGljaCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGJhc2ljIENSVUQgb3BlcmF0aW9ucyBhZ2FpbnN0XHJcbiAgICAgKiBhIHNwZWNpZmllZCB3ZWIgYXBpLlxyXG4gICAgICogQHR5cGVQYXJhbSBUIC0gTW9kZWwgb2YgR2VuZXJpYyBTbGljZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBzdHJpbmcgZGVmaW5pbmcgdGhlIG5hbWUgb2YgdGhlIHNsaWNlIGluIHRoZSBzdG9yZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaVBhdGggLSBzdHJpbmcgY29udGFpbmluZyByZWxhdGl2ZSBwYXRoIHRvIHdlYiBhcGlcclxuICAgICAqIEBwYXJhbSB7a2V5b2YgVH0gZGVmYXVsdFNvcnQgLSBzdHJpbmcgc2hvd2luZyBkZWZhdWx0IHNvcnQgZmllbGRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXNjZW5kaW5nIC0gKG9wdGlvbmFsKSBkZWZhdWx0IHNvcnQgZGlyZWN0aW9uIC0gZGVmYXVsdHMgdG8gdHJ1ZVxyXG4gICAgICogQHJldHVybnMgYSBuZXcgR2VuZXJpY1NsaWNlPFQ+XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEdlbmVyaWNTbGljZShuYW1lLCBhcGlQYXRoLCBkZWZhdWx0U29ydCwgYXNjZW5kaW5nKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoYXNjZW5kaW5nID09PSB2b2lkIDApIHsgYXNjZW5kaW5nID0gdHJ1ZTsgfVxyXG4gICAgICAgIHRoaXMuTmFtZSA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5BUElQYXRoID0gXCJcIjtcclxuICAgICAgICB0aGlzLkRhdGEgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW190aGlzLk5hbWVdLkRhdGE7IH07XHJcbiAgICAgICAgdGhpcy5FcnJvciA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGVbX3RoaXMuTmFtZV0uRXJyb3I7IH07XHJcbiAgICAgICAgdGhpcy5EYXR1bSA9IGZ1bmN0aW9uIChzdGF0ZSwgaWQpIHsgcmV0dXJuIHN0YXRlW190aGlzLk5hbWVdLkRhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5JRCA9PT0gaWQ7IH0pOyB9O1xyXG4gICAgICAgIHRoaXMuU3RhdHVzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZVtfdGhpcy5OYW1lXS5TdGF0dXM7IH07XHJcbiAgICAgICAgdGhpcy5Tb3J0RmllbGQgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW190aGlzLk5hbWVdLlNvcnRGaWVsZDsgfTtcclxuICAgICAgICB0aGlzLkFzY2VuZGluZyA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGVbX3RoaXMuTmFtZV0uQXNjZW5kaW5nOyB9O1xyXG4gICAgICAgIHRoaXMuUGFyZW50SUQgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW190aGlzLk5hbWVdLlBhcmVudElEOyB9O1xyXG4gICAgICAgIHRoaXMuU2VhcmNoUmVzdWx0cyA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGVbX3RoaXMuTmFtZV0uU2VhcmNoUmVzdWx0czsgfTtcclxuICAgICAgICB0aGlzLlNlYXJjaFN0YXR1cyA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGVbX3RoaXMuTmFtZV0uU2VhcmNoU3RhdHVzOyB9O1xyXG4gICAgICAgIHRoaXMuU2VhcmNoRmlsdGVycyA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGVbX3RoaXMuTmFtZV0uRmlsdGVyOyB9O1xyXG4gICAgICAgIHRoaXMuTmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5BUElQYXRoID0gYXBpUGF0aDtcclxuICAgICAgICB0aGlzLmZldGNoSGFuZGxlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNlYXJjaEhhbmRsZSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGZldGNoID0gKDAsIHRvb2xraXRfMS5jcmVhdGVBc3luY1RodW5rKShuYW1lICsgXCIvRmV0Y2hcIiArIG5hbWUsIGZ1bmN0aW9uIChwYXJlbnRJRCwgX2EpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ25hbCA9IF9hLnNpZ25hbCwgZ2V0U3RhdGUgPSBfYS5nZXRTdGF0ZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSwgaGFuZGxlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmV0Y2hIYW5kbGUgIT0gbnVsbCAmJiB0aGlzLmZldGNoSGFuZGxlLmFib3J0ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mZXRjaEhhbmRsZS5hYm9ydCgnUHJldicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gdGhpcy5HZXRSZWNvcmRzKHN0YXRlLkFzY2VuZGluZywgc3RhdGUuU29ydEZpZWxkLCBwYXJlbnRJRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZldGNoSGFuZGxlID0gaGFuZGxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGUuYWJvcnQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGhhbmRsZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBkQkFjdGlvbiA9ICgwLCB0b29sa2l0XzEuY3JlYXRlQXN5bmNUaHVuaykobmFtZSArIFwiL0RCQWN0aW9uXCIgKyBuYW1lLCBmdW5jdGlvbiAoYXJncywgX2EpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ25hbCA9IF9hLnNpZ25hbDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSB0aGlzLkFjdGlvbihhcmdzLnZlcmIsIGFyZ3MucmVjb3JkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlLmFib3J0ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZS5hYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBoYW5kbGVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgZEJTZWFyY2ggPSAoMCwgdG9vbGtpdF8xLmNyZWF0ZUFzeW5jVGh1bmspKG5hbWUgKyBcIi9TZWFyY2hcIiArIG5hbWUsIGZ1bmN0aW9uIChhcmdzLCBfYSkge1xyXG4gICAgICAgICAgICB2YXIgZ2V0U3RhdGUgPSBfYS5nZXRTdGF0ZSwgc2lnbmFsID0gX2Euc2lnbmFsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvcnRmaWVsZCwgYXNjLCBoYW5kbGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZmllbGQgPSBhcmdzLnNvcnRGaWVsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzYyA9IGFyZ3MuYXNjZW5kaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydGZpZWxkID0gc29ydGZpZWxkID09PSB1bmRlZmluZWQgPyBnZXRTdGF0ZSgpW3RoaXMuTmFtZV0uU29ydEZpZWxkIDogc29ydGZpZWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNjID0gYXNjID09PSB1bmRlZmluZWQgPyBnZXRTdGF0ZSgpW3RoaXMuTmFtZV0uQXNjZW5kaW5nIDogYXNjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VhcmNoSGFuZGxlICE9IG51bGwgJiYgdGhpcy5zZWFyY2hIYW5kbGUuYWJvcnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaEhhbmRsZS5hYm9ydCgnUHJldicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gdGhpcy5TZWFyY2goYXJncy5maWx0ZXIsIGFzYywgc29ydGZpZWxkLCBnZXRTdGF0ZSgpW3RoaXMuTmFtZV0uUGFyZW50SUQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hIYW5kbGUgPSBoYW5kbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZS5hYm9ydCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaGFuZGxlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Iuc2VudCgpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGRCU29ydCA9ICgwLCB0b29sa2l0XzEuY3JlYXRlQXN5bmNUaHVuaykobmFtZSArIFwiL0RCU29ydFwiICsgbmFtZSwgZnVuY3Rpb24gKGFyZ3MsIF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduYWwgPSBfYS5zaWduYWwsIGdldFN0YXRlID0gX2EuZ2V0U3RhdGUsIGRpc3BhdGNoID0gX2EuZGlzcGF0Y2g7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUsIHNvcnRGbGQsIGFzYywgaGFuZGxlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydEZsZCA9IHN0YXRlLlNvcnRGaWVsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzYyA9IHN0YXRlLkFzY2VuZGluZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5Tb3J0RmllbGQgPT09IGFyZ3MuU29ydEZpZWxkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzYyA9ICFhcmdzLkFzY2VuZGluZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0RmxkID0gYXJncy5Tb3J0RmllbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChkQlNlYXJjaCh7IGZpbHRlcjogc3RhdGUuRmlsdGVyLCBzb3J0RmllbGQ6IHNvcnRGbGQsIGFzY2VuZGluZzogYXNjIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZldGNoSGFuZGxlICE9IG51bGwgJiYgdGhpcy5mZXRjaEhhbmRsZS5hYm9ydCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hIYW5kbGUuYWJvcnQoJ1ByZXYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHRoaXMuR2V0UmVjb3Jkcyhhc2MsIHNvcnRGbGQsIChzdGF0ZS5QYXJlbnRJRCAhPSBudWxsID8gc3RhdGUuUGFyZW50SUQgOiB1bmRlZmluZWQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hIYW5kbGUgPSBoYW5kbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZS5hYm9ydCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaGFuZGxlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Iuc2VudCgpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHNsaWNlID0gKDAsIHRvb2xraXRfMS5jcmVhdGVTbGljZSkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLk5hbWUsXHJcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZToge1xyXG4gICAgICAgICAgICAgICAgU3RhdHVzOiAndW5pbnRpYXRlZCcsXHJcbiAgICAgICAgICAgICAgICBTZWFyY2hTdGF0dXM6ICd1bmludGlhdGVkJyxcclxuICAgICAgICAgICAgICAgIEVycm9yOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgRGF0YTogW10sXHJcbiAgICAgICAgICAgICAgICBTb3J0RmllbGQ6IGRlZmF1bHRTb3J0LFxyXG4gICAgICAgICAgICAgICAgQXNjZW5kaW5nOiBhc2NlbmRpbmcsXHJcbiAgICAgICAgICAgICAgICBQYXJlbnRJRDogbnVsbCxcclxuICAgICAgICAgICAgICAgIFNlYXJjaFJlc3VsdHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgRmlsdGVyOiBbXSxcclxuICAgICAgICAgICAgICAgIEFjdGl2ZUZldGNoSUQ6IFtdLFxyXG4gICAgICAgICAgICAgICAgQWN0aXZlU2VhcmNoSUQ6IFtdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlZHVjZXJzOiB7fSxcclxuICAgICAgICAgICAgZXh0cmFSZWR1Y2VyczogZnVuY3Rpb24gKGJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShmZXRjaC5mdWxmaWxsZWQsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuQWN0aXZlRmV0Y2hJRCA9IHN0YXRlLkFjdGl2ZUZldGNoSUQuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgIT09IGFjdGlvbi5tZXRhLnJlcXVlc3RJZDsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuU3RhdHVzID0gJ2lkbGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLkVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5EYXRhID0gSlNPTi5wYXJzZShhY3Rpb24ucGF5bG9hZC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRDYXNlKGZldGNoLnBlbmRpbmcsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLlBhcmVudElEICE9PSAoYWN0aW9uLm1ldGEuYXJnID09IG51bGwgPyBudWxsIDogYWN0aW9uLm1ldGEuYXJnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuU2VhcmNoU3RhdHVzID0gJ2NoYW5nZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLlBhcmVudElEID0gKGFjdGlvbi5tZXRhLmFyZyA9PSBudWxsID8gbnVsbCA6IGFjdGlvbi5tZXRhLmFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuU3RhdHVzID0gJ2xvYWRpbmcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLkFjdGl2ZUZldGNoSUQucHVzaChhY3Rpb24ubWV0YS5yZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZENhc2UoZmV0Y2gucmVqZWN0ZWQsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuQWN0aXZlRmV0Y2hJRCA9IHN0YXRlLkFjdGl2ZUZldGNoSUQuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgIT09IGFjdGlvbi5tZXRhLnJlcXVlc3RJZDsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLkFjdGl2ZUZldGNoSUQubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdlcnJvcic7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuRXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2U6IChhY3Rpb24uZXJyb3IubWVzc2FnZSA9PSBudWxsID8gJycgOiBhY3Rpb24uZXJyb3IubWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcmI6ICdGRVRDSCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRpbWU6IG5ldyBEYXRlKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShkQkFjdGlvbi5wZW5kaW5nLCBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5TdGF0dXMgPSAnbG9hZGluZyc7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShkQkFjdGlvbi5yZWplY3RlZCwgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5TdGF0dXMgPSAnZXJyb3InO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLkVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlOiAoYWN0aW9uLmVycm9yLm1lc3NhZ2UgPT0gbnVsbCA/ICcnIDogYWN0aW9uLmVycm9yLm1lc3NhZ2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZXJiOiBhY3Rpb24ubWV0YS5hcmcudmVyYixcclxuICAgICAgICAgICAgICAgICAgICAgICAgVGltZTogbmV3IERhdGUoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRDYXNlKGRCQWN0aW9uLmZ1bGZpbGxlZCwgZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuU3RhdHVzID0gJ2NoYW5nZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLlNlYXJjaFN0YXR1cyA9ICdjaGFuZ2VkJztcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5FcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShkQlNlYXJjaC5wZW5kaW5nLCBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLlNlYXJjaFN0YXR1cyA9ICdsb2FkaW5nJztcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5BY3RpdmVTZWFyY2hJRC5wdXNoKGFjdGlvbi5tZXRhLnJlcXVlc3RJZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShkQlNlYXJjaC5yZWplY3RlZCwgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5BY3RpdmVTZWFyY2hJRCA9IHN0YXRlLkFjdGl2ZVNlYXJjaElELmZpbHRlcihmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkICE9PSBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQ7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5BY3RpdmVTZWFyY2hJRC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuU2VhcmNoU3RhdHVzID0gJ2Vycm9yJztcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5FcnJvciA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZTogKGFjdGlvbi5lcnJvci5tZXNzYWdlID09IG51bGwgPyAnJyA6IGFjdGlvbi5lcnJvci5tZXNzYWdlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVyYjogJ1NFQVJDSCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRpbWU6IG5ldyBEYXRlKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShkQlNlYXJjaC5mdWxmaWxsZWQsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuQWN0aXZlU2VhcmNoSUQgPSBzdGF0ZS5BY3RpdmVTZWFyY2hJRC5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZCAhPT0gYWN0aW9uLm1ldGEucmVxdWVzdElkOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5TZWFyY2hTdGF0dXMgPSAnaWRsZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuU2VhcmNoUmVzdWx0cyA9IEpTT04ucGFyc2UoYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLkZpbHRlciA9IGFjdGlvbi5tZXRhLmFyZy5maWx0ZXI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShkQlNvcnQucGVuZGluZywgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5TdGF0dXMgPSAnbG9hZGluZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuQWN0aXZlRmV0Y2hJRC5wdXNoKGFjdGlvbi5tZXRhLnJlcXVlc3RJZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShkQlNvcnQucmVqZWN0ZWQsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuQWN0aXZlRmV0Y2hJRCA9IHN0YXRlLkFjdGl2ZUZldGNoSUQuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgIT09IGFjdGlvbi5tZXRhLnJlcXVlc3RJZDsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLkFjdGl2ZUZldGNoSUQubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdlcnJvcic7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuRXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2U6IChhY3Rpb24uZXJyb3IubWVzc2FnZSA9PSBudWxsID8gJycgOiBhY3Rpb24uZXJyb3IubWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcmI6ICdGRVRDSCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRpbWU6IG5ldyBEYXRlKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShkQlNvcnQuZnVsZmlsbGVkLCBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLkFjdGl2ZUZldGNoSUQgPSBzdGF0ZS5BY3RpdmVGZXRjaElELmZpbHRlcihmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkICE9PSBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQ7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdpZGxlJztcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5FcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuRGF0YSA9IEpTT04ucGFyc2UoYWN0aW9uLnBheWxvYWQudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLlNvcnRGaWVsZCA9PT0gYWN0aW9uLm1ldGEuYXJnLlNvcnRGaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuQXNjZW5kaW5nID0gIXN0YXRlLkFzY2VuZGluZztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLlNvcnRGaWVsZCA9IGFjdGlvbi5tZXRhLmFyZy5Tb3J0RmllbGQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuRmV0Y2ggPSBmZXRjaDtcclxuICAgICAgICB0aGlzLkRCQWN0aW9uID0gZEJBY3Rpb247XHJcbiAgICAgICAgdGhpcy5TbGljZSA9IHNsaWNlO1xyXG4gICAgICAgIHRoaXMuREJTZWFyY2ggPSBkQlNlYXJjaDtcclxuICAgICAgICB0aGlzLlNvcnQgPSBkQlNvcnQ7XHJcbiAgICAgICAgdGhpcy5SZWR1Y2VyID0gc2xpY2UucmVkdWNlcjtcclxuICAgIH1cclxuICAgIEdlbmVyaWNTbGljZS5wcm90b3R5cGUuR2V0UmVjb3JkcyA9IGZ1bmN0aW9uIChhc2NlbmRpbmcsIHNvcnRGaWVsZCwgcGFyZW50SUQpIHtcclxuICAgICAgICByZXR1cm4gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBcIlwiICsgdGhpcy5BUElQYXRoICsgKHBhcmVudElEICE9IG51bGwgPyAnLycgKyBwYXJlbnRJRCA6ICcnKSArIFwiL1wiICsgc29ydEZpZWxkICsgXCIvXCIgKyAoYXNjZW5kaW5nID8gJzEnIDogJzAnKSxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBHZW5lcmljU2xpY2UucHJvdG90eXBlLkFjdGlvbiA9IGZ1bmN0aW9uICh2ZXJiLCByZWNvcmQpIHtcclxuICAgICAgICB2YXIgYWN0aW9uID0gJyc7XHJcbiAgICAgICAgaWYgKHZlcmIgPT09ICdQT1NUJylcclxuICAgICAgICAgICAgYWN0aW9uID0gJ0FkZCc7XHJcbiAgICAgICAgZWxzZSBpZiAodmVyYiA9PT0gJ0RFTEVURScpXHJcbiAgICAgICAgICAgIGFjdGlvbiA9ICdEZWxldGUnO1xyXG4gICAgICAgIGVsc2UgaWYgKHZlcmIgPT09ICdQQVRDSCcpXHJcbiAgICAgICAgICAgIGFjdGlvbiA9ICdVcGRhdGUnO1xyXG4gICAgICAgIHJldHVybiAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiB2ZXJiLFxyXG4gICAgICAgICAgICB1cmw6IHRoaXMuQVBJUGF0aCArIFwiL1wiICsgYWN0aW9uLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KF9fYXNzaWduKHt9LCByZWNvcmQpKSxcclxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEdlbmVyaWNTbGljZS5wcm90b3R5cGUuU2VhcmNoID0gZnVuY3Rpb24gKGZpbHRlciwgYXNjZW5kaW5nLCBzb3J0RmllbGQsIHBhcmVudElEKSB7XHJcbiAgICAgICAgcmV0dXJuICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcclxuICAgICAgICAgICAgdXJsOiB0aGlzLkFQSVBhdGggKyBcIi9cIiArIChwYXJlbnRJRCAhPSBudWxsID8gcGFyZW50SUQgKyBcIi9cIiA6ICcnKSArIFwiU2VhcmNoYWJsZUxpc3RcIixcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7IFNlYXJjaGVzOiBmaWx0ZXIsIE9yZGVyQnk6IHNvcnRGaWVsZCwgQXNjZW5kaW5nOiBhc2NlbmRpbmcgfSksXHJcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gR2VuZXJpY1NsaWNlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBHZW5lcmljU2xpY2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIExvYWRpbmdJY29uLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIwLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwMS8xMS8yMDIwIC0gQ2hyaXN0b3BoIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIHN0eWxlZF9jb21wb25lbnRzXzEgPSByZXF1aXJlKFwic3R5bGVkLWNvbXBvbmVudHNcIik7XHJcbnZhciBzcGluID0gKDAsIHN0eWxlZF9jb21wb25lbnRzXzEua2V5ZnJhbWVzKSh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuIDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cXG4gMTAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cXG5cIl0sIFtcIlxcbiAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XFxuIDEwMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9XFxuXCJdKSkpO1xyXG52YXIgSWNvbiA9IHN0eWxlZF9jb21wb25lbnRzXzEuZGVmYXVsdC5kaXYodGVtcGxhdGVPYmplY3RfMiB8fCAodGVtcGxhdGVPYmplY3RfMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdGFuaW1hdGlvbjogXCIsIFwiIDFzIGxpbmVhciBpbmZpbml0ZTtcXG5cXHRib3JkZXI6IFwiLCBcInB4IHNvbGlkICNmM2YzZjM7XFxuXFx0Ym9yZGVyLVRvcDogXCIsIFwicHggc29saWQgIzU1NTtcXG5cXHRib3JkZXItUmFkaXVzOiA1MCU7XFxuXFx0d2lkdGg6IFwiLCBcInB4O1xcblxcdGhlaWdodDogXCIsIFwicHhcXG5cIl0sIFtcIlxcblxcdGFuaW1hdGlvbjogXCIsIFwiIDFzIGxpbmVhciBpbmZpbml0ZTtcXG5cXHRib3JkZXI6IFwiLCBcInB4IHNvbGlkICNmM2YzZjM7XFxuXFx0Ym9yZGVyLVRvcDogXCIsIFwicHggc29saWQgIzU1NTtcXG5cXHRib3JkZXItUmFkaXVzOiA1MCU7XFxuXFx0d2lkdGg6IFwiLCBcInB4O1xcblxcdGhlaWdodDogXCIsIFwicHhcXG5cIl0pKSwgc3BpbiwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBwcm9wcy5zaXplIC8gNTsgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBwcm9wcy5zaXplIC8gNTsgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBwcm9wcy5zaXplOyB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIHByb3BzLnNpemU7IH0pO1xyXG52YXIgTG9hZGluZ0ljb24gPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgIHZhciBoID0gKHByb3BzLlNpemUgPT09IHVuZGVmaW5lZCA/IDI1IDogcHJvcHMuU2l6ZSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgd2lkdGg6IChwcm9wcy5MYWJlbCA9PT0gdW5kZWZpbmVkID8gaCA6IHVuZGVmaW5lZCksIG1hcmdpbjogJ2F1dG8nIH0sIGhpZGRlbjogIXByb3BzLlNob3cgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uLCB7IHNpemU6IGggfSksXHJcbiAgICAgICAgICAgIHByb3BzLkxhYmVsICE9PSB1bmRlZmluZWQgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBwcm9wcy5MYWJlbCkgOiBudWxsKSkpO1xyXG59O1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMb2FkaW5nSWNvbjtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEsIHRlbXBsYXRlT2JqZWN0XzI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIExvYWRpbmdTY3JlZW4udHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDAxLzExLzIwMjAgLSBDaHJpc3RvcGggTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgTG9hZGluZ0ljb25fMSA9IHJlcXVpcmUoXCIuL0xvYWRpbmdJY29uXCIpO1xyXG52YXIgTG9hZGluZ1NjcmVlbiA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgdmFyIHggPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gMjA7XHJcbiAgICByZXR1cm4gKHByb3BzLlNob3cgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgICAgIHpJbmRleDogOTk4MCxcclxuICAgICAgICB9IH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IGhlaWdodDogJzQwcHgnLCB3aWR0aDogJzQwcHgnLCBtYXJnaW46ICdhdXRvJywgbWFyZ2luVG9wOiB4IH0gfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChMb2FkaW5nSWNvbl8xLmRlZmF1bHQsIHsgU2hvdzogdHJ1ZSwgU2l6ZTogNDAgfSkpKSA6IG51bGwpO1xyXG59O1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMb2FkaW5nU2NyZWVuO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBBcHBsaWNhdGlvbi50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDIvMTMvMjAyMiAtIEMuIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9Db250ZXh0XCIpO1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciByZWFjdF9yb3V0ZXJfZG9tXzEgPSByZXF1aXJlKFwicmVhY3Qtcm91dGVyLWRvbVwiKTtcclxudmFyIFBhZ2VfMSA9IHJlcXVpcmUoXCIuL1BhZ2VcIik7XHJcbnZhciBTZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9TZWN0aW9uXCIpO1xyXG52YXIgTG9hZGluZ1NjcmVlbl8xID0gcmVxdWlyZShcIi4uL0xvYWRpbmdTY3JlZW5cIik7XHJcbnZhciBTZXJ2ZXJFcnJvckljb25fMSA9IHJlcXVpcmUoXCIuLi9TZXJ2ZXJFcnJvckljb25cIik7XHJcbnZhciBzdHlsZWRfY29tcG9uZW50c18xID0gcmVxdWlyZShcInN0eWxlZC1jb21wb25lbnRzXCIpO1xyXG52YXIgZ3BhX3N5bWJvbHNfMSA9IHJlcXVpcmUoXCJAZ3BhLWdlbXN0b25lL2dwYS1zeW1ib2xzXCIpO1xyXG52YXIgU2lkZWJhck5hdiA9IHN0eWxlZF9jb21wb25lbnRzXzEuZGVmYXVsdC5uYXYodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgJiB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHotaW5kZXg6IDEwMDtcXG4gICAgcGFkZGluZzogNDhweCAwIDA7XFxuICAgIGJveC1zaGFkb3c6IGluc2V0IC0xcHggMCAwIHJnYmEoMCwwLDAsLjEpO1xcbiAgICB3aWR0aDogXCIsIFwicHg7XFxuICB9XCJdLCBbXCJcXG4gICYge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB6LWluZGV4OiAxMDA7XFxuICAgIHBhZGRpbmc6IDQ4cHggMCAwO1xcbiAgICBib3gtc2hhZG93OiBpbnNldCAtMXB4IDAgMCByZ2JhKDAsMCwwLC4xKTtcXG4gICAgd2lkdGg6IFwiLCBcInB4O1xcbiAgfVwiXSkpLCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIHByb3BzLmNvbGxhcHNlZCA/IDUwIDogMjAwOyB9KTtcclxudmFyIFNpZGViYXJEaXYgPSBzdHlsZWRfY29tcG9uZW50c18xLmRlZmF1bHQuZGl2KHRlbXBsYXRlT2JqZWN0XzIgfHwgKHRlbXBsYXRlT2JqZWN0XzIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICYge1xcbiAgICBwb3NpdGlvbjogLXdlYmtpdC1zdGlja3k7XFxuICAgIHBvc2l0aW9uOiBzdGlja3k7XFxuICAgIGhlaWdodDogY2FsYyggMTAwJSAtIDM1cHgpO1xcbiAgfVwiXSwgW1wiXFxuICAmIHtcXG4gICAgcG9zaXRpb246IC13ZWJraXQtc3RpY2t5O1xcbiAgICBwb3NpdGlvbjogc3RpY2t5O1xcbiAgICBoZWlnaHQ6IGNhbGMoIDEwMCUgLSAzNXB4KTtcXG4gIH1cIl0pKSk7XHJcbnZhciBNYWluRGl2ID0gc3R5bGVkX2NvbXBvbmVudHNfMS5kZWZhdWx0LmRpdih0ZW1wbGF0ZU9iamVjdF8zIHx8ICh0ZW1wbGF0ZU9iamVjdF8zID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuJiB7XFxuICAgIHRvcDogNDBweDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogY2FsYygxMDAlIC0gXCIsIFwicHgpO1xcbiAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDQ4cHgpO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBsZWZ0OiBcIiwgXCJweDtcXG59XFxuJiBzdmcge1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gfVwiXSwgW1wiXFxuJiB7XFxuICAgIHRvcDogNDBweDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogY2FsYygxMDAlIC0gXCIsIFwicHgpO1xcbiAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDQ4cHgpO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBsZWZ0OiBcIiwgXCJweDtcXG59XFxuJiBzdmcge1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gfVwiXSkpLCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIHByb3BzLmNvbGxhcHNlZCA/IDUwIDogMjAwOyB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIHByb3BzLmNvbGxhcHNlZCA/IDUwIDogMjAwOyB9KTtcclxudmFyIEFwcGxpY2F0aW9ucyA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLCBjb2xsYXBzZWQgPSBfYVswXSwgc2V0Q29sbGFwc2VkID0gX2FbMV07XHJcbiAgICB2YXIgc2hvd09wZW4gPSBwcm9wcy5BbGxvd0NvbGxhcHNlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLkFsbG93Q29sbGFwc2VkICYmIGNvbGxhcHNlZDtcclxuICAgIHZhciBzaG93Q2xvc2UgPSBwcm9wcy5BbGxvd0NvbGxhcHNlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLkFsbG93Q29sbGFwc2VkICYmICFjb2xsYXBzZWQ7XHJcbiAgICBmdW5jdGlvbiBHZXRDb250ZXh0KCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBob21lUGF0aDogcHJvcHMuSG9tZVBhdGgsXHJcbiAgICAgICAgICAgIHVzZXJSb2xlczogKChfYSA9IHByb3BzLlVzZXJSb2xlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogWydWaWV3ZXInXSksXHJcbiAgICAgICAgICAgIGNvbGxhcHNlZDogY29sbGFwc2VkXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIENyZWF0ZVJvdXRlKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoZWxlbWVudC5wcm9wcy5SZXF1aXJlZFJvbGVzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudC5wcm9wcy5SZXF1aXJlZFJvbGVzLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gR2V0Q29udGV4dCgpLnVzZXJSb2xlcy5maW5kSW5kZXgoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkgPT09IHI7IH0pID4gLTE7IH0pLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3Rfcm91dGVyX2RvbV8xLlJvdXRlLCB7IHBhdGg6IFwiXCIgKyBwcm9wcy5Ib21lUGF0aCArIGVsZW1lbnQucHJvcHMuTmFtZSwgZWxlbWVudDogUmVhY3QuY3JlYXRlRWxlbWVudChTZXJ2ZXJFcnJvckljb25fMS5kZWZhdWx0LCB7IFNob3c6IHRydWUsIExhYmVsOiAnWW91IGFyZSBub3QgYXV0aG9yaXplZCB0byB2aWV3IHRoaXMgcGFnZScgfSkgfSk7XHJcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3Rfcm91dGVyX2RvbV8xLlJvdXRlLCB7IHBhdGg6IFwiXCIgKyBwcm9wcy5Ib21lUGF0aCArIGVsZW1lbnQucHJvcHMuTmFtZSwgZWxlbWVudDogZWxlbWVudC5wcm9wcy5jaGlsZHJlbiB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN1c3BlbnNlLCB7IGZhbGxiYWNrOiBSZWFjdC5jcmVhdGVFbGVtZW50KExvYWRpbmdTY3JlZW5fMS5kZWZhdWx0LCB7IFNob3c6IHRydWUgfSkgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRfMS5Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBHZXRDb250ZXh0KCkgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdF9yb3V0ZXJfZG9tXzEuQnJvd3NlclJvdXRlciwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogeyB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LCBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibmF2XCIsIHsgY2xhc3NOYW1lOiBcIm5hdmJhciBuYXZiYXItZGFyayBmaXhlZC10b3AgYmctZGFyayBmbGV4LW1kLW5vd3JhcCBwLTAgc2hhZG93XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd09wZW4gPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IHN0eWxlOiB7IGNvbG9yOiAnI2Y4ZjlmYScsIG1hcmdpbkxlZnQ6IDE1IH0sIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldENvbGxhcHNlZChmYWxzZSk7IH0gfSwgZ3BhX3N5bWJvbHNfMS5TVkdJY29ucy5BcnJvd0ZvcndhcmQpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0Nsb3NlID8gUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgeyBzdHlsZTogeyBjb2xvcjogJyNmOGY5ZmEnLCBtYXJnaW5MZWZ0OiAxNSB9LCBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRDb2xsYXBzZWQodHJ1ZSk7IH0gfSwgZ3BhX3N5bWJvbHNfMS5TVkdJY29ucy5BcnJvd0JhY2t3YXJkKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLkxvZ28gIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IGNsYXNzTmFtZTogXCJuYXZiYXItYnJhbmQgY29sLXNtLTMgY29sLW1kLTIgbXItMCBtci1hdXRvXCIsIGhyZWY6IHByb3BzLkhvbWVQYXRoIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7IHN0eWxlOiB7IG1heEhlaWdodDogMzUsIG1hcmdpbjogLTUgfSwgc3JjOiBwcm9wcy5Mb2dvIH0pKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7IGNsYXNzTmFtZTogXCJuYXZiYXItbmF2IHB4LTMgbWwtYXV0b1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwgeyBjbGFzc05hbWU6IFwibmF2LWl0ZW0gdGV4dC1ub3dyYXBcIiB9LCBwcm9wcy5PblNpZ25PdXQgIT09IHVuZGVmaW5lZCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgY2xhc3NOYW1lOiBcIm5hdi1saW5rXCIsIG9uQ2xpY2s6IHByb3BzLk9uU2lnbk91dCB9LCBcIlNpZ24gb3V0XCIpIDogbnVsbCkpKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFNpZGViYXJOYXYsIHsgY2xhc3NOYW1lOiBcImJnLWxpZ2h0XCIsIGNvbGxhcHNlZDogY29sbGFwc2VkIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2lkZWJhckRpdiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7IGNsYXNzTmFtZTogXCJuYXZiYXItbmF2IHB4LTNcIiB9LCBSZWFjdC5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gUGFnZV8xLmRlZmF1bHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuQ2hpbGRyZW4ubWFwKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IFNlY3Rpb25fMS5kZWZhdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuVmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmICFjb2xsYXBzZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IHdpZHRoOiAnMTAwJScsIHRleHRBbGlnbjogJ2NlbnRlcicsIGhlaWdodDogMzUgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVmVyc2lvbiBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuVmVyc2lvbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwpKSA6IG51bGwpLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFpbkRpdiwgeyBjb2xsYXBzZWQ6IGNvbGxhcHNlZCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0X3JvdXRlcl9kb21fMS5Sb3V0ZXMsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0X3JvdXRlcl9kb21fMS5Sb3V0ZSwgeyBwYXRoOiBcIlwiICsgcHJvcHMuSG9tZVBhdGggfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0X3JvdXRlcl9kb21fMS5Sb3V0ZSwgeyBpbmRleDogdHJ1ZSwgZWxlbWVudDogUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdF9yb3V0ZXJfZG9tXzEuTmF2aWdhdGUsIHsgdG86IFwiXCIgKyBwcm9wcy5Ib21lUGF0aCArIHByb3BzLkRlZmF1bHRQYXRoIH0pIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkNoaWxkcmVuLm1hcChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBQYWdlXzEuZGVmYXVsdCAmJiBSZWFjdC5DaGlsZHJlbi5jb3VudChlbGVtZW50LnByb3BzLmNoaWxkcmVuKSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlUm91dGUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFNlY3Rpb25fMS5kZWZhdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLm1hcChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IFBhZ2VfMS5kZWZhdWx0ICYmIFJlYWN0LkNoaWxkcmVuLmNvdW50KGUucHJvcHMuY2hpbGRyZW4pID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVJvdXRlKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSkpKSkpKTtcclxufTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQXBwbGljYXRpb25zO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSwgdGVtcGxhdGVPYmplY3RfMiwgdGVtcGxhdGVPYmplY3RfMztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgQ2lyY2xlUGx1c1NWRy50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDIvMTMvMjAyMiAtIEMuIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ29udGV4dCA9IHZvaWQgMDtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG47XHJcbmV4cG9ydHMuQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xyXG4gICAgaG9tZVBhdGg6ICcnLFxyXG4gICAgdXNlclJvbGVzOiBbJ1ZpZXdlciddLFxyXG4gICAgY29sbGFwc2VkOiBmYWxzZVxyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgUGFnZS50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMTAvMDUvMjAyMCAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFRvb2xUaXBfMSA9IHJlcXVpcmUoXCIuLi9Ub29sVGlwXCIpO1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciByZWFjdF9yb3V0ZXJfZG9tXzEgPSByZXF1aXJlKFwicmVhY3Qtcm91dGVyLWRvbVwiKTtcclxudmFyIENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0NvbnRleHRcIik7XHJcbnZhciBQYWdlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksIGhvdmVyID0gX2FbMF0sIHNldEhvdmVyID0gX2FbMV07XHJcbiAgICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dF8xLkNvbnRleHQpO1xyXG4gICAgaWYgKHByb3BzLlJlcXVpcmVkUm9sZXMgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5SZXF1aXJlZFJvbGVzLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gY29udGV4dC51c2VyUm9sZXMuZmluZEluZGV4KGZ1bmN0aW9uIChpKSB7IHJldHVybiBpID09PSByOyB9KSA+IC0xOyB9KS5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAocHJvcHMuTGFiZWwgIT09IHVuZGVmaW5lZCB8fCBwcm9wcy5JY29uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwgeyBjbGFzc05hbWU6IFwibmF2LWl0ZW1cIiwgc3R5bGU6IHsgcG9zaXRpb246ICdyZWxhdGl2ZScgfSB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdF9yb3V0ZXJfZG9tXzEuTmF2TGluaywgeyBcImRhdGEtdG9vbHRpcFwiOiBwcm9wcy5OYW1lLCBjbGFzc05hbWU6IFwibmF2LWxpbmtcIiwgdG86IFwiXCIgKyBjb250ZXh0LmhvbWVQYXRoICsgcHJvcHMuTmFtZSwgc3R5bGU6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAoeyBjb2xvcjogYS5pc0FjdGl2ZSA/ICcjMDA3YmZmJyA6ICcjNzg4MjhkJyB9KTsgfSwgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRIb3Zlcih0cnVlKTsgfSwgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRIb3ZlcihmYWxzZSk7IH0gfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5JY29uICE9PSB1bmRlZmluZWQgPyBwcm9wcy5JY29uIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAhY29udGV4dC5jb2xsYXBzZWQgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuTGFiZWwpIDogbnVsbCkpLFxyXG4gICAgICAgICAgICBjb250ZXh0LmNvbGxhcHNlZCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbFRpcF8xLmRlZmF1bHQsIHsgVGFyZ2V0OiBwcm9wcy5OYW1lLCBTaG93OiBob3ZlciwgUG9zaXRpb246ICdyaWdodCcgfSxcclxuICAgICAgICAgICAgICAgIFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgcHJvcHMuTGFiZWwpIDogbnVsbCkpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFBhZ2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIEhlYWRlci50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDIvMTMvMjAyMiAtIEMuIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0NvbnRleHRcIik7XHJcbnZhciBTZWN0aW9uID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dF8xLkNvbnRleHQpO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoclwiLCBudWxsKSxcclxuICAgICAgICBwcm9wcy5MYWJlbCAhPT0gdW5kZWZpbmVkICYmICFjb250ZXh0LmNvbGxhcHNlZCA/XHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDZcIiwgeyBjbGFzc05hbWU6IFwic2lkZWJhci1oZWFkaW5nIGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBhbGlnbi1pdGVtcy1jZW50ZXIgcHgtMyBtdC00IG1iLTEgdGV4dC1tdXRlZFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgcHJvcHMuTGFiZWwpKSkgOiBudWxsLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7IGNsYXNzTmFtZTogXCJuYXZiYXItbmF2IHB4LTNcIiB9LCBwcm9wcy5jaGlsZHJlbikpKTtcclxufTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU2VjdGlvbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgTW9kYWwudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDEyLzI5LzIwMjAgLSBDaHJpc3RvcGggTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgVG9vbFRpcF8xID0gcmVxdWlyZShcIi4vVG9vbFRpcFwiKTtcclxudmFyIGhlbHBlcl9mdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCJAZ3BhLWdlbXN0b25lL2hlbHBlci1mdW5jdGlvbnNcIik7XHJcbi8vIFByb3BzIERlc2NyaXB0aW9uOlxyXG4vLyBUaXRsZSA9PiBUaXRsZSBvZiBUaGUgTW9kYWxcclxuLy8gU2hvd1ggPT4gc2hvdyBvciBoaWRlIHRoZSBYIGJ1dHRvbiAoZGVmYXVsdCB0cnVlKVxyXG4vLyBDYWxsQmFjayA9PiBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBjbG9zaW5nIHRoZSBNb2RhbCBlaXRoZXIgdGhyb3VnaCBDYW5jZWwgKGNvbmZpcm1lZD1mYWxzZSkgb3IgQWNjZXB0IEJ1dHRvbiAoY29uZmlybWVkPXRydWUpXHJcbi8vIFNob3cgPT4gV2hldGhlciB0byBzaG93IHRoZSBtb2RhbFxyXG4vLyBTaXplID0+IFNpemUgb2YgdGhlIG1vZGFsXHJcbi8vIFNob3dDYW5jZWwgPT4gV2hldGhlciB0byBzaG93IHRoZSBjYW5jZWwgYnV0dG9uXHJcbi8vIERpc2FibGVDb25maXJtID0+IERpc2FibGVzIHRoZSBDb25maXJtIGJ1dHRvblxyXG4vLyBDYW5jZWxUZXh0ID0+IFRleHQgb24gQ2FuY2VsIEJ1dHRvblxyXG4vLyBDb25maXJtIHRleHQgPT4gVGV4dCBvbiBDb25maXJtIGJ1dHRvblxyXG4vLyBDb25maXJtQnRuQ2xhc3MgPT4gQ2xhc3Mgb2YgdGhlIENvbmZpcm0gQnV0dG9uXHJcbi8vIENhbmNlbEJ0bkNsYXNzID0+PiBDbGFzcyBvZiB0aGUgQ2FuY2VsIEJ1dHRvblxyXG52YXIgTW9kYWwgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgIHZhciBfYSA9IFJlYWN0LnVzZVN0YXRlKCdub25lJyksIGhvdmVyID0gX2FbMF0sIHNldEhvdmVyID0gX2FbMV07XHJcbiAgICB2YXIgX2IgPSBSZWFjdC51c2VTdGF0ZSgnJyksIGd1aWQgPSBfYlswXSwgc2V0R3VpZCA9IF9iWzFdO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZXRHdWlkKCgwLCBoZWxwZXJfZnVuY3Rpb25zXzEuQ3JlYXRlR3VpZCkoKSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICB2YXIgY29uZmlybUJ0biA9IChwcm9wcy5Db25maXJtVGV4dCA9PT0gdW5kZWZpbmVkID8gJ1NhdmUnIDogcHJvcHMuQ29uZmlybVRleHQpO1xyXG4gICAgdmFyIGN4bkJ0biA9IChwcm9wcy5DYW5jZWxUZXh0ID09PSB1bmRlZmluZWQgPyAnQ2FuY2VsJyA6IHByb3BzLkNhbmNlbFRleHQpO1xyXG4gICAgdmFyIGN4bmJ0bkNscyA9ICdidG4gJyArIChwcm9wcy5DYW5jZWxCdG5DbGFzcyA9PT0gdW5kZWZpbmVkID8gJ2J0bi1kYW5nZXInIDogcHJvcHMuQ2FuY2VsQnRuQ2xhc3MpO1xyXG4gICAgdmFyIGNvbmZpcm1idG5DbHMgPSAnYnRuICcgKyAocHJvcHMuQ29uZmlybUJ0bkNsYXNzID09PSB1bmRlZmluZWQgPyAnYnRuLXByaW1hcnknIDogcHJvcHMuQ29uZmlybUJ0bkNsYXNzKTtcclxuICAgIHZhciBzaG93Q29uZmlybVRvb2xUaXAgPSAocHJvcHMuQ29uZmlybVNob3dUb29sVGlwICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuQ29uZmlybVNob3dUb29sVGlwKSAmJiBob3ZlciA9PT0gJ2NvbmZpcm0nO1xyXG4gICAgdmFyIHNob3dDeG5Ub29sVGlwID0gKHByb3BzLkNhbmNlbFNob3dUb29sVGlwICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuQ2FuY2VsU2hvd1Rvb2xUaXApICYmIGhvdmVyID09PSAnY2FuY2VsJztcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm1vZGFsXCIgKyAocHJvcHMuU2hvdyA/IFwiIHNob3dcIiA6ICcnKSwgc3R5bGU6IHByb3BzLlNob3cgPyB7IGRpc3BsYXk6ICdibG9jaycsIHpJbmRleDogOTk5MCB9IDoge30gfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJtb2RhbC1kaWFsb2dcIiArIChwcm9wcy5TaXplID09PSB1bmRlZmluZWQgPyAnJyA6IHByb3BzLlNpemUgPT09ICd4bGcnID8gJycgOiAoXCIgbW9kYWwtXCIgKyBwcm9wcy5TaXplKSksIHN0eWxlOiBwcm9wcy5TaXplID09PSAneGxnJyA/IHsgbWF4V2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoIC0gMTAwIH0gOiB7fSB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJtb2RhbC1jb250ZW50XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm1vZGFsLWhlYWRlclwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7IGNsYXNzTmFtZTogXCJtb2RhbC10aXRsZVwiIH0sIHByb3BzLlRpdGxlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuU2hvd1ggPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcImNsb3NlXCIsIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BzLkNhbGxCYWNrKGZhbHNlLCBmYWxzZSk7IH0gfSwgXCJcXHUwMEQ3XCIpIDogbnVsbCksXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJtb2RhbC1ib2R5XCIgfSwgcHJvcHMuU2hvdyA/IHByb3BzLmNoaWxkcmVuIDogbnVsbCksXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJtb2RhbC1mb290ZXJcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBjb25maXJtYnRuQ2xzICsgKCEocHJvcHMuRGlzYWJsZUNvbmZpcm0gPT09IHVuZGVmaW5lZCB8fCAhcHJvcHMuRGlzYWJsZUNvbmZpcm0pID8gJyBkaXNhYmxlZCcgOiAnJyksIFwiZGF0YS10b29sdGlwXCI6IGd1aWQgKyAnLWNvbmZpcm0nLCBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7IGlmICghKHByb3BzLkRpc2FibGVDb25maXJtID09PSB1bmRlZmluZWQgfHwgIXByb3BzLkRpc2FibGVDb25maXJtKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IHByb3BzLkNhbGxCYWNrKHRydWUsIHRydWUpOyB9LCBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldEhvdmVyKCdjb25maXJtJyk7IH0sIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0SG92ZXIoJ25vbmUnKTsgfSB9LCBjb25maXJtQnRuKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuU2hvd0NhbmNlbCA9PT0gdW5kZWZpbmVkIHx8IHByb3BzLlNob3dDYW5jZWwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogY3huYnRuQ2xzICsgKCEocHJvcHMuRGlzYWJsZUNhbmNlbCA9PT0gdW5kZWZpbmVkIHx8ICFwcm9wcy5EaXNhYmxlQ2FuY2VsKSA/ICcgZGlzYWJsZWQnIDogJycpLCBcImRhdGEtdG9vbHRpcFwiOiBndWlkICsgJy1jYW5jZWwnLCBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7IGlmICghKHByb3BzLkRpc2FibGVDYW5jZWwgPT09IHVuZGVmaW5lZCB8fCAhcHJvcHMuRGlzYWJsZUNhbmNlbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgcHJvcHMuQ2FsbEJhY2soZmFsc2UsIHRydWUpOyB9LCBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldEhvdmVyKCdjYW5jZWwnKTsgfSwgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRIb3Zlcignbm9uZScpOyB9IH0sIGN4bkJ0bilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCkpKSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sVGlwXzEuZGVmYXVsdCwgeyBTaG93OiBzaG93Q29uZmlybVRvb2xUaXAsIFBvc2l0aW9uOiAndG9wJywgVGhlbWU6ICdkYXJrJywgVGFyZ2V0OiBndWlkICsgJy1jb25maXJtJywgWmluZGV4OiA5OTk5IH0sIHByb3BzLkNvbmZpcm1Ub29sVGlwQ29udGVudCksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sVGlwXzEuZGVmYXVsdCwgeyBTaG93OiBzaG93Q3huVG9vbFRpcCwgUG9zaXRpb246ICd0b3AnLCBUaGVtZTogJ2RhcmsnLCBUYXJnZXQ6IGd1aWQgKyAnLWNhbmNlbCcsIFppbmRleDogOTk5OSB9LCBwcm9wcy5DYW5jZWxUb29sVGlwQ29udGVudCksXHJcbiAgICAgICAgcHJvcHMuU2hvdyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXHJcbiAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC41LFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDk5ODAsXHJcbiAgICAgICAgICAgIH0gfSkgOiBudWxsKSk7XHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vZGFsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBTZWFyY2hCYXIudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDAxLzA2LzIwMjAgLSBDaHJpc3RvcGggTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciBNb2RhbF8xID0gcmVxdWlyZShcIi4vTW9kYWxcIik7XHJcbnZhciBMb2FkaW5nSWNvbl8xID0gcmVxdWlyZShcIi4vTG9hZGluZ0ljb25cIik7XHJcbnZhciByZWFjdF9mb3Jtc18xID0gcmVxdWlyZShcIkBncGEtZ2Vtc3RvbmUvcmVhY3QtZm9ybXNcIik7XHJcbnZhciBncGFfc3ltYm9sc18xID0gcmVxdWlyZShcIkBncGEtZ2Vtc3RvbmUvZ3BhLXN5bWJvbHNcIik7XHJcbmZ1bmN0aW9uIFNlYXJjaEJhcihwcm9wcykge1xyXG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLCBob3ZlciA9IF9hWzBdLCBzZXRIb3ZlciA9IF9hWzFdO1xyXG4gICAgdmFyIF9iID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLCBzaG93ID0gX2JbMF0sIHNldFNob3cgPSBfYlsxXTtcclxuICAgIHZhciBfYyA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSwgaXNOZXcgPSBfY1swXSwgc2V0SXNOZXcgPSBfY1sxXTtcclxuICAgIHZhciBfZCA9IFJlYWN0LnVzZVN0YXRlKFtdKSwgZmlsdGVycyA9IF9kWzBdLCBzZXRGaWx0ZXJzID0gX2RbMV07XHJcbiAgICB2YXIgX2UgPSBSZWFjdC51c2VTdGF0ZSh7IEZpZWxkTmFtZTogcHJvcHMuQ29sbHVtbkxpc3RbMF0ua2V5LCBTZWFyY2hUZXh0OiAnJywgT3BlcmF0b3I6IHByb3BzLkNvbGx1bW5MaXN0WzBdLnR5cGUgPT09ICdzdHJpbmcnID8gJ0xJS0UnIDogJz0nLCBUeXBlOiBwcm9wcy5Db2xsdW1uTGlzdFswXS50eXBlLCBpc1Bpdm90Q29sdW1uOiBwcm9wcy5Db2xsdW1uTGlzdFswXS5pc1Bpdm90RmllbGQgfSksIGZpbHRlciA9IF9lWzBdLCBzZXRGaWx0ZXIgPSBfZVsxXTtcclxuICAgIHZhciBfZiA9IFJlYWN0LnVzZVN0YXRlKFwiXCIpLCBzZWFyY2ggPSBfZlswXSwgc2V0U2VhcmNoID0gX2ZbMV07XHJcbiAgICB2YXIgX2cgPSBSZWFjdC51c2VTdGF0ZShudWxsKSwgc2VhcmNoRmlsdGVyID0gX2dbMF0sIHNldFNlYXJjaEZpbHRlciA9IF9nWzFdO1xyXG4gICAgLy8gVXBkYXRlIFNlYXJjaEZpbHRlciBpZiB0aGVyZSBhcmUgYW55IENoYXJhY3RlciBhbmQgb25seSBkbyBpdCBldmVyeSA1MDBtcyB0byBhdm9pZCBoYW1tZXJpbmcgdGhlIHNlcnZlciB3aGlsZSB0eXBpbmdcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPiAwICYmIHByb3BzLmRlZmF1bHRDb2xsdW1uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLmRlZmF1bHRDb2xsdW1uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VhcmNoRmlsdGVyKHsgRmllbGROYW1lOiBwcm9wcy5kZWZhdWx0Q29sbHVtbi5rZXksIE9wZXJhdG9yOiAnTElLRScsIFR5cGU6IHByb3BzLmRlZmF1bHRDb2xsdW1uLnR5cGUsIFNlYXJjaFRleHQ6ICgnKicgKyBzZWFyY2ggKyAnKicpLCBpc1Bpdm90Q29sdW1uOiBwcm9wcy5kZWZhdWx0Q29sbHVtbi5pc1Bpdm90RmllbGQgfSk7XHJcbiAgICAgICAgICAgIH0sIDUwMCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNldFNlYXJjaEZpbHRlcihudWxsKTtcclxuICAgICAgICAgICAgfSwgNTAwKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBpZiAoaGFuZGxlICE9PSBudWxsKVxyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTsgfTtcclxuICAgIH0sIFtzZWFyY2hdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHNlYXJjaEZpbHRlciAhPT0gbnVsbClcclxuICAgICAgICAgICAgcHJvcHMuU2V0RmlsdGVyKF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgZmlsdGVycywgdHJ1ZSksIFtzZWFyY2hGaWx0ZXJdLCBmYWxzZSkpO1xyXG4gICAgICAgIGlmIChzZWFyY2hGaWx0ZXIgPT09IG51bGwpXHJcbiAgICAgICAgICAgIHByb3BzLlNldEZpbHRlcihmaWx0ZXJzKTtcclxuICAgIH0sIFtzZWFyY2hGaWx0ZXJdKTtcclxuICAgIGZ1bmN0aW9uIGRlbGV0ZUZpbHRlcihmKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gZmlsdGVycy5maW5kSW5kZXgoZnVuY3Rpb24gKGZzKSB7IHJldHVybiBmcyA9PT0gZjsgfSk7XHJcbiAgICAgICAgdmFyIGZpbHRzID0gX19zcHJlYWRBcnJheShbXSwgZmlsdGVycywgdHJ1ZSk7XHJcbiAgICAgICAgZmlsdHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICBzZXRGaWx0ZXJzKGZpbHRzKTtcclxuICAgICAgICBzZXRIb3ZlcihmYWxzZSk7XHJcbiAgICAgICAgaWYgKHByb3BzLmRlZmF1bHRDb2xsdW1uICE9PSB1bmRlZmluZWQgJiYgc2VhcmNoRmlsdGVyICE9PSBudWxsKVxyXG4gICAgICAgICAgICBwcm9wcy5TZXRGaWx0ZXIoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBmaWx0cywgdHJ1ZSksIFtzZWFyY2hGaWx0ZXJdLCBmYWxzZSkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcHJvcHMuU2V0RmlsdGVyKGZpbHRzKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZEZpbHRlcigpIHtcclxuICAgICAgICB2YXIgb2xkRmlsdGVycyA9IF9fc3ByZWFkQXJyYXkoW10sIGZpbHRlcnMsIHRydWUpO1xyXG4gICAgICAgIHZhciBhZGp1c3RlZEZpbHRlciA9IF9fYXNzaWduKHt9LCBmaWx0ZXIpO1xyXG4gICAgICAgIGlmIChhZGp1c3RlZEZpbHRlci5UeXBlID09PSAnc3RyaW5nJyAmJiAoYWRqdXN0ZWRGaWx0ZXIuT3BlcmF0b3IgPT09ICdMSUtFJyB8fCBhZGp1c3RlZEZpbHRlci5PcGVyYXRvciA9PT0gJ05PVCBMSUtFJykpXHJcbiAgICAgICAgICAgIGFkanVzdGVkRmlsdGVyLlNlYXJjaFRleHQgPSAnKicgKyBhZGp1c3RlZEZpbHRlci5TZWFyY2hUZXh0ICsgJyonO1xyXG4gICAgICAgIG9sZEZpbHRlcnMucHVzaChhZGp1c3RlZEZpbHRlcik7XHJcbiAgICAgICAgc2V0RmlsdGVycyhvbGRGaWx0ZXJzKTtcclxuICAgICAgICBzZXRGaWx0ZXIoeyBGaWVsZE5hbWU6IHByb3BzLkNvbGx1bW5MaXN0WzBdLmtleSwgU2VhcmNoVGV4dDogJycsIE9wZXJhdG9yOiBwcm9wcy5Db2xsdW1uTGlzdFswXS50eXBlID09PSAnc3RyaW5nJyA/ICdMSUtFJyA6ICc9JywgVHlwZTogcHJvcHMuQ29sbHVtbkxpc3RbMF0udHlwZSwgaXNQaXZvdENvbHVtbjogcHJvcHMuQ29sbHVtbkxpc3RbMF0uaXNQaXZvdEZpZWxkIH0pO1xyXG4gICAgICAgIGlmIChwcm9wcy5kZWZhdWx0Q29sbHVtbiAhPT0gdW5kZWZpbmVkICYmIHNlYXJjaEZpbHRlciAhPT0gbnVsbClcclxuICAgICAgICAgICAgcHJvcHMuU2V0RmlsdGVyKF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb2xkRmlsdGVycywgdHJ1ZSksIFtzZWFyY2hGaWx0ZXJdLCBmYWxzZSkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcHJvcHMuU2V0RmlsdGVyKG9sZEZpbHRlcnMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZWRpdEZpbHRlcihpbmRleCkge1xyXG4gICAgICAgIHNldElzTmV3KGZhbHNlKTtcclxuICAgICAgICB2YXIgb2xkRmlsdGVycyA9IF9fc3ByZWFkQXJyYXkoW10sIGZpbHRlcnMsIHRydWUpO1xyXG4gICAgICAgIHZhciBmaWx0ID0gX19hc3NpZ24oe30sIG9sZEZpbHRlcnNbaW5kZXhdKTtcclxuICAgICAgICBvbGRGaWx0ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgaWYgKGZpbHQuVHlwZSA9PT0gJ3N0cmluZycgJiYgKGZpbHQuT3BlcmF0b3IgPT09ICdMSUtFJyB8fCBmaWx0Lk9wZXJhdG9yID09PSAnTk9UIExJS0UnKSlcclxuICAgICAgICAgICAgZmlsdC5TZWFyY2hUZXh0ID0gZmlsdC5TZWFyY2hUZXh0LnN1YnN0cigxLCBmaWx0LlNlYXJjaFRleHQubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgc2V0U2hvdyh0cnVlKTtcclxuICAgICAgICBzZXRGaWx0ZXJzKG9sZEZpbHRlcnMpO1xyXG4gICAgICAgIHNldEZpbHRlcihmaWx0KTtcclxuICAgICAgICBpZiAocHJvcHMuZGVmYXVsdENvbGx1bW4gIT09IHVuZGVmaW5lZCAmJiBzZWFyY2hGaWx0ZXIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHByb3BzLlNldEZpbHRlcihfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG9sZEZpbHRlcnMsIHRydWUpLCBbc2VhcmNoRmlsdGVyXSwgZmFsc2UpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHByb3BzLlNldEZpbHRlcihvbGRGaWx0ZXJzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbHRlcigpIHtcclxuICAgICAgICBzZXRTaG93KCFzaG93KTtcclxuICAgICAgICBzZXRJc05ldyh0cnVlKTtcclxuICAgICAgICBzZXRGaWx0ZXIoeyBGaWVsZE5hbWU6IHByb3BzLkNvbGx1bW5MaXN0WzBdLmtleSwgU2VhcmNoVGV4dDogJycsIE9wZXJhdG9yOiBwcm9wcy5Db2xsdW1uTGlzdFswXS50eXBlID09PSAnc3RyaW5nJyA/ICdMSUtFJyA6ICc9JywgVHlwZTogcHJvcHMuQ29sbHVtbkxpc3RbMF0udHlwZSwgaXNQaXZvdENvbHVtbjogcHJvcHMuQ29sbHVtbkxpc3RbMF0uaXNQaXZvdEZpZWxkIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbnRlbnQgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJvd1wiIH0sXHJcbiAgICAgICAgICAgICAgICBwcm9wcy5kZWZhdWx0Q29sbHVtbiAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNvbFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiaW5wdXQtZ3JvdXBcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgY2xhc3NOYW1lOiBcImZvcm0tY29udHJvbCBtci1zbS0yXCIsIHR5cGU6IFwic2VhcmNoXCIsIHBsYWNlaG9sZGVyOiBcIlNlYXJjaCBcIiArIHByb3BzLmRlZmF1bHRDb2xsdW1uLmxhYmVsLCBvbkNoYW5nZTogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBzZXRTZWFyY2goZXZlbnQudGFyZ2V0LnZhbHVlKTsgfSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLlNob3dMb2FkaW5nICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuU2hvd0xvYWRpbmcgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImlucHV0LWdyb3VwLWFwcGVuZFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChMb2FkaW5nSWNvbl8xLmRlZmF1bHQsIHsgU2hvdzogdHJ1ZSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBcIikgOiBudWxsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgeyBzdHlsZTogeyBtYXJnaW5Ub3A6IDIsIG1hcmdpbkJvdHRvbTogMiB9IH0sIHByb3BzLlJlc3VsdE5vdGUpKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgcG9zaXRpb246ICdyZWxhdGl2ZScsIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snIH0sIGNsYXNzTmFtZTogJ2NvbCcgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBcImJ0biBidG4tXCIgKyAoZmlsdGVycy5sZW5ndGggPiAwID8gXCJ3YXJuaW5nXCIgOiBcInByaW1hcnlcIiksIG9uQ2xpY2s6IGZ1bmN0aW9uIChldnQpIHsgZXZ0LnByZXZlbnREZWZhdWx0KCk7IGNyZWF0ZUZpbHRlcigpOyB9LCBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldEhvdmVyKHRydWUpOyB9LCBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldEhvdmVyKGZhbHNlKTsgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkFkZCBGaWx0ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVycy5sZW5ndGggPiAwID8gKFwiKFwiICsgZmlsdGVycy5sZW5ndGggKyBcIilcIikgOiBcIlwiKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoIC8gMywgZGlzcGxheTogaG92ZXIgPyAnYmxvY2snIDogJ25vbmUnLCBwb3NpdGlvbjogJ2Fic29sdXRlJywgYmFja2dyb3VuZENvbG9yOiAnI2YxZjFmMScsIGJveFNoYWRvdzogJzBweCA4cHggMTZweCAwcHggcmdiYSgwLDAsMCwwLjIpJywgekluZGV4OiAxLCByaWdodDogKHByb3BzLkRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IDAgOiB1bmRlZmluZWQpLCBsZWZ0OiAocHJvcHMuRGlyZWN0aW9uID09PSAnbGVmdCcgPyAwIDogdW5kZWZpbmVkKSB9LCBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldEhvdmVyKHRydWUpOyB9LCBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldEhvdmVyKGZhbHNlKTsgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBjbGFzc05hbWU6ICd0YWJsZScgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aGVhZFwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGhcIiwgbnVsbCwgXCJDb2x1bW5cIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCBudWxsLCBcIk9wZXJhdG9yXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGhcIiwgbnVsbCwgXCJTZWFyY2ggVGV4dFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRoXCIsIG51bGwsIFwiRWRpdFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRoXCIsIG51bGwsIFwiUmVtb3ZlXCIpKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgbnVsbCwgZmlsdGVycy5tYXAoZnVuY3Rpb24gKGYsIGkpIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogaSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLCBmLkZpZWxkTmFtZSA9PT0gcHJvcHMuQ29sbHVtbkxpc3RbMF0ua2V5ID8gcHJvcHMuQ29sbHVtbkxpc3RbMF0ubGFiZWwgOiBmLkZpZWxkTmFtZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwsIGYuT3BlcmF0b3IpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLCBmLlNlYXJjaFRleHQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogJ2J1dHRvbicsIGNsYXNzTmFtZTogXCJidG4gYnRuLXNtXCIsIG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlZGl0RmlsdGVyKGkpOyB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBncGFfc3ltYm9sc18xLlBlbmNpbCkpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6ICdidXR0b24nLCBjbGFzc05hbWU6IFwiYnRuIGJ0bi1zbVwiLCBvbkNsaWNrOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZGVsZXRlRmlsdGVyKGYpOyB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBncGFfc3ltYm9sc18xLlRyYXNoQ2FuKSkpKTsgfSkpKSkpKSkpKTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IHdpZHRoOiAnMTAwJScgfSB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJuYXZcIiwgeyBjbGFzc05hbWU6IFwibmF2YmFyIG5hdmJhci1leHBhbmQtbGcgbmF2YmFyLWxpZ2h0IGJnLWxpZ2h0XCIgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjb2xsYXBzZSBuYXZiYXItY29sbGFwc2VcIiwgc3R5bGU6IHsgd2lkdGg6ICcxMDAlJyB9IH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgeyBjbGFzc05hbWU6IFwibmF2YmFyLW5hdiBtci1hdXRvXCIsIHN0eWxlOiB7IHdpZHRoOiAnMTAwJScgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLkRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IHByb3BzLmNoaWxkcmVuIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5MYWJlbCAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIHsgY2xhc3NOYW1lOiBcIm5hdi1pdGVtXCIsIHN0eWxlOiB7IG1pbldpZHRoOiAocHJvcHMuV2lkdGggPT09IHVuZGVmaW5lZCA/ICcxNTBweCcgOiB1bmRlZmluZWQpLCB3aWR0aDogcHJvcHMuV2lkdGgsIHBhZGRpbmdSaWdodDogMTAgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIsIHsgY2xhc3NOYW1lOiBcImJvcmRlclwiLCBzdHlsZTogeyBwYWRkaW5nOiAnMTBweCcsIGhlaWdodDogJzEwMCUnIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGVnZW5kXCIsIHsgY2xhc3NOYW1lOiBcInctYXV0b1wiLCBzdHlsZTogeyBmb250U2l6ZTogJ2xhcmdlJyB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLkxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjpcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCkpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIHsgY2xhc3NOYW1lOiBcIm5hdi1pdGVtXCIsIHN0eWxlOiB7IG1pbldpZHRoOiAocHJvcHMuV2lkdGggPT09IHVuZGVmaW5lZCA/ICcxNTBweCcgOiB1bmRlZmluZWQpLCB3aWR0aDogcHJvcHMuV2lkdGgsIHBhZGRpbmdSaWdodDogMTAgfSB9LCBjb250ZW50KSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5EaXJlY3Rpb24gPT09ICdsZWZ0JyA/IHByb3BzLmNoaWxkcmVuIDogbnVsbCkpKSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1vZGFsXzEuZGVmYXVsdCwgeyBUaXRsZTogJ0FkZCBGaWx0ZXInLCBTaG93OiBzaG93LCBDYWxsQmFjazogZnVuY3Rpb24gKGNvbmYpIHsgaWYgKGNvbmYpXHJcbiAgICAgICAgICAgICAgICBhZGRGaWx0ZXIoKTsgc2V0U2hvdyhmYWxzZSk7IH0sIENvbmZpcm1UZXh0OiBpc05ldyA/ICdBZGQnIDogJ1NhdmUnLCBDYW5jZWxUZXh0OiBpc05ldyA/ICdDbG9zZScgOiAnRGVsZXRlJyB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0X2Zvcm1zXzEuU2VsZWN0LCB7IFJlY29yZDogZmlsdGVyLCBGaWVsZDogJ0ZpZWxkTmFtZScsIE9wdGlvbnM6IHByb3BzLkNvbGx1bW5MaXN0Lm1hcChmdW5jdGlvbiAoZmwpIHsgcmV0dXJuICh7IFZhbHVlOiBmbC5rZXksIExhYmVsOiBmbC5sYWJlbCB9KTsgfSksIFNldHRlcjogZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IFwiSU5cIjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gcHJvcHMuQ29sbHVtbkxpc3QuZmluZChmdW5jdGlvbiAoZmwpIHsgcmV0dXJuIGZsLmtleSA9PT0gcmVjb3JkLkZpZWxkTmFtZTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbiAhPT0gdW5kZWZpbmVkICYmIGNvbHVtbi50eXBlID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBcIkxJS0VcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uICE9PSB1bmRlZmluZWQgJiYgKGNvbHVtbi50eXBlID09PSAnbnVtYmVyJyB8fCBjb2x1bW4udHlwZSA9PT0gJ2ludGVnZXInIHx8IGNvbHVtbi50eXBlID09PSAnYm9vbGVhbicgfHwgY29sdW1uLnR5cGUgPT09ICdkYXRldGltZScpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9ICc9JztcclxuICAgICAgICAgICAgICAgICAgICBzZXRGaWx0ZXIoZnVuY3Rpb24gKHByZXZGaWx0ZXIpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldkZpbHRlciksIHsgRmllbGROYW1lOiByZWNvcmQuRmllbGROYW1lLCBTZWFyY2hUZXh0OiAnJywgT3BlcmF0b3I6IG9wZXJhdG9yLCBUeXBlOiAoY29sdW1uICE9PSB1bmRlZmluZWQgPyBjb2x1bW4udHlwZSA6ICdzdHJpbmcnKSwgaXNQaXZvdENvbHVtbjogKGNvbHVtbiAhPT0gdW5kZWZpbmVkID8gY29sdW1uLmlzUGl2b3RGaWVsZCA6IHRydWUpIH0pKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LCBMYWJlbDogJ0NvbHVtbicgfSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmlsdGVyQ3JlYXRvciwgeyBGaWx0ZXI6IGZpbHRlciwgRmllbGQ6IHByb3BzLkNvbGx1bW5MaXN0LmZpbmQoZnVuY3Rpb24gKGZsKSB7IHJldHVybiBmbC5rZXkgPT09IGZpbHRlci5GaWVsZE5hbWU7IH0pLCBTZXR0ZXI6IGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIHNldEZpbHRlcihyZWNvcmQpOyB9LCBFbnVtOiAocHJvcHMuR2V0RW51bSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcHJvcHMuR2V0RW51bSkgfSkpKSk7XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gU2VhcmNoQmFyO1xyXG5mdW5jdGlvbiBGaWx0ZXJDcmVhdG9yKHByb3BzKSB7XHJcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZShbXSksIG9wdGlvbnMgPSBfYVswXSwgc2V0T3B0aW9ucyA9IF9hWzFdO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocHJvcHMuRmllbGQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChwcm9wcy5GaWVsZC5lbnVtICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHNldE9wdGlvbnMocHJvcHMuRmllbGQuZW51bSk7XHJcbiAgICAgICAgaWYgKHByb3BzLkVudW0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzLkVudW0oc2V0T3B0aW9ucywgcHJvcHMuRmllbGQpO1xyXG4gICAgICAgIGlmIChwcm9wcy5GaWVsZC5lbnVtID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHNldE9wdGlvbnMoW10pO1xyXG4gICAgfSwgW3Byb3BzLkZpZWxkLCBwcm9wcy5FbnVtXSk7XHJcbiAgICBpZiAocHJvcHMuRmllbGQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGlmIChwcm9wcy5GaWVsZC50eXBlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgbnVsbCwgXCJDb2x1bW4gdHlwZSBpcyBzdHJpbmcuIFdpbGRjYXJkICgqKSBjYW4gYmUgdXNlZCB3aXRoICdMSUtFJyBhbmQgJ05PVCBMSUtFJ1wiKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ3JvdycgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdjb2wtNCcgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHsgY2xhc3NOYW1lOiAnZm9ybS1jb250cm9sJywgdmFsdWU6IHByb3BzLkZpbHRlci5PcGVyYXRvciwgb25DaGFuZ2U6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV2dC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5TZXR0ZXIoZnVuY3Rpb24gKHByZXZTdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2U3RhdGUpLCB7IE9wZXJhdG9yOiB2YWx1ZSB9KSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwgeyB2YWx1ZTogJ0xJS0UnIH0sIFwiTElLRVwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnPScgfSwgXCI9XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsgdmFsdWU6ICdOT1QgTElLRScgfSwgXCJOT1QgTElLRVwiKSkpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2NvbCcgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgeyBjbGFzc05hbWU6ICdmb3JtLWNvbnRyb2wnLCB2YWx1ZTogcHJvcHMuRmlsdGVyLlNlYXJjaFRleHQucmVwbGFjZSgnJF8nLCAnXycpLCBvbkNoYW5nZTogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZXZ0LnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLlNldHRlcihmdW5jdGlvbiAocHJldlN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZTdGF0ZSksIHsgU2VhcmNoVGV4dDogdmFsdWUucmVwbGFjZSgnXycsICckXycpIH0pKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMuRmllbGQudHlwZSA9PT0gXCJpbnRlZ2VyXCIgfHwgcHJvcHMuRmllbGQudHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBcIkNvbHVtbiB0eXBlIGlzIFwiLFxyXG4gICAgICAgICAgICAgICAgcHJvcHMuRmllbGQudHlwZSxcclxuICAgICAgICAgICAgICAgIFwiLlwiKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ3JvdycgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdjb2wtNCcgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHsgY2xhc3NOYW1lOiAnZm9ybS1jb250cm9sJywgdmFsdWU6IHByb3BzLkZpbHRlci5PcGVyYXRvciwgb25DaGFuZ2U6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV2dC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5TZXR0ZXIoZnVuY3Rpb24gKHByZXZTdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2U3RhdGUpLCB7IE9wZXJhdG9yOiB2YWx1ZSB9KSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwgeyB2YWx1ZTogJz0nIH0sIFwiPVwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnPD4nIH0sIFwiPD5cIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwgeyB2YWx1ZTogJz4nIH0sIFwiPlwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnPj0nIH0sIFwiPj1cIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwgeyB2YWx1ZTogJzwnIH0sIFwiPFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnPj0nIH0sIFwiPj1cIikpKSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdjb2wnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgdHlwZTogJ251bWJlcicsIGNsYXNzTmFtZTogJ2Zvcm0tY29udHJvbCcsIHZhbHVlOiBwcm9wcy5GaWx0ZXIuU2VhcmNoVGV4dCwgb25DaGFuZ2U6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV2dC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5TZXR0ZXIoZnVuY3Rpb24gKHByZXZTdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2U3RhdGUpLCB7IFNlYXJjaFRleHQ6IHZhbHVlIH0pKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMuRmllbGQudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFwiQ29sdW1uIHR5cGUgaXMgXCIsXHJcbiAgICAgICAgICAgICAgICBwcm9wcy5GaWVsZC50eXBlLFxyXG4gICAgICAgICAgICAgICAgXCIuXCIpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAncm93JyB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2NvbC00JyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiwgeyBjbGFzc05hbWU6ICdmb3JtLWNvbnRyb2wnLCB2YWx1ZTogcHJvcHMuRmlsdGVyLk9wZXJhdG9yLCBvbkNoYW5nZTogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZXZ0LnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLlNldHRlcihmdW5jdGlvbiAocHJldlN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZTdGF0ZSksIHsgT3BlcmF0b3I6IHZhbHVlIH0pKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnPScgfSwgXCI9XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsgdmFsdWU6ICc8PicgfSwgXCI8PlwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnPicgfSwgXCI+XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsgdmFsdWU6ICc+PScgfSwgXCI+PVwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHZhbHVlOiAnPCcgfSwgXCI8XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsgdmFsdWU6ICc+PScgfSwgXCI+PVwiKSkpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2NvbCcgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgeyB0eXBlOiAnZGF0ZScsIGNsYXNzTmFtZTogJ2Zvcm0tY29udHJvbCcsIHZhbHVlOiBwcm9wcy5GaWx0ZXIuU2VhcmNoVGV4dC5zcGxpdCgnICcpWzBdLCBvbkNoYW5nZTogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZXZ0LnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLlNldHRlcihmdW5jdGlvbiAocHJldlN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZTdGF0ZSksIHsgU2VhcmNoVGV4dDogKHZhbHVlICsgJyAnICsgKHByZXZTdGF0ZS5TZWFyY2hUZXh0LnNwbGl0KCcgJykubGVuZ3RoID4gMSA/IHByZXZTdGF0ZS5TZWFyY2hUZXh0LnNwbGl0KCcgJylbMV0gOiAnMDowMCcpKSB9KSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IHR5cGU6ICd0aW1lJywgY2xhc3NOYW1lOiAnZm9ybS1jb250cm9sJywgdmFsdWU6IHByb3BzLkZpbHRlci5TZWFyY2hUZXh0LnNwbGl0KCcgJykubGVuZ3RoID4gMSA/IHByb3BzLkZpbHRlci5TZWFyY2hUZXh0LnNwbGl0KCcgJylbMV0gOiAnMDowMCcsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBldnQudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuU2V0dGVyKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldlN0YXRlKSwgeyBTZWFyY2hUZXh0OiAocHJldlN0YXRlLlNlYXJjaFRleHQuc3BsaXQoJyAnKVswXSArICcgJyArIHZhbHVlKSB9KSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0pKSkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb3BzLkZpZWxkLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZm9ybS1jaGVja1wiIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IHR5cGU6IFwiY2hlY2tib3hcIiwgY2xhc3NOYW1lOiBcImZvcm0tY2hlY2staW5wdXRcIiwgc3R5bGU6IHsgekluZGV4OiAxIH0sIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuU2V0dGVyKGZ1bmN0aW9uIChwcmV2RmlsdGVyKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZGaWx0ZXIpLCB7IE9wZXJhdG9yOiAnPScsIFNlYXJjaFRleHQ6IGV2dC50YXJnZXQuY2hlY2tlZCA/IFwiMVwiIDogXCIwXCIgfSkpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sIHZhbHVlOiBwcm9wcy5GaWx0ZXIuU2VhcmNoVGV4dCA9PT0gXCIxXCIgPyAnb24nIDogJ29mZicsIGNoZWNrZWQ6IHByb3BzLkZpbHRlci5TZWFyY2hUZXh0ID09PSBcIjFcIiA/IHRydWUgOiBmYWxzZSB9KSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHsgY2xhc3NOYW1lOiBcImZvcm0tY2hlY2stbGFiZWxcIiB9LCBcIkNvbHVtbiB0eXBlIGlzIGJvb2xlYW4uIFllcy9PbiBpcyBjaGVja2VkLlwiKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLCBudWxsLCBcIkNvbHVtbiB0eXBlIGlzIGVudW1lcmFibGUuIFNlbGVjdCBmcm9tIGJlbG93LlwiKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgc3R5bGU6IHsgbGlzdFN0eWxlOiAnbm9uZScgfSB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmb3JtLWNoZWNrXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgdHlwZTogXCJjaGVja2JveFwiLCBjbGFzc05hbWU6IFwiZm9ybS1jaGVjay1pbnB1dFwiLCBzdHlsZTogeyB6SW5kZXg6IDEgfSwgb25DaGFuZ2U6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0LnRhcmdldC5jaGVja2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5TZXR0ZXIoZnVuY3Rpb24gKHByZXZTZXR0ZXIpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldlNldHRlciksIHsgU2VhcmNoVGV4dDogXCIoXCIgKyBvcHRpb25zLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5WYWx1ZTsgfSkuam9pbignLCcpICsgXCIpXCIgfSkpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLlNldHRlcihmdW5jdGlvbiAocHJldlNldHRlcikgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2U2V0dGVyKSwgeyBTZWFyY2hUZXh0OiAnJyB9KSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGVmYXVsdFZhbHVlOiAnb2ZmJyB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHsgY2xhc3NOYW1lOiBcImZvcm0tY2hlY2stbGFiZWxcIiB9LCBcIlNlbGVjdCBBbGxcIikpKSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubWFwKGZ1bmN0aW9uICh2bGksIGluZGV4KSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwgeyBrZXk6IGluZGV4IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmb3JtLWNoZWNrXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgdHlwZTogXCJjaGVja2JveFwiLCBjbGFzc05hbWU6IFwiZm9ybS1jaGVjay1pbnB1dFwiLCBzdHlsZTogeyB6SW5kZXg6IDEgfSwgb25DaGFuZ2U6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0LnRhcmdldC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gcHJvcHMuRmlsdGVyLlNlYXJjaFRleHQucmVwbGFjZSgnKCcsICcnKS5yZXBsYWNlKCcpJywgJycpLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gXCJcIjsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaCh2bGkuVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dF8xID0gXCIoXCIgKyBsaXN0LmpvaW4oJywnKSArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5TZXR0ZXIoZnVuY3Rpb24gKHByZXZTZXR0ZXIpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldlNldHRlciksIHsgU2VhcmNoVGV4dDogdGV4dF8xIH0pKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHByb3BzLkZpbHRlci5TZWFyY2hUZXh0LnJlcGxhY2UoJygnLCAnJykucmVwbGFjZSgnKScsICcnKS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IFwiXCI7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IHZsaS5WYWx1ZTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0XzIgPSBcIihcIiArIGxpc3Quam9pbignLCcpICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLlNldHRlcihmdW5jdGlvbiAocHJldlNldHRlcikgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2U2V0dGVyKSwgeyBTZWFyY2hUZXh0OiB0ZXh0XzIgfSkpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB2YWx1ZTogcHJvcHMuRmlsdGVyLlNlYXJjaFRleHQuaW5kZXhPZih2bGkuVmFsdWUpID49IDAgPyAnb24nIDogJ29mZicsIGNoZWNrZWQ6IHByb3BzLkZpbHRlci5TZWFyY2hUZXh0LmluZGV4T2YodmxpLlZhbHVlKSA+PSAwID8gdHJ1ZSA6IGZhbHNlIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgeyBjbGFzc05hbWU6IFwiZm9ybS1jaGVjay1sYWJlbFwiIH0sIHZsaS5MYWJlbCkpKTsgfSkpKSk7XHJcbiAgICB9XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgU2VydmVyRXJyb3JJY29uLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIxLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwNi8xOS8yMDIxIC0gQ2hyaXN0b3BoIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxuZnVuY3Rpb24gU2VydmVyRXJyb3JJY29uKHByb3BzKSB7XHJcbiAgICB2YXIgaCA9IChwcm9wcy5TaXplID09PSB1bmRlZmluZWQgPyAyNSA6IHByb3BzLlNpemUpO1xyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgd2lkdGg6IChwcm9wcy5MYWJlbCA9PT0gdW5kZWZpbmVkID8gaCA6IHVuZGVmaW5lZCksIG1hcmdpbjogJ2F1dG8nIH0sIGhpZGRlbjogIXByb3BzLlNob3cgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHN0eWxlOiB7IGZpbGw6ICdkYXJrcmVkJywgaGVpZ2h0OiBoIH0sIHZpZXdCb3g6ICcwIDAgMjAgMjAnIH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTEwLjE4NSwxLjQxN2MtNC43NDEsMC04LjU4MywzLjg0Mi04LjU4Myw4LjU4M2MwLDQuNzQsMy44NDIsOC41ODIsOC41ODMsOC41ODJTMTguNzY4LDE0Ljc0LDE4Ljc2OCwxMEMxOC43NjgsNS4yNTksMTQuOTI2LDEuNDE3LDEwLjE4NSwxLjQxNyBNMTAuMTg1LDE3LjY4Yy00LjIzNSwwLTcuNjc5LTMuNDQ1LTcuNjc5LTcuNjhjMC00LjIzNSwzLjQ0NC03LjY3OSw3LjY3OS03LjY3OVMxNy44NjQsNS43NjUsMTcuODY0LDEwQzE3Ljg2NCwxNC4yMzQsMTQuNDIsMTcuNjgsMTAuMTg1LDE3LjY4IE0xMC44MjQsMTBsMi44NDItMi44NDRjMC4xNzgtMC4xNzYsMC4xNzgtMC40NiwwLTAuNjM3Yy0wLjE3Ny0wLjE3OC0wLjQ2MS0wLjE3OC0wLjYzNywwbC0yLjg0NCwyLjg0MUw3LjM0MSw2LjUyYy0wLjE3Ni0wLjE3OC0wLjQ2LTAuMTc4LTAuNjM3LDBjLTAuMTc4LDAuMTc2LTAuMTc4LDAuNDYxLDAsMC42MzdMOS41NDYsMTBsLTIuODQxLDIuODQ0Yy0wLjE3OCwwLjE3Ni0wLjE3OCwwLjQ2MSwwLDAuNjM3YzAuMTc4LDAuMTc4LDAuNDU5LDAuMTc4LDAuNjM3LDBsMi44NDQtMi44NDFsMi44NDQsMi44NDFjMC4xNzgsMC4xNzgsMC40NTksMC4xNzgsMC42MzcsMGMwLjE3OC0wLjE3NiwwLjE3OC0wLjQ2MSwwLTAuNjM3TDEwLjgyNCwxMHpcIiB9KSksXHJcbiAgICAgICAgICAgIHByb3BzLkxhYmVsICE9PSB1bmRlZmluZWQgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBwcm9wcy5MYWJlbCkgOiBudWxsKSk7XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gU2VydmVyRXJyb3JJY29uO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBUYWJTZWxlY3Rvci50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDUvMjAvMjAyMSAtIENocmlzdG9waCBMYWNrbmVyXHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciBoZWxwZXJfZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiQGdwYS1nZW1zdG9uZS9oZWxwZXItZnVuY3Rpb25zXCIpO1xyXG52YXIgVGFiU2VsZWN0b3IgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgIHZhciBfYSA9IFJlYWN0LnVzZVN0YXRlKDEpLCBuVmlzaWJsZSA9IF9hWzBdLCBzZXROVmlzaWJsZSA9IF9hWzFdO1xyXG4gICAgdmFyIF9iID0gUmVhY3QudXNlU3RhdGUoMTAwKSwgd2lkdGggPSBfYlswXSwgc2V0V2lkdGggPSBfYlsxXTtcclxuICAgIHZhciBfYyA9IFJlYWN0LnVzZVN0YXRlKCgwLCBoZWxwZXJfZnVuY3Rpb25zXzEuQ3JlYXRlR3VpZCkoKSksIGd1aWQgPSBfY1swXSwgc2V0R3VpZCA9IF9jWzFdO1xyXG4gICAgdmFyIF9kID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLCBkcm9wRG93bk9wZW4gPSBfZFswXSwgc2V0RHJvcERvd25PcGVuID0gX2RbMV07XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldERyb3BEb3duT3BlbihmYWxzZSk7XHJcbiAgICB9LCBbcHJvcHMuQ3VycmVudFRhYl0pO1xyXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ3VpZCk7XHJcbiAgICAgICAgdmFyIHcgPSAxMDA7XHJcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB3ID0gKDAsIGhlbHBlcl9mdW5jdGlvbnNfMS5HZXROb2RlU2l6ZSkodGFyZ2V0KS53aWR0aDtcclxuICAgICAgICBpZiAodyAhPT0gd2lkdGgpXHJcbiAgICAgICAgICAgIHNldFdpZHRoKHcpO1xyXG4gICAgfSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBXdGV4dCA9IDQwO1xyXG4gICAgICAgIHZhciBOdGV4dCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKE50ZXh0IDwgcHJvcHMuVGFicy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHcgPSAyICogMTcgKyAoMCwgaGVscGVyX2Z1bmN0aW9uc18xLkdldFRleHRXaWR0aCkoXCJTZWdvZSBVSVwiLCAnMTRweCcsIHByb3BzLlRhYnNbTnRleHRdLkxhYmVsKSArIDE7XHJcbiAgICAgICAgICAgIGlmIChXdGV4dCArIHcgPiAod2lkdGggLSAyKSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBXdGV4dCA9IFd0ZXh0ICsgdztcclxuICAgICAgICAgICAgTnRleHQgPSBOdGV4dCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldE5WaXNpYmxlKE50ZXh0KTtcclxuICAgIH0sIFt3aWR0aCwgcHJvcHMuVGFic10pO1xyXG4gICAgdmFyIHNob3dFeHAgPSBuVmlzaWJsZSA8IHByb3BzLlRhYnMubGVuZ3RoO1xyXG4gICAgaWYgKHdpZHRoIDwgNTApXHJcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogeyB3aWR0aDogJzEwMCUnIH0sIGlkOiBndWlkIH0sIFwiIFwiKTtcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgd2lkdGg6ICcxMDAlJyB9LCBpZDogZ3VpZCB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7IGNsYXNzTmFtZTogXCJuYXYgbmF2LXRhYnNcIiwgc3R5bGU6IHsgbWF4SGVpZ2h0OiAzOCB9IH0sXHJcbiAgICAgICAgICAgIHByb3BzLlRhYnMubWFwKGZ1bmN0aW9uICh0LCBpKSB7IHJldHVybiBpID4gKG5WaXNpYmxlIC0gMSkgPyBudWxsIDpcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7IGNsYXNzTmFtZTogXCJuYXYtaXRlbVwiLCBrZXk6IGkgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IGNsYXNzTmFtZTogXCJuYXYtbGlua1wiICsgKHByb3BzLkN1cnJlbnRUYWIgPT09IHQuSWQgPyBcIiBhY3RpdmVcIiA6IFwiXCIpLCBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wcy5TZXRUYWIodC5JZCk7IH0gfSwgdC5MYWJlbCkpOyB9KSxcclxuICAgICAgICAgICAgc2hvd0V4cCA/XHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwgeyBjbGFzc05hbWU6IFwibmF2LWl0ZW0gZHJvcGRvd25cIiArIChkcm9wRG93bk9wZW4gPyAnIHNob3cnIDogJycpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgeyBjbGFzc05hbWU6IFwibmF2LWxpbmsgZHJvcGRvd24tdG9nZ2xlXCIsIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldERyb3BEb3duT3BlbihmdW5jdGlvbiAocykgeyByZXR1cm4gIXM7IH0pOyB9IH0sIFwiLi4uXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZHJvcGRvd24tbWVudSBkcm9wZG93bi1tZW51LXJpZ2h0XCIgKyAoZHJvcERvd25PcGVuID8gJyBzaG93JyA6ICcnKSB9LCBwcm9wcy5UYWJzLm1hcChmdW5jdGlvbiAodCwgaSkgeyByZXR1cm4gaSA+IChuVmlzaWJsZSAtIDEpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgeyBjbGFzc05hbWU6IFwiZHJvcGRvd24taXRlbVwiICsgcHJvcHMuQ3VycmVudFRhYiA9PT0gdC5JZCA/ICcgYWN0aXZlJyA6ICcnLCBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wcy5TZXRUYWIodC5JZCk7IH0sIGtleTogaSB9LCB0LkxhYmVsKSA6IG51bGw7IH0pKSkgOiBudWxsKSk7XHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRhYlNlbGVjdG9yO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBUb29sVGlwLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIwLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwMS8xNC8yMDIxIC0gQ2hyaXN0b3BoIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIHN0eWxlZF9jb21wb25lbnRzXzEgPSByZXF1aXJlKFwic3R5bGVkLWNvbXBvbmVudHNcIik7XHJcbnZhciBoZWxwZXJfZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiQGdwYS1nZW1zdG9uZS9oZWxwZXItZnVuY3Rpb25zXCIpO1xyXG52YXIgV3JhcHBlckRpdiA9IHN0eWxlZF9jb21wb25lbnRzXzEuZGVmYXVsdC5kaXYodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgJiB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIHBhZGRpbmc6IDhweCAyMXB4O1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZS1vdXQ7XFxuICAgIHotaW5kZXg6IFwiLCBcIjtcXG4gICAgb3BhY2l0eTogXCIsIFwiO1xcbiAgICBjb2xvcjogXCIsIFwiO1xcbiAgICBiYWNrZ3JvdW5kOiBcIiwgXCI7XFxuICAgIHRvcDogXCIsIFwiO1xcbiAgICBsZWZ0OiBcIiwgXCI7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgfVxcbiAgXCIsIFwiXFxuICBcIiwgXCJcXG4gIFwiLCBcIlxcbiAgXCIsIFwiXCJdLCBbXCJcXG4gICYge1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcbiAgICBwYWRkaW5nOiA4cHggMjFweDtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIGVhc2Utb3V0O1xcbiAgICB6LWluZGV4OiBcIiwgXCI7XFxuICAgIG9wYWNpdHk6IFwiLCBcIjtcXG4gICAgY29sb3I6IFwiLCBcIjtcXG4gICAgYmFja2dyb3VuZDogXCIsIFwiO1xcbiAgICB0b3A6IFwiLCBcIjtcXG4gICAgbGVmdDogXCIsIFwiO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIH1cXG4gIFwiLCBcIlxcbiAgXCIsIFwiXFxuICBcIiwgXCJcXG4gIFwiLCBcIlwiXHJcbiAgICAvLyBUaGUgb3RoZXIgZWxlbWVudCBuZWVkcyB0byBiZSBsYWJlbGQgYXMgZGF0YS10b29sdGlwIHRoYXQgd2lsbCBvbmx5IGJlIHVzZWQgZm9yIHBvc2l0aW9uaW5nXHJcbl0pKSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBwcm9wcy5aaW5kZXg7IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gcHJvcHMuU2hvdyA/IFwiMC45XCIgOiBcIjBcIjsgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAocHJvcHMuVGhlbWUgPT09ICdkYXJrJyA/IFwiI2ZmZlwiIDogJyMyMjInKTsgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAocHJvcHMuVGhlbWUgPT09ICdkYXJrJyA/IFwiIzIyMlwiIDogJyNmZmYnKTsgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBwcm9wcy5Ub3AgKyBcInB4XCI7IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gcHJvcHMuTGVmdCArIFwicHhcIjsgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAocHJvcHMuTG9jYXRpb24gPT09ICd0b3AnID8gXCJcXG4gICAgJjo6YWZ0ZXIge1xcbiAgICAgYm9yZGVyLWxlZnQ6IDhweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gICAgIGJvcmRlci1yaWdodDogOHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgICAgYm9yZGVyLXRvcDogOHB4IHNvbGlkIFwiICsgKHByb3BzLlRoZW1lID09PSAnZGFyaycgPyBcIiMyMjJcIiA6ICcjZmZmJykgKyBcIjtcXG4gICAgIGxlZnQ6IDUwJTtcXG4gICAgIGJvdHRvbTogLTZweDtcXG4gICAgIG1hcmdpbi1sZWZ0OiAtOHB4O1xcbiAgICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgICB3aWR0aDogMHB4O1xcbiAgICAgaGVpZ2h0OiAwcHg7XFxuICAgICBwb3NpdGlvbjogYWJzb2x1dGVcXG4gICAgfVxcbiAgXCIgOiAnJyk7IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKHByb3BzLkxvY2F0aW9uID09PSAnYm90dG9tJyA/IFwiXFxuICAgICY6OmJlZm9yZSB7XFxuICAgICBib3JkZXItbGVmdDogOHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgICAgYm9yZGVyLXJpZ2h0OiA4cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgICBib3JkZXItYm90dG9tOiA4cHggc29saWQgXCIgKyAocHJvcHMuVGhlbWUgPT09ICdkYXJrJyA/IFwiIzIyMlwiIDogJyNmZmYnKSArIFwiO1xcbiAgICAgbGVmdDogNTAlO1xcbiAgICAgdG9wOiAtNnB4O1xcbiAgICAgbWFyZ2luLWxlZnQ6IC04cHg7XFxuICAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgIHdpZHRoOiAwcHg7XFxuICAgICBoZWlnaHQ6IDBweDtcXG4gICAgIHBvc2l0aW9uOiBhYnNvbHV0ZVxcbiAgICB9XFxuICBcIiA6ICcnKTsgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAocHJvcHMuTG9jYXRpb24gPT09ICdsZWZ0JyA/IFwiXFxuICAgICY6OmJlZm9yZSB7XFxuICAgICBib3JkZXItdG9wOiA4cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgICBib3JkZXItYm90dG9tOiA4cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgICBib3JkZXItbGVmdDogOHB4IHNvbGlkIFwiICsgKHByb3BzLlRoZW1lID09PSAnZGFyaycgPyBcIiMyMjJcIiA6ICcjZmZmJykgKyBcIjtcXG4gICAgIHRvcDogNTAlO1xcbiAgICAgbGVmdDogMTAwJTtcXG4gICAgIG1hcmdpbi10b3A6IC04cHg7XFxuICAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgIHdpZHRoOiAwcHg7XFxuICAgICBoZWlnaHQ6IDBweDtcXG4gICAgIHBvc2l0aW9uOiBhYnNvbHV0ZVxcbiAgICB9XFxuICBcIiA6ICcnKTsgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAocHJvcHMuTG9jYXRpb24gPT09ICdyaWdodCcgPyBcIlxcbiAgICAmOjpiZWZvcmUge1xcbiAgICAgYm9yZGVyLXRvcDogOHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgICAgYm9yZGVyLWJvdHRvbTogOHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgICAgYm9yZGVyLXJpZ2h0OiA4cHggc29saWQgXCIgKyAocHJvcHMuVGhlbWUgPT09ICdkYXJrJyA/IFwiIzIyMlwiIDogJyNmZmYnKSArIFwiO1xcbiAgICAgdG9wOiA1MCU7XFxuICAgICBsZWZ0OiAtNnB4O1xcbiAgICAgbWFyZ2luLXRvcDogLThweDtcXG4gICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgd2lkdGg6IDBweDtcXG4gICAgIGhlaWdodDogMHB4O1xcbiAgICAgcG9zaXRpb246IGFic29sdXRlXFxuICAgIH1cXG4gIFwiIDogJycpOyB9KTtcclxuLy8gVGhlIG90aGVyIGVsZW1lbnQgbmVlZHMgdG8gYmUgbGFiZWxkIGFzIGRhdGEtdG9vbHRpcCB0aGF0IHdpbGwgb25seSBiZSB1c2VkIGZvciBwb3NpdGlvbmluZ1xyXG52YXIgVG9vbFRpcCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoMCksIHRvcCA9IF9hWzBdLCBzZXRUb3AgPSBfYVsxXTtcclxuICAgIHZhciBfYiA9IFJlYWN0LnVzZVN0YXRlKDApLCBsZWZ0ID0gX2JbMF0sIHNldExlZnQgPSBfYlsxXTtcclxuICAgIHZhciBfYyA9IFJlYWN0LnVzZVN0YXRlKFwiXCIpLCBndWlkID0gX2NbMF0sIHNldEd1aWQgPSBfY1sxXTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0R3VpZCgoMCwgaGVscGVyX2Z1bmN0aW9uc18xLkNyZWF0ZUd1aWQpKCkpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSBVcGRhdGVQb3NpdGlvbigpLCB0ID0gX2FbMF0sIGwgPSBfYVsxXTtcclxuICAgICAgICBpZiAodCAhPT0gdG9wKVxyXG4gICAgICAgICAgICBzZXRUb3AodCk7XHJcbiAgICAgICAgaWYgKGwgIT09IGxlZnQpXHJcbiAgICAgICAgICAgIHNldExlZnQobCk7XHJcbiAgICB9KTtcclxuICAgIHZhciB6SW5kZXggPSAocHJvcHMuWmluZGV4ID09PSB1bmRlZmluZWQgPyAyMDAwIDogcHJvcHMuWmluZGV4KTtcclxuICAgIGZ1bmN0aW9uIFVwZGF0ZVBvc2l0aW9uKCkge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtdG9vbHRpcFwiICsgKHByb3BzLlRhcmdldCA9PT0gdW5kZWZpbmVkID8gJycgOiBcIj1cXFwiXCIgKyBwcm9wcy5UYXJnZXQgKyBcIlxcXCJcIikgKyBcIl1cIik7XHJcbiAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBbLTk5OSwgLTk5OV07XHJcbiAgICAgICAgdmFyIHRhcmdldExvY2F0aW9uID0gKDAsIGhlbHBlcl9mdW5jdGlvbnNfMS5HZXROb2RlU2l6ZSkodGFyZ2V0WzBdKTtcclxuICAgICAgICB2YXIgdG9vbFRpcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGd1aWQpO1xyXG4gICAgICAgIGlmICh0b29sVGlwID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gWy05OTksIC05OTldO1xyXG4gICAgICAgIHZhciB0aXBMb2NhdGlvbiA9ICgwLCBoZWxwZXJfZnVuY3Rpb25zXzEuR2V0Tm9kZVNpemUpKHRvb2xUaXApO1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSA1O1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbMCwgMF07XHJcbiAgICAgICAgaWYgKHByb3BzLlBvc2l0aW9uID09PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGFyZ2V0TG9jYXRpb24udG9wICsgMC41ICogdGFyZ2V0TG9jYXRpb24uaGVpZ2h0IC0gMC41ICogdGlwTG9jYXRpb24uaGVpZ2h0O1xyXG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0YXJnZXRMb2NhdGlvbi5sZWZ0IC0gdGlwTG9jYXRpb24ud2lkdGggLSBvZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb3BzLlBvc2l0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRhcmdldExvY2F0aW9uLnRvcCArIDAuNSAqIHRhcmdldExvY2F0aW9uLmhlaWdodCAtIDAuNSAqIHRpcExvY2F0aW9uLmhlaWdodDtcclxuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGFyZ2V0TG9jYXRpb24ubGVmdCArIHRhcmdldExvY2F0aW9uLndpZHRoICsgb2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9wcy5Qb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcHJvcHMuUG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0YXJnZXRMb2NhdGlvbi50b3AgLSB0aXBMb2NhdGlvbi5oZWlnaHQgLSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRhcmdldExvY2F0aW9uLmxlZnQgKyAwLjUgKiB0YXJnZXRMb2NhdGlvbi53aWR0aCAtIDAuNSAqIHRpcExvY2F0aW9uLndpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9wcy5Qb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcclxuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGFyZ2V0TG9jYXRpb24udG9wICsgdGFyZ2V0TG9jYXRpb24uaGVpZ2h0ICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0YXJnZXRMb2NhdGlvbi5sZWZ0ICsgMC41ICogdGFyZ2V0TG9jYXRpb24ud2lkdGggLSAwLjUgKiB0aXBMb2NhdGlvbi53aWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHZhciB0aGVtZSA9IChwcm9wcy5UaGVtZSA9PT0gdW5kZWZpbmVkID8gJ2RhcmsnIDogcHJvcHMuVGhlbWUpO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZXJEaXYsIHsgU2hvdzogcHJvcHMuU2hvdywgVGhlbWU6IHRoZW1lLCBUb3A6IHRvcCwgTGVmdDogbGVmdCwgaWQ6IGd1aWQsIExvY2F0aW9uOiBwcm9wcy5Qb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gJ3RvcCcgOiBwcm9wcy5Qb3NpdGlvbiwgWmluZGV4OiB6SW5kZXggfSwgcHJvcHMuY2hpbGRyZW4pKTtcclxufTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVG9vbFRpcDtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIFdhcm5pbmcudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDEyLzI5LzIwMjAgLSBDaHJpc3RvcGggTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgTW9kYWxfMSA9IHJlcXVpcmUoXCIuL01vZGFsXCIpO1xyXG4vLyBVc2FnZTpcclxuLy8gPFdhcm5pbmcgVGl0bGU9J1RoaXMgaXMgYSBXYXJuaW5nJyBNZXNzYWdlPXsnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIENvbnRpbnVlPyd9IENhbGxiYWNrPXsoY2FuY2VsZWQpID0+IHNldFNob3coZmFsc2UpfSBTaG93PXtzaG93fSAvPlxyXG4vL1xyXG4vLyBQcm9wcyBEZXNjcmlwdGlvbjpcclxuLy8gVGl0bGUgPT4gVGl0bGUgb2YgVGhlIE1vZGFsXHJcbi8vIENhbGxCYWNrID0+IEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGNsb3NpbmcgdGhlIE1vZGFsIGVpdGhlciB0aHJvdWdoIENhbmNlbCAoY29uZmlybWVkPWZhbHNlKSBvciBDb25maXJtIEJ1dHRvbiAoY29uZmlybWVkPXRydWUpXHJcbi8vIFNob3cgPT4gV2hldGhlciB0byBzaG93IHRoZSBtb2RhbFxyXG4vLyBNZXNzYWdlID0+IFRoZSBtZXNzYWdlIHNob3duIGJ5IHRoZSBNb2RhbFxyXG52YXIgV2FybmluZyA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE1vZGFsXzEuZGVmYXVsdCwgeyBUaXRsZTogcHJvcHMuVGl0bGUsIFNob3c6IHByb3BzLlNob3csIENhbmNlbEJ0bkNsYXNzOiAnYnRuLWRhbmdlcicsIENhbmNlbFRleHQ6ICdDYW5jZWwnLCBDb25maXJtQnRuQ2xhc3M6ICdidG4tc3VjY2VzcycsIENvbmZpcm1UZXh0OiAnQ29uZmlybScsIFNob3dYOiBmYWxzZSwgU2hvd0NhbmNlbDogdHJ1ZSwgU2l6ZTogJ3NtJywgQ2FsbEJhY2s6IGZ1bmN0aW9uIChjb25maXJtZWQpIHsgcmV0dXJuIHByb3BzLkNhbGxCYWNrKGNvbmZpcm1lZCk7IH0gfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBwcm9wcy5NZXNzYWdlKSkpO1xyXG59O1xyXG5leHBvcnRzLmRlZmF1bHQgPSBXYXJuaW5nO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBpbmRleC50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMTIvMjkvMjAyMCAtIEMuIExhY2tuZXIgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkZpbHRlcmFibGVUYWJsZSA9IGV4cG9ydHMuU2VjdGlvbiA9IGV4cG9ydHMuUGFnZSA9IGV4cG9ydHMuQXBwbGljYXRpb24gPSBleHBvcnRzLkNvbmZpZ3VyYWJsZVRhYmxlID0gZXhwb3J0cy5HZW5lcmljU2xpY2UgPSBleHBvcnRzLlNlcnZlckVycm9ySWNvbiA9IGV4cG9ydHMuVGFiU2VsZWN0b3IgPSBleHBvcnRzLlRvb2xUaXAgPSBleHBvcnRzLkxvYWRpbmdJY29uID0gZXhwb3J0cy5Mb2FkaW5nU2NyZWVuID0gZXhwb3J0cy5TZWFyY2hCYXIgPSBleHBvcnRzLldhcm5pbmcgPSBleHBvcnRzLk1vZGFsID0gdm9pZCAwO1xyXG52YXIgTW9kYWxfMSA9IHJlcXVpcmUoXCIuL01vZGFsXCIpO1xyXG5leHBvcnRzLk1vZGFsID0gTW9kYWxfMS5kZWZhdWx0O1xyXG52YXIgV2FybmluZ18xID0gcmVxdWlyZShcIi4vV2FybmluZ1wiKTtcclxuZXhwb3J0cy5XYXJuaW5nID0gV2FybmluZ18xLmRlZmF1bHQ7XHJcbnZhciBTZWFyY2hCYXJfMSA9IHJlcXVpcmUoXCIuL1NlYXJjaEJhclwiKTtcclxuZXhwb3J0cy5TZWFyY2hCYXIgPSBTZWFyY2hCYXJfMS5kZWZhdWx0O1xyXG52YXIgTG9hZGluZ1NjcmVlbl8xID0gcmVxdWlyZShcIi4vTG9hZGluZ1NjcmVlblwiKTtcclxuZXhwb3J0cy5Mb2FkaW5nU2NyZWVuID0gTG9hZGluZ1NjcmVlbl8xLmRlZmF1bHQ7XHJcbnZhciBMb2FkaW5nSWNvbl8xID0gcmVxdWlyZShcIi4vTG9hZGluZ0ljb25cIik7XHJcbmV4cG9ydHMuTG9hZGluZ0ljb24gPSBMb2FkaW5nSWNvbl8xLmRlZmF1bHQ7XHJcbnZhciBUb29sVGlwXzEgPSByZXF1aXJlKFwiLi9Ub29sVGlwXCIpO1xyXG5leHBvcnRzLlRvb2xUaXAgPSBUb29sVGlwXzEuZGVmYXVsdDtcclxudmFyIFRhYlNlbGVjdG9yXzEgPSByZXF1aXJlKFwiLi9UYWJTZWxlY3RvclwiKTtcclxuZXhwb3J0cy5UYWJTZWxlY3RvciA9IFRhYlNlbGVjdG9yXzEuZGVmYXVsdDtcclxudmFyIFNlcnZlckVycm9ySWNvbl8xID0gcmVxdWlyZShcIi4vU2VydmVyRXJyb3JJY29uXCIpO1xyXG5leHBvcnRzLlNlcnZlckVycm9ySWNvbiA9IFNlcnZlckVycm9ySWNvbl8xLmRlZmF1bHQ7XHJcbnZhciBHZW5lcmljU2xpY2VfMSA9IHJlcXVpcmUoXCIuL0dlbmVyaWNTbGljZVwiKTtcclxuZXhwb3J0cy5HZW5lcmljU2xpY2UgPSBHZW5lcmljU2xpY2VfMS5kZWZhdWx0O1xyXG52YXIgQ29uZmlndXJhYmxlVGFibGVfMSA9IHJlcXVpcmUoXCIuL0NvbmZpZ3VyYWJsZVRhYmxlXCIpO1xyXG5leHBvcnRzLkNvbmZpZ3VyYWJsZVRhYmxlID0gQ29uZmlndXJhYmxlVGFibGVfMS5kZWZhdWx0O1xyXG52YXIgQXBwbGljYXRpb25fMSA9IHJlcXVpcmUoXCIuL01lbnVlL0FwcGxpY2F0aW9uXCIpO1xyXG5leHBvcnRzLkFwcGxpY2F0aW9uID0gQXBwbGljYXRpb25fMS5kZWZhdWx0O1xyXG52YXIgUGFnZV8xID0gcmVxdWlyZShcIi4vTWVudWUvUGFnZVwiKTtcclxuZXhwb3J0cy5QYWdlID0gUGFnZV8xLmRlZmF1bHQ7XHJcbnZhciBTZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9NZW51ZS9TZWN0aW9uXCIpO1xyXG5leHBvcnRzLlNlY3Rpb24gPSBTZWN0aW9uXzEuZGVmYXVsdDtcclxudmFyIEZpbHRlcmFibGVUYWJsZV8xID0gcmVxdWlyZShcIi4vRmlsdGVyYWJsZVRhYmxlL0ZpbHRlcmFibGVUYWJsZVwiKTtcclxuZXhwb3J0cy5GaWx0ZXJhYmxlVGFibGUgPSBGaWx0ZXJhYmxlVGFibGVfMS5kZWZhdWx0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBEeW5hbWljVGFibGUudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjEsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDA3LzI2LzIwMjEgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuRHluYW1pY1RhYmxlID0gdm9pZCAwO1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciBUYWJsZV8xID0gcmVxdWlyZShcIi4vVGFibGVcIik7XHJcbmZ1bmN0aW9uIER5bmFtaWNUYWJsZShwcm9wcykge1xyXG4gICAgaWYgKHByb3BzLmRhdGEubGVuZ3RoIDw9IDApXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIgY29scyA9IFtdO1xyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcy5kYXRhWzBdKTtcclxuICAgIGZvciAodmFyIF9pID0gMCwga2V5c18xID0ga2V5czsgX2kgPCBrZXlzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGtleXNfMVtfaV07XHJcbiAgICAgICAgY29scy5wdXNoKHsga2V5OiBrZXksIGxhYmVsOiBrZXksIGZpZWxkOiBrZXkgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IGNsYXNzTmFtZTogcHJvcHMudGFibGVDbGFzcyAhPT0gdW5kZWZpbmVkID8gcHJvcHMudGFibGVDbGFzcyA6ICcnLCBzdHlsZTogcHJvcHMudGFibGVTdHlsZSB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFibGVfMS5IZWFkZXIsIHsgQ2xhc3M6IHByb3BzLnRoZWFkQ2xhc3MsIFN0eWxlOiBwcm9wcy50aGVhZFN0eWxlLCBDb2xzOiBjb2xzLCBTb3J0S2V5OiBwcm9wcy5zb3J0S2V5LCBBc2NlbmRpbmc6IHByb3BzLmFzY2VuZGluZywgQ2xpY2s6IGZ1bmN0aW9uIChkLCBlKSB7IHJldHVybiBoYW5kbGVTb3J0KGQsIGUpOyB9IH0pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFibGVfMS5Sb3dzLCB7IERhdGE6IHByb3BzLmRhdGEsIENvbHM6IGNvbHMsIFJvd1N0eWxlOiBwcm9wcy5yb3dTdHlsZSwgQm9keVN0eWxlOiBwcm9wcy50Ym9keVN0eWxlLCBCb2R5Q2xhc3M6IHByb3BzLnRib2R5Q2xhc3MsIENsaWNrOiBmdW5jdGlvbiAoZGF0YSwgZSkgeyByZXR1cm4gcHJvcHMub25DbGljayhkYXRhLCBlKTsgfSwgU2VsZWN0ZWQ6IHByb3BzLnNlbGVjdGVkLCBLZXlTZWxlY3RvcjogcHJvcHMua2V5U2VsZWN0b3IgfSkpKTtcclxuICAgIGZ1bmN0aW9uIGhhbmRsZVNvcnQoZGF0YSwgZXZlbnQpIHtcclxuICAgICAgICBpZiAoZGF0YS5jb2xLZXkgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHByb3BzLm9uU29ydChkYXRhKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkR5bmFtaWNUYWJsZSA9IER5bmFtaWNUYWJsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgU2VhcmNoYWJsZVRhYmxlLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIxLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwNy8xMi8yMDIxIC0gQy4gTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlNlYXJjaGFibGVUYWJsZSA9IHZvaWQgMDtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgVGFibGVfMSA9IHJlcXVpcmUoXCIuL1RhYmxlXCIpO1xyXG4vKipcclxuICogQSBUYWJsZSB3aXRoIGFuIGlucHV0IEZpZWxkIHRvIHNlYXJjaCBvbiB0b3BcclxuICovXHJcbmZ1bmN0aW9uIFNlYXJjaGFibGVUYWJsZShwcm9wcykge1xyXG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUocHJvcHMuZGF0YSksIGRhdGEgPSBfYVswXSwgc2V0RGF0YSA9IF9hWzFdO1xyXG4gICAgdmFyIF9iID0gUmVhY3QudXNlU3RhdGUoJycpLCBzZWFyY2hUZXh0QVMgPSBfYlswXSwgc2V0U2VhcmNoVGV4dEFTID0gX2JbMV07XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldERhdGEocHJvcHMuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHByb3BzLm1hdGNoU2VhcmNoKHMsIHNlYXJjaFRleHRBUyk7IH0pKTtcclxuICAgIH0sIFtwcm9wcy5kYXRhLCBzZWFyY2hUZXh0QVNdKTtcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IGNsYXNzTmFtZTogXCJmb3JtLWNvbnRyb2xcIiwgcGxhY2Vob2xkZXI6IFwiU2VhcmNoIGZpbHRlciBmb3Igc2VsZWN0IGJveCAuLi5cIiwgdmFsdWU6IHNlYXJjaFRleHRBUywgb25DaGFuZ2U6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBzZXRTZWFyY2hUZXh0QVMoZS50YXJnZXQudmFsdWUpOyB9IH0pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFibGVfMS5kZWZhdWx0LCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgZGF0YTogZGF0YSB9KSkpO1xyXG59XHJcbmV4cG9ydHMuU2VhcmNoYWJsZVRhYmxlID0gU2VhcmNoYWJsZVRhYmxlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBTZWxlY3RUYWJsZS50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDEvMjIvMjAyMSAtIEMuIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXHJcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5TZWxlY3RUYWJsZSA9IHZvaWQgMDtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XHJcbnZhciBUYWJsZV8xID0gcmVxdWlyZShcIi4vVGFibGVcIik7XHJcbmZ1bmN0aW9uIFNlbGVjdFRhYmxlKHByb3BzKSB7XHJcbiAgICB2YXIgZGlkTW91bnRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xyXG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUocHJvcHMuZGF0YSksIGRhdGEgPSBfYVswXSwgc2V0RGF0YSA9IF9hWzFdO1xyXG4gICAgdmFyIF9iID0gUmVhY3QudXNlU3RhdGUoW10pLCBzZWxlY3RlZCA9IF9iWzBdLCBzZXRTZWxlY3RlZCA9IF9iWzFdO1xyXG4gICAgdmFyIF9jID0gUmVhY3QudXNlU3RhdGUocHJvcHMuc29ydEtleSksIHNvcnRLZXkgPSBfY1swXSwgc2V0U29ydEtleSA9IF9jWzFdO1xyXG4gICAgdmFyIF9kID0gUmVhY3QudXNlU3RhdGUocHJvcHMuYXNjZW5kaW5nKSwgYXNjZW5kaW5nID0gX2RbMF0sIHNldEFzY2VuZGluZyA9IF9kWzFdO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoZGlkTW91bnRSZWYuY3VycmVudClcclxuICAgICAgICAgICAgc2VsZWN0QWxsKCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBkaWRNb3VudFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIH0sIFtwcm9wcy5zZWxlY3RBbGxDb3VudGVyXSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChwcm9wcy5kYXRhLmxlbmd0aCAhPT0gZGF0YS5sZW5ndGgpXHJcbiAgICAgICAgICAgIHNldERhdGEocHJvcHMuZGF0YSk7XHJcbiAgICB9LCBbcHJvcHMuZGF0YV0pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5maWx0ZXIoZnVuY3Rpb24gKGtleUl0ZW0pIHsgcmV0dXJuIGRhdGEuZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtW3Byb3BzLktleUZpZWxkXSA9PT0ga2V5SXRlbTsgfSkgPiAtMTsgfSk7IH0pO1xyXG4gICAgfSwgW2RhdGFdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNvcnRDb2x1bW4gPSBwcm9wcy5jb2xzLmZpbHRlcihmdW5jdGlvbiAoY29sKSB7IHJldHVybiBjb2wua2V5ID09PSBzb3J0S2V5OyB9KVswXTtcclxuICAgICAgICBpZiAoc29ydENvbHVtbiA9PT0gdW5kZWZpbmVkIHx8IHNvcnRDb2x1bW4uZmllbGQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBzb3J0RmllbGQgPSBzb3J0Q29sdW1uLmZpZWxkO1xyXG4gICAgICAgIHNldERhdGEoZnVuY3Rpb24gKGxzdCkgeyByZXR1cm4gKF8ub3JkZXJCeShsc3QsIFtzb3J0RmllbGRdLCBbKGFzY2VuZGluZyA/IFwiYXNjXCIgOiBcImRlc2NcIildKSk7IH0pO1xyXG4gICAgfSwgW2FzY2VuZGluZywgc29ydEtleV0pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwcm9wcy5vblNlbGVjdGlvbihkYXRhLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gc2VsZWN0ZWQuZmluZEluZGV4KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSA9PT0gaXRlbVtwcm9wcy5LZXlGaWVsZF07IH0pID4gLTE7IH0pKTtcclxuICAgIH0sIFtzZWxlY3RlZF0pO1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZCwgZXZlbnQpIHtcclxuICAgICAgICB2YXIgc0luZGV4ID0gc2VsZWN0ZWQuZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtID09PSBkLnJvd1twcm9wcy5LZXlGaWVsZF07IH0pO1xyXG4gICAgICAgIGlmIChzSW5kZXggPT09IC0xKVxyXG4gICAgICAgICAgICBzZXRTZWxlY3RlZChmdW5jdGlvbiAob2QpIHsgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb2QsIHRydWUpLCBbZC5yb3dbcHJvcHMuS2V5RmllbGRdXSwgZmFsc2UpOyB9KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHNldFNlbGVjdGVkKGZ1bmN0aW9uIChvZCkgeyByZXR1cm4gb2QuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtICE9PSBkLnJvd1twcm9wcy5LZXlGaWVsZF07IH0pOyB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNlbGVjdEFsbCgpIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChmdW5jdGlvbiAoZCkgeyBpZiAoZC5sZW5ndGggPT09IGRhdGEubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93W3Byb3BzLktleUZpZWxkXTsgfSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU29ydChkKSB7XHJcbiAgICAgICAgaWYgKGQuY29sS2V5ID09PSBzb3J0S2V5KVxyXG4gICAgICAgICAgICBzZXRBc2NlbmRpbmcoIWFzY2VuZGluZyk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBzZXRTb3J0S2V5KGQuY29sS2V5KTtcclxuICAgIH1cclxuICAgIHZhciB0YWJsZVByb3BzID0ge1xyXG4gICAgICAgIGNvbHM6IF9fc3ByZWFkQXJyYXkoW1xyXG4gICAgICAgICAgICB7IGtleTogJ2dlbXN0b25lLWNoZWNrYm94JywgZmllbGQ6IHByb3BzLktleUZpZWxkLCBsYWJlbDogJycsIGhlYWRlclN0eWxlOiB7IHdpZHRoOiAnNGVtJyB9LCByb3dTdHlsZTogeyB3aWR0aDogJzRlbScgfSwgY29udGVudDogZnVuY3Rpb24gKGl0ZW0sIGtleSwgZmllbGQsIHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc2VsZWN0ZWQuZmluZEluZGV4KGZ1bmN0aW9uIChpKSB7IHJldHVybiBpID09PSBpdGVtW3Byb3BzLktleUZpZWxkXTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgbWFyZ2luVG9wOiAnMTZweCcsIHRleHRBbGlnbjogJ2NlbnRlcicgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlcIiwgeyBjbGFzc05hbWU6IFwiZmEgZmEtY2hlY2stc3F1YXJlLW8gZmEtM3hcIiB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9IH1cclxuICAgICAgICBdLCBwcm9wcy5jb2xzLCB0cnVlKSxcclxuICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLFxyXG4gICAgICAgIHNvcnRLZXk6IHNvcnRLZXksXHJcbiAgICAgICAgYXNjZW5kaW5nOiBhc2NlbmRpbmcsXHJcbiAgICAgICAgb25Tb3J0OiBoYW5kbGVTb3J0LFxyXG4gICAgICAgIHRhYmxlQ2xhc3M6IHByb3BzLnRhYmxlQ2xhc3MsXHJcbiAgICAgICAgdGFibGVTdHlsZTogcHJvcHMudGFibGVTdHlsZSxcclxuICAgICAgICB0aGVhZFN0eWxlOiBwcm9wcy50aGVhZFN0eWxlLFxyXG4gICAgICAgIHRoZWFkQ2xhc3M6IHByb3BzLnRoZWFkQ2xhc3MsXHJcbiAgICAgICAgdGJvZHlTdHlsZTogcHJvcHMudGJvZHlTdHlsZSxcclxuICAgICAgICB0Ym9keUNsYXNzOiBwcm9wcy50Ym9keUNsYXNzLFxyXG4gICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZmFsc2U7IH0sXHJcbiAgICAgICAgcm93U3R5bGU6IHByb3BzLnJvd1N0eWxlXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFibGVfMS5kZWZhdWx0LCBfX2Fzc2lnbih7fSwgdGFibGVQcm9wcykpO1xyXG59XHJcbmV4cG9ydHMuU2VsZWN0VGFibGUgPSBTZWxlY3RUYWJsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIFRhYmxlLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE4LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwOC8wMi8yMDE4IC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkhlYWRlciA9IGV4cG9ydHMuUm93cyA9IHZvaWQgMDtcclxudmFyIGdwYV9zeW1ib2xzXzEgPSByZXF1aXJlKFwiQGdwYS1nZW1zdG9uZS9ncGEtc3ltYm9sc1wiKTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG5mdW5jdGlvbiBUYWJsZShwcm9wcykge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBjbGFzc05hbWU6IHByb3BzLnRhYmxlQ2xhc3MgIT09IHVuZGVmaW5lZCA/IHByb3BzLnRhYmxlQ2xhc3MgOiAnJywgc3R5bGU6IHByb3BzLnRhYmxlU3R5bGUgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRlciwgeyBDbGFzczogcHJvcHMudGhlYWRDbGFzcywgU3R5bGU6IHByb3BzLnRoZWFkU3R5bGUsIENvbHM6IHByb3BzLmNvbHMsIFNvcnRLZXk6IHByb3BzLnNvcnRLZXksIEFzY2VuZGluZzogcHJvcHMuYXNjZW5kaW5nLCBDbGljazogZnVuY3Rpb24gKGQsIGUpIHsgcmV0dXJuIGhhbmRsZVNvcnQoZCwgZSk7IH0gfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3dzLCB7IERhdGE6IHByb3BzLmRhdGEsIENvbHM6IHByb3BzLmNvbHMsIFJvd1N0eWxlOiBwcm9wcy5yb3dTdHlsZSwgQm9keVN0eWxlOiBwcm9wcy50Ym9keVN0eWxlLCBCb2R5Q2xhc3M6IHByb3BzLnRib2R5Q2xhc3MsIENsaWNrOiBmdW5jdGlvbiAoZGF0YSwgZSkgeyByZXR1cm4gKHByb3BzLm9uQ2xpY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBwcm9wcy5vbkNsaWNrKGRhdGEsIGUpKTsgfSwgU2VsZWN0ZWQ6IHByb3BzLnNlbGVjdGVkLCBLZXlTZWxlY3RvcjogcHJvcHMua2V5U2VsZWN0b3IgfSkpKTtcclxuICAgIGZ1bmN0aW9uIGhhbmRsZVNvcnQoZGF0YSwgZXZlbnQpIHtcclxuICAgICAgICBpZiAoZGF0YS5jb2xLZXkgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHByb3BzLm9uU29ydChkYXRhKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBUYWJsZTtcclxuZnVuY3Rpb24gUm93cyhwcm9wcykge1xyXG4gICAgaWYgKHByb3BzLkRhdGEubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgdmFyIHJvd3MgPSBwcm9wcy5EYXRhLm1hcChmdW5jdGlvbiAoaXRlbSwgcm93SW5kZXgpIHtcclxuICAgICAgICB2YXIgY2VsbHMgPSBwcm9wcy5Db2xzLm1hcChmdW5jdGlvbiAoY29sRGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDZWxsLCB7IGtleTogY29sRGF0YS5rZXksIFN0eWxlOiBjb2xEYXRhLnJvd1N0eWxlLCBEYXRhS2V5OiBjb2xEYXRhLmtleSwgRGF0YUZpZWxkOiBjb2xEYXRhLmZpZWxkLCBPYmplY3Q6IGl0ZW0sIFJvd0luZGV4OiByb3dJbmRleCwgQ29udGVudDogY29sRGF0YS5jb250ZW50LCBDbGljazogZnVuY3Rpb24gKGRhdGEsIGUpIHsgcmV0dXJuIHByb3BzLkNsaWNrKGRhdGEsIGUpOyB9IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBzdHlsZSA9IChwcm9wcy5Sb3dTdHlsZSAhPT0gdW5kZWZpbmVkKSA/IF9fYXNzaWduKHt9LCBwcm9wcy5Sb3dTdHlsZSkgOiB7fTtcclxuICAgICAgICBpZiAoc3R5bGUuY3Vyc29yID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcclxuICAgICAgICBpZiAocHJvcHMuU2VsZWN0ZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5TZWxlY3RlZChpdGVtKSlcclxuICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3llbGxvdyc7XHJcbiAgICAgICAgZnVuY3Rpb24gVG9LZXkoaW5kZXgsIGRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BzLktleVNlbGVjdG9yID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXgudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzLktleVNlbGVjdG9yKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHN0eWxlOiBzdHlsZSwga2V5OiBUb0tleShyb3dJbmRleCwgaXRlbSkgfSwgY2VsbHMpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgeyBzdHlsZTogcHJvcHMuQm9keVN0eWxlLCBjbGFzc05hbWU6IHByb3BzLkJvZHlDbGFzcyB9LCByb3dzKSk7XHJcbn1cclxuZXhwb3J0cy5Sb3dzID0gUm93cztcclxuZnVuY3Rpb24gQ2VsbChwcm9wcykge1xyXG4gICAgdmFyIGNzcyA9IChwcm9wcy5TdHlsZSAhPT0gdW5kZWZpbmVkKSA/IF9fYXNzaWduKHt9LCBwcm9wcy5TdHlsZSkgOiB7fTtcclxuICAgIHZhciBnZXRGaWVsZFZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcHMuRGF0YUZpZWxkICE9PSB1bmRlZmluZWQgPyBwcm9wcy5PYmplY3RbcHJvcHMuRGF0YUZpZWxkXSA6IG51bGw7IH07XHJcbiAgICB2YXIgZ2V0RmllbGRDb250ZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcHMuQ29udGVudCAhPT0gdW5kZWZpbmVkID8gcHJvcHMuQ29udGVudChwcm9wcy5PYmplY3QsIHByb3BzLkRhdGFLZXksIHByb3BzLkRhdGFGaWVsZCwgY3NzLCBwcm9wcy5Sb3dJbmRleCkgOiBnZXRGaWVsZFZhbHVlKCk7IH07XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IHN0eWxlOiBjc3MsIG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBwcm9wcy5DbGljayh7IGNvbEtleTogcHJvcHMuRGF0YUtleSwgY29sRmllbGQ6IHByb3BzLkRhdGFGaWVsZCwgcm93OiBwcm9wcy5PYmplY3QsIGRhdGE6IGdldEZpZWxkVmFsdWUoKSwgaW5kZXg6IHByb3BzLlJvd0luZGV4IH0sIGUpOyB9IH0sIGdldEZpZWxkQ29udGVudCgpKSk7XHJcbn1cclxuZnVuY3Rpb24gSGVhZGVyKHByb3BzKSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aGVhZFwiLCB7IGNsYXNzTmFtZTogcHJvcHMuQ2xhc3MsIHN0eWxlOiBwcm9wcy5TdHlsZSB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBudWxsLCBwcm9wcy5Db2xzLm1hcChmdW5jdGlvbiAoY29sKSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRlckNlbGwsIHsga2V5OiBjb2wua2V5LCBIZWFkZXJTdHlsZTogY29sLmhlYWRlclN0eWxlLCBEYXRhS2V5OiBjb2wua2V5LCBDbGljazogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHByb3BzLkNsaWNrKHsgY29sS2V5OiBjb2wua2V5LCBjb2xGaWVsZDogY29sLmZpZWxkLCBhc2NlbmRpbmc6IHByb3BzLkFzY2VuZGluZyB9LCBlKTsgfSwgTGFiZWw6IGNvbC5sYWJlbCwgU29ydEtleTogcHJvcHMuU29ydEtleSwgQXNjZW5kaW5nOiBwcm9wcy5Bc2NlbmRpbmcgfSk7IH0pKSkpO1xyXG59XHJcbmV4cG9ydHMuSGVhZGVyID0gSGVhZGVyO1xyXG5mdW5jdGlvbiBIZWFkZXJDZWxsKHByb3BzKSB7XHJcbiAgICB2YXIgc3R5bGUgPSAocHJvcHMuSGVhZGVyU3R5bGUgIT09IHVuZGVmaW5lZCkgPyBwcm9wcy5IZWFkZXJTdHlsZSA6IHt9O1xyXG4gICAgaWYgKHN0eWxlLmN1cnNvciA9PT0gdW5kZWZpbmVkICYmIHByb3BzLkRhdGFLZXkgIT09IG51bGwpIHtcclxuICAgICAgICBzdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XHJcbiAgICB9XHJcbiAgICBpZiAoc3R5bGUucG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgIH1cclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRoXCIsIHsgc3R5bGU6IHN0eWxlLCBvbkNsaWNrOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gcHJvcHMuQ2xpY2soZSk7IH0gfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIHdpZHRoOiAyNSB9IH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVuZGVyQW5nbGVJY29uLCB7IFNvcnRLZXk6IHByb3BzLlNvcnRLZXksIEtleTogcHJvcHMuRGF0YUtleSwgQXNjZW5kaW5nOiBwcm9wcy5Bc2NlbmRpbmcgfSkpLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogeyBtYXJnaW5MZWZ0OiAyNSB9IH0sIHByb3BzLkxhYmVsKSkpO1xyXG59XHJcbmZ1bmN0aW9uIFJlbmRlckFuZ2xlSWNvbihwcm9wcykge1xyXG4gICAgdmFyIEFuZ2xlSWNvbiA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmFzY2VuZGluZyA/IGdwYV9zeW1ib2xzXzEuU1ZHSWNvbnMuQXJyb3dEcm9wVXAgOiBncGFfc3ltYm9sc18xLlNWR0ljb25zLkFycm93RHJvcERvd247IH07XHJcbiAgICBpZiAocHJvcHMuU29ydEtleSA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGlmIChwcm9wcy5Tb3J0S2V5ICE9PSBwcm9wcy5LZXkpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBbmdsZUljb24sIHsgYXNjZW5kaW5nOiBwcm9wcy5Bc2NlbmRpbmcgfSk7XHJcbn1cclxuO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgaW5kZXgudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMTgsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDA4LzAyLzIwMTggLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vICAwMi8xMi8yMDIxIC0gQy4gbGFja25lclxyXG4vLyAgICAgICBNb3ZlZCB0YWJsZSB0byBzZXBlcmF0ZSBGaWxlLlxyXG4vL1xyXG4vLyAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Sb3dzID0gZXhwb3J0cy5EeW5hbWljVGFibGUgPSBleHBvcnRzLlNlYXJjaGFibGVUYWJsZSA9IGV4cG9ydHMuU2VsZWN0VGFibGUgPSB2b2lkIDA7XHJcbnZhciBUYWJsZV8xID0gcmVxdWlyZShcIi4vVGFibGVcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvd3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFRhYmxlXzEuUm93czsgfSB9KTtcclxudmFyIFNlbGVjdFRhYmxlXzEgPSByZXF1aXJlKFwiLi9TZWxlY3RUYWJsZVwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VsZWN0VGFibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNlbGVjdFRhYmxlXzEuU2VsZWN0VGFibGU7IH0gfSk7XHJcbnZhciBTZWFyY2hhYmxlVGFibGVfMSA9IHJlcXVpcmUoXCIuL1NlYXJjaGFibGVUYWJsZVwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VhcmNoYWJsZVRhYmxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTZWFyY2hhYmxlVGFibGVfMS5TZWFyY2hhYmxlVGFibGU7IH0gfSk7XHJcbnZhciBEeW5hbWljVGFibGVfMSA9IHJlcXVpcmUoXCIuL0R5bmFtaWNUYWJsZVwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRHluYW1pY1RhYmxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEeW5hbWljVGFibGVfMS5EeW5hbWljVGFibGU7IH0gfSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRhYmxlXzEuZGVmYXVsdDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5TVkdJY29ucyA9IHZvaWQgMDtcclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBTVkdJY29ucy50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMiwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDIvMTcvMjAyMiAtIEMgTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIFNWR0ljb25zO1xyXG4oZnVuY3Rpb24gKFNWR0ljb25zKSB7XHJcbiAgICBTVkdJY29ucy5EYXRhQ29udGFpbmVyID0gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiBcIjI0XCIsIGhlaWdodDogXCIyNFwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgY2xhc3NOYW1lOiBcImZlYXRoZXIgZmVhdGhlci1maWxlXCIgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTSAzLDQuNSBhIDksNC41IDAsMCwwIDE4IDMgYSA5LDQuNSAwLDAsMCAtMTggMCBsIDAsMTEgYSA5LDQuNSAwLDAsMCAxOCAwIGwgMCwtMTFcIiB9KSk7XHJcbiAgICBTVkdJY29ucy5DdWJlID0gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiBcIjI0XCIsIGhlaWdodDogXCIyNFwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgY2xhc3NOYW1lOiBcImZlYXRoZXIgZmVhdGhlci1maWxlXCIgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7IHg6IFwiMVwiLCB5OiBcIjhcIiwgd2lkdGg6IFwiMTVcIiwgaGVpZ2h0OiBcIjE1XCIgfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwgeyB4OiBcIjZcIiwgeTogXCIzXCIsIHdpZHRoOiBcIjE1XCIsIGhlaWdodDogXCIxNVwiIH0pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMVwiLCB4MjogXCI2XCIsIHkxOiBcIjhcIiwgeTI6IFwiM1wiIH0pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMTZcIiwgeDI6IFwiMjFcIiwgeTE6IFwiOFwiLCB5MjogXCIzXCIgfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwgeyB4MTogXCIxNlwiLCB4MjogXCIyMVwiLCB5MTogXCIyM1wiLCB5MjogXCIxOFwiIH0pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMVwiLCB4MjogXCI2XCIsIHkxOiBcIjIzXCIsIHkyOiBcIjE4XCIgfSkpO1xyXG4gICAgU1ZHSWNvbnMuSG91c2UgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IFwiMjRcIiwgaGVpZ2h0OiBcIjI0XCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBjbGFzc05hbWU6IFwiZmVhdGhlciBmZWF0aGVyLWhvbWVcIiB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMyA5bDktNyA5IDd2MTFhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJ6XCIgfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjkgMjIgOSAxMiAxNSAxMiAxNSAyMlwiIH0pKTtcclxuICAgIFNWR0ljb25zLkRvY3VtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiBcIjI0XCIsIGhlaWdodDogXCIyNFwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgY2xhc3NOYW1lOiBcImZlYXRoZXIgZmVhdGhlci1maWxlLXRleHRcIiB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTQgMkg2YTIgMiAwIDAgMC0yIDJ2MTZhMiAyIDAgMCAwIDIgMmgxMmEyIDIgMCAwIDAgMi0yVjh6XCIgfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjE0IDIgMTQgOCAyMCA4XCIgfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwgeyB4MTogXCIxNlwiLCB5MTogXCIxM1wiLCB4MjogXCI4XCIsIHkyOiBcIjEzXCIgfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwgeyB4MTogXCIxNlwiLCB5MTogXCIxN1wiLCB4MjogXCI4XCIsIHkyOiBcIjE3XCIgfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjEwIDkgOSA5IDggOVwiIH0pKTtcclxuICAgIFNWR0ljb25zLkFycm93Rm9yd2FyZCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogXCIyNFwiLCBoZWlnaHQ6IFwiMjRcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgY2xhc3NOYW1lOiBcImZlYXRoZXIgZmVhdGhlci1maWxlLXRleHRcIiB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5Z29uXCIsIHsgcG9pbnRzOiBcIjYuMjMsMjAuMjMgOCwyMiAxOCwxMiA4LDIgNi4yMywzLjc3IDE0LjQ2LDEyXCIgfSkpO1xyXG4gICAgU1ZHSWNvbnMuQXJyb3dCYWNrd2FyZCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogXCIyNFwiLCBoZWlnaHQ6IFwiMjRcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgY2xhc3NOYW1lOiBcImZlYXRoZXIgZmVhdGhlci1maWxlLXRleHRcIiB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5Z29uXCIsIHsgcG9pbnRzOiBcIjE3Ljc3LDMuNzcgMTYsMiA2LDEyIDE2LDIyIDE3Ljc3LDIwLjIzIDkuNTQsMTJcIiB9KSk7XHJcbiAgICBTVkdJY29ucy5BcnJvd0Ryb3BVcCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogXCIyNFwiLCBoZWlnaHQ6IFwiMjRcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgY2xhc3NOYW1lOiBcImZlYXRoZXIgZmVhdGhlci1maWxlLXRleHRcIiB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNyAxNGw1LTUgNSA1elwiIH0pKTtcclxuICAgIFNWR0ljb25zLkFycm93RHJvcERvd24gPSBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IFwiMjRcIiwgaGVpZ2h0OiBcIjI0XCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIGNsYXNzTmFtZTogXCJmZWF0aGVyIGZlYXRoZXItZmlsZS10ZXh0XCIgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTcgMTBsNSA1IDUtNXpcIiB9KSk7XHJcbiAgICBTVkdJY29ucy5TZXR0aW5ncyA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogXCIyNFwiLCBoZWlnaHQ6IFwiMjRcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIGNsYXNzTmFtZTogXCJmZWF0aGVyIGZlYXRoZXItZmlsZS10ZXh0XCIgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE5LjE0LDEyLjk0YzAuMDQtMC4zLDAuMDYtMC42MSwwLjA2LTAuOTRjMC0wLjMyLTAuMDItMC42NC0wLjA3LTAuOTRsMi4wMy0xLjU4YzAuMTgtMC4xNCwwLjIzLTAuNDEsMC4xMi0wLjYxIGwtMS45Mi0zLjMyYy0wLjEyLTAuMjItMC4zNy0wLjI5LTAuNTktMC4yMmwtMi4zOSwwLjk2Yy0wLjUtMC4zOC0xLjAzLTAuNy0xLjYyLTAuOTRMMTQuNCwyLjgxYy0wLjA0LTAuMjQtMC4yNC0wLjQxLTAuNDgtMC40MSBoLTMuODRjLTAuMjQsMC0wLjQzLDAuMTctMC40NywwLjQxTDkuMjUsNS4zNUM4LjY2LDUuNTksOC4xMiw1LjkyLDcuNjMsNi4yOUw1LjI0LDUuMzNjLTAuMjItMC4wOC0wLjQ3LDAtMC41OSwwLjIyTDIuNzQsOC44NyBDMi42Miw5LjA4LDIuNjYsOS4zNCwyLjg2LDkuNDhsMi4wMywxLjU4QzQuODQsMTEuMzYsNC44LDExLjY5LDQuOCwxMnMwLjAyLDAuNjQsMC4wNywwLjk0bC0yLjAzLDEuNTggYy0wLjE4LDAuMTQtMC4yMywwLjQxLTAuMTIsMC42MWwxLjkyLDMuMzJjMC4xMiwwLjIyLDAuMzcsMC4yOSwwLjU5LDAuMjJsMi4zOS0wLjk2YzAuNSwwLjM4LDEuMDMsMC43LDEuNjIsMC45NGwwLjM2LDIuNTQgYzAuMDUsMC4yNCwwLjI0LDAuNDEsMC40OCwwLjQxaDMuODRjMC4yNCwwLDAuNDQtMC4xNywwLjQ3LTAuNDFsMC4zNi0yLjU0YzAuNTktMC4yNCwxLjEzLTAuNTYsMS42Mi0wLjk0bDIuMzksMC45NiBjMC4yMiwwLjA4LDAuNDcsMCwwLjU5LTAuMjJsMS45Mi0zLjMyYzAuMTItMC4yMiwwLjA3LTAuNDctMC4xMi0wLjYxTDE5LjE0LDEyLjk0eiBNMTIsMTUuNmMtMS45OCwwLTMuNi0xLjYyLTMuNi0zLjYgczEuNjItMy42LDMuNi0zLjZzMy42LDEuNjIsMy42LDMuNlMxMy45OCwxNS42LDEyLDE1LjZ6XCIgfSkpO1xyXG4gICAgU1ZHSWNvbnMuRmlsdGVyID0gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiBcIjI0XCIsIGhlaWdodDogXCIyNFwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgY2xhc3NOYW1lOiBcImZlYXRoZXIgZmVhdGhlci1maWxlLXRleHRcIiB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNC4yNSw1LjYxQzYuMjcsOC4yLDEwLDEzLDEwLDEzdjZjMCwwLjU1LDAuNDUsMSwxLDFoMmMwLjU1LDAsMS0wLjQ1LDEtMXYtNmMwLDAsMy43Mi00LjgsNS43NC03LjM5IEMyMC4yNSw0Ljk1LDE5Ljc4LDQsMTguOTUsNEg1LjA0QzQuMjEsNCwzLjc0LDQuOTUsNC4yNSw1LjYxelwiIH0pKTtcclxufSkoU1ZHSWNvbnMgPSBleHBvcnRzLlNWR0ljb25zIHx8IChleHBvcnRzLlNWR0ljb25zID0ge30pKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgaW5kZXgudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjEsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDA5LzMwLzIwMjAgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU1ZHSWNvbnMgPSBleHBvcnRzLlF1ZXN0aW9ubWFyayA9IGV4cG9ydHMuUmV3aW5kQnV0dG9uID0gZXhwb3J0cy5GYXN0Rm9yd2FyZEJ1dHRvbiA9IGV4cG9ydHMuUGF1c2VCdXR0b24gPSBleHBvcnRzLlN0b3BCdXR0b24gPSBleHBvcnRzLlBsYXlCdXR0b24gPSBleHBvcnRzLlNjcm9sbCA9IGV4cG9ydHMuSG91c2UgPSBleHBvcnRzLk1hZ25pZnlpbmdHbGFzcyA9IGV4cG9ydHMuRm91cldheUFycm93ID0gZXhwb3J0cy5JbnB1dE51bWJlcnMgPSBleHBvcnRzLkROQSA9IGV4cG9ydHMuRG93bkFycm93ID0gZXhwb3J0cy5SaWdodEFycm93ID0gZXhwb3J0cy5MZWZ0QXJyb3cgPSBleHBvcnRzLlVwQXJyb3cgPSBleHBvcnRzLkZsYWcgPSBleHBvcnRzLldyZW5jaCA9IGV4cG9ydHMuU3Bpbm5lciA9IGV4cG9ydHMuV2FybmluZyA9IGV4cG9ydHMuUGx1cyA9IGV4cG9ydHMuQ3Jvc3NNYXJrID0gZXhwb3J0cy5UcmFzaENhbiA9IGV4cG9ydHMuUGVuY2lsID0gZXhwb3J0cy5IZWF2eUNoZWNrTWFyayA9IHZvaWQgMDtcclxudmFyIFNWR0ljb25zXzEgPSByZXF1aXJlKFwiLi9TVkdJY29uc1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU1ZHSWNvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNWR0ljb25zXzEuU1ZHSWNvbnM7IH0gfSk7XHJcbmV4cG9ydHMuSGVhdnlDaGVja01hcmsgPSAn4pyU77iPJztcclxuZXhwb3J0cy5QZW5jaWwgPSAn4pyP77iPJztcclxuZXhwb3J0cy5UcmFzaENhbiA9ICfwn5eR77iPJztcclxuZXhwb3J0cy5Dcm9zc01hcmsgPSAn4p2MJztcclxuZXhwb3J0cy5QbHVzID0gJ+KelSc7XHJcbmV4cG9ydHMuV2FybmluZyA9ICfimqDvuI8nO1xyXG5leHBvcnRzLlNwaW5uZXIgPSAn8J+UhCc7XHJcbmV4cG9ydHMuV3JlbmNoID0gJ/CflKcnO1xyXG5leHBvcnRzLkZsYWcgPSAn8J+aqSc7XHJcbmV4cG9ydHMuVXBBcnJvdyA9ICfirIbvuI8nO1xyXG5leHBvcnRzLkxlZnRBcnJvdyA9ICfirIUnO1xyXG5leHBvcnRzLlJpZ2h0QXJyb3cgPSAn4p6hJztcclxuZXhwb3J0cy5Eb3duQXJyb3cgPSAn4qyH77iPJztcclxuZXhwb3J0cy5ETkEgPSAn8J+nrCc7XHJcbmV4cG9ydHMuSW5wdXROdW1iZXJzID0gJ/CflKInO1xyXG5leHBvcnRzLkZvdXJXYXlBcnJvdyA9ICfimKknO1xyXG5leHBvcnRzLk1hZ25pZnlpbmdHbGFzcyA9ICfwn5SNJztcclxuZXhwb3J0cy5Ib3VzZSA9ICfwn4+gJztcclxuZXhwb3J0cy5TY3JvbGwgPSAn8J+TnCc7XHJcbmV4cG9ydHMuUGxheUJ1dHRvbiA9ICfilrbvuI8nO1xyXG5leHBvcnRzLlN0b3BCdXR0b24gPSAn4o+577iPJztcclxuZXhwb3J0cy5QYXVzZUJ1dHRvbiA9ICfij7jvuI8nO1xyXG5leHBvcnRzLkZhc3RGb3J3YXJkQnV0dG9uID0gJ+KPqSc7XHJcbmV4cG9ydHMuUmV3aW5kQnV0dG9uID0gJ+KPqic7XHJcbmV4cG9ydHMuUXVlc3Rpb25tYXJrID0gJz8nO1xyXG4iLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcclxuICAgICAgICB0b1tqXSA9IGZyb21baV07XHJcbiAgICByZXR1cm4gdG87XHJcbn07XHJcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XHJcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG52YXIgX19kZWZOb3JtYWxQcm9wID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlOyB9O1xyXG52YXIgX19vYmpTcHJlYWQgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxyXG4gICAgICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcclxuICAgICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xyXG4gICAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYiA9IF9fZ2V0T3duUHJvcFN5bWJvbHMoYik7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gX2JbX2ldO1xyXG4gICAgICAgICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXHJcbiAgICAgICAgICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcbnZhciBfX2FzeW5jID0gZnVuY3Rpb24gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB2YXIgZnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfTtcclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuLy8gc3JjL2luZGV4LnRzXHJcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xyXG5pbXBvcnQgeyBkZWZhdWx0IGFzIGRlZmF1bHQyLCBjdXJyZW50IGFzIGN1cnJlbnQyLCBmcmVlemUsIG9yaWdpbmFsLCBpc0RyYWZ0IGFzIGlzRHJhZnQ0IH0gZnJvbSBcImltbWVyXCI7XHJcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIGFzIGNyZWF0ZVNlbGVjdG9yMiB9IGZyb20gXCJyZXNlbGVjdFwiO1xyXG4vLyBzcmMvY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IudHNcclxuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xyXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciB9IGZyb20gXCJyZXNlbGVjdFwiO1xyXG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgc2VsZWN0b3IgPSBjcmVhdGVTZWxlY3Rvci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gICAgdmFyIHdyYXBwZWRTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciByZXN0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgcmVzdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbaXNEcmFmdCh2YWx1ZSkgPyBjdXJyZW50KHZhbHVlKSA6IHZhbHVlXSwgcmVzdCkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB3cmFwcGVkU2VsZWN0b3I7XHJcbn07XHJcbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xyXG5pbXBvcnQgeyBjcmVhdGVTdG9yZSwgY29tcG9zZSBhcyBjb21wb3NlMiwgYXBwbHlNaWRkbGV3YXJlLCBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcclxuLy8gc3JjL2RldnRvb2xzRXh0ZW5zaW9uLnRzXHJcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tIFwicmVkdXhcIjtcclxudmFyIGNvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgIHJldHVybiBjb21wb3NlO1xyXG4gICAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxudmFyIGRldlRvb2xzRW5oYW5jZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vb3ApIHtcclxuICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgIH07XHJcbn07XHJcbi8vIHNyYy9pc1BsYWluT2JqZWN0LnRzXHJcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIHByb3RvID0gdmFsdWU7XHJcbiAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcclxufVxyXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcclxuaW1wb3J0IHRodW5rTWlkZGxld2FyZSBmcm9tIFwicmVkdXgtdGh1bmtcIjtcclxuLy8gc3JjL3V0aWxzLnRzXHJcbmZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXksIGZuTmFtZSkge1xyXG4gICAgdmFyIGVsYXBzZWQgPSAwO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtZWFzdXJlVGltZTogZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVkID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3YXJuSWZFeGNlZWRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZm5OYW1lICsgXCIgdG9vayBcIiArIGVsYXBzZWQgKyBcIm1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mIFwiICsgbWF4RGVsYXkgKyBcIm1zLiBcXG5JZiB5b3VyIHN0YXRlIG9yIGFjdGlvbnMgYXJlIHZlcnkgbGFyZ2UsIHlvdSBtYXkgd2FudCB0byBkaXNhYmxlIHRoZSBtaWRkbGV3YXJlIGFzIGl0IG1pZ2h0IGNhdXNlIHRvbyBtdWNoIG9mIGEgc2xvd2Rvd24gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2dldERlZmF1bHRNaWRkbGV3YXJlIGZvciBpbnN0cnVjdGlvbnMuXFxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG52YXIgTWlkZGxld2FyZUFycmF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1pZGRsZXdhcmVBcnJheSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1pZGRsZXdhcmVBcnJheSgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNaWRkbGV3YXJlQXJyYXkucHJvdG90eXBlKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWlkZGxld2FyZUFycmF5LCBTeW1ib2wuc3BlY2llcywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWlkZGxld2FyZUFycmF5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1pZGRsZXdhcmVBcnJheS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcnJbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29uY2F0LmFwcGx5KHRoaXMsIGFycik7XHJcbiAgICB9O1xyXG4gICAgTWlkZGxld2FyZUFycmF5LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcnJbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgKE1pZGRsZXdhcmVBcnJheS5iaW5kLmFwcGx5KE1pZGRsZXdhcmVBcnJheSwgX19zcHJlYWRBcnJheShbdm9pZCAwXSwgYXJyWzBdLmNvbmNhdCh0aGlzKSkpKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IChNaWRkbGV3YXJlQXJyYXkuYmluZC5hcHBseShNaWRkbGV3YXJlQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyci5jb25jYXQodGhpcykpKSkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTWlkZGxld2FyZUFycmF5O1xyXG59KEFycmF5KSk7XHJcbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxudmFyIHByZWZpeCA9IFwiSW52YXJpYW50IGZhaWxlZFwiO1xyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8IFwiXCIpKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBzZXJpYWxpemVyLCBpbmRlbnQsIGRlY3ljbGVyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZShzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xyXG4gICAgdmFyIHN0YWNrID0gW10sIGtleXMgPSBbXTtcclxuICAgIGlmICghZGVjeWNsZXIpXHJcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbiAoXywgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+XVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrRm9yTXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKSB7XHJcbiAgICB2YXIgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkZXRlY3RNdXRhdGlvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIHRyYWNrZWRQcm9wZXJ0aWVzLCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqLCBwYXRoKSB7XHJcbiAgICBpZiAoaWdub3JlUGF0aHMgPT09IHZvaWQgMCkgeyBpZ25vcmVQYXRocyA9IFtdOyB9XHJcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBcIlwiOyB9XHJcbiAgICB2YXIgdHJhY2tlZCA9IHsgdmFsdWU6IG9iaiB9O1xyXG4gICAgaWYgKCFpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICAgICAgdHJhY2tlZC5jaGlsZHJlbiA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XHJcbiAgICAgICAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJhY2tlZC5jaGlsZHJlbltrZXldID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqW2tleV0sIGNoaWxkUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyYWNrZWQ7XHJcbn1cclxuZnVuY3Rpb24gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgdHJhY2tlZFByb3BlcnR5LCBvYmosIHNhbWVQYXJlbnRSZWYsIHBhdGgpIHtcclxuICAgIGlmIChpZ25vcmVQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZVBhdGhzID0gW107IH1cclxuICAgIGlmIChzYW1lUGFyZW50UmVmID09PSB2b2lkIDApIHsgc2FtZVBhcmVudFJlZiA9IGZhbHNlOyB9XHJcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBcIlwiOyB9XHJcbiAgICB2YXIgcHJldk9iaiA9IHRyYWNrZWRQcm9wZXJ0eSA/IHRyYWNrZWRQcm9wZXJ0eS52YWx1ZSA6IHZvaWQgMDtcclxuICAgIHZhciBzYW1lUmVmID0gcHJldk9iaiA9PT0gb2JqO1xyXG4gICAgaWYgKHNhbWVQYXJlbnRSZWYgJiYgIXNhbWVSZWYgJiYgIU51bWJlci5pc05hTihvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2FzTXV0YXRlZDogdHJ1ZSwgcGF0aDogcGF0aCB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzSW1tdXRhYmxlKHByZXZPYmopIHx8IGlzSW1tdXRhYmxlKG9iaikpIHtcclxuICAgICAgICByZXR1cm4geyB3YXNNdXRhdGVkOiBmYWxzZSB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGtleXNUb0RldGVjdCA9IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xyXG4gICAgICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XHJcbiAgICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XHJcbiAgICAgICAgaWYgKGlnbm9yZVBhdGhzLmxlbmd0aCAmJiBpZ25vcmVQYXRocy5pbmRleE9mKGNoaWxkUGF0aCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuW2tleV0sIG9ialtrZXldLCBzYW1lUmVmLCBjaGlsZFBhdGgpO1xyXG4gICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IHdhc011dGF0ZWQ6IGZhbHNlIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBuZXh0KGFjdGlvbik7IH07IH07IH07XHJcbiAgICB9XHJcbiAgICB2YXIgX2IgPSBvcHRpb25zLmlzSW1tdXRhYmxlLCBpc0ltbXV0YWJsZSA9IF9iID09PSB2b2lkIDAgPyBpc0ltbXV0YWJsZURlZmF1bHQgOiBfYiwgaWdub3JlZFBhdGhzID0gb3B0aW9ucy5pZ25vcmVkUGF0aHMsIF9jID0gb3B0aW9ucy53YXJuQWZ0ZXIsIHdhcm5BZnRlciA9IF9jID09PSB2b2lkIDAgPyAzMiA6IF9jLCBpZ25vcmUgPSBvcHRpb25zLmlnbm9yZTtcclxuICAgIGlnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocyB8fCBpZ25vcmU7XHJcbiAgICB2YXIgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgIHZhciBnZXRTdGF0ZSA9IF9iLmdldFN0YXRlO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgdmFyIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgaW52YXJpYW50KCFyZXN1bHQud2FzTXV0YXRlZCwgXCJBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICdcIiArIChyZXN1bHQucGF0aCB8fCBcIlwiKSArIFwiJy4gIFRoaXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvci4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGRpc3BhdGNoZWRBY3Rpb24gPSBuZXh0KGFjdGlvbik7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC53YXNNdXRhdGVkICYmIGludmFyaWFudCghcmVzdWx0Lndhc011dGF0ZWQsIFwiQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiBcIiArIChyZXN1bHQucGF0aCB8fCBcIlwiKSArIFwiLiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uIFwiICsgc3RyaW5naWZ5KGFjdGlvbikgKyBcIi4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xyXG4gICAgICAgIH07IH07XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxuZnVuY3Rpb24gaXNQbGFpbih2YWwpIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcclxuICAgIHJldHVybiB0eXBlID09PSBcInVuZGVmaW5lZFwiIHx8IHZhbCA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcclxufVxyXG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGgsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMpIHtcclxuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IFwiXCI7IH1cclxuICAgIGlmIChpc1NlcmlhbGl6YWJsZSA9PT0gdm9pZCAwKSB7IGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbjsgfVxyXG4gICAgaWYgKGlnbm9yZWRQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZWRQYXRocyA9IFtdOyB9XHJcbiAgICB2YXIgZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XHJcbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtleVBhdGg6IHBhdGggfHwgXCI8cm9vdD5cIixcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfaSA8IGVudHJpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgX2IgPSBlbnRyaWVzXzFbX2ldLCBrZXkgPSBfYlswXSwgbmVzdGVkVmFsdWUgPSBfYlsxXTtcclxuICAgICAgICB2YXIgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XHJcbiAgICAgICAgaWYgKGhhc0lnbm9yZWRQYXRocyAmJiBpZ25vcmVkUGF0aHMuaW5kZXhPZihuZXN0ZWRQYXRoKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzKTtcclxuICAgICAgICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBuZXh0KGFjdGlvbik7IH07IH07IH07XHJcbiAgICB9XHJcbiAgICB2YXIgX2IgPSBvcHRpb25zLmlzU2VyaWFsaXphYmxlLCBpc1NlcmlhbGl6YWJsZSA9IF9iID09PSB2b2lkIDAgPyBpc1BsYWluIDogX2IsIGdldEVudHJpZXMgPSBvcHRpb25zLmdldEVudHJpZXMsIF9jID0gb3B0aW9ucy5pZ25vcmVkQWN0aW9ucywgaWdub3JlZEFjdGlvbnMgPSBfYyA9PT0gdm9pZCAwID8gW10gOiBfYywgX2QgPSBvcHRpb25zLmlnbm9yZWRBY3Rpb25QYXRocywgaWdub3JlZEFjdGlvblBhdGhzID0gX2QgPT09IHZvaWQgMCA/IFtcIm1ldGEuYXJnXCIsIFwibWV0YS5iYXNlUXVlcnlNZXRhXCJdIDogX2QsIF9lID0gb3B0aW9ucy5pZ25vcmVkUGF0aHMsIGlnbm9yZWRQYXRocyA9IF9lID09PSB2b2lkIDAgPyBbXSA6IF9lLCBfZiA9IG9wdGlvbnMud2FybkFmdGVyLCB3YXJuQWZ0ZXIgPSBfZiA9PT0gdm9pZCAwID8gMzIgOiBfZiwgX2cgPSBvcHRpb25zLmlnbm9yZVN0YXRlLCBpZ25vcmVTdGF0ZSA9IF9nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9nO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZUFQSSkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICBpZiAoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsIFwiU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlXCIpO1xyXG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocyk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogYFwiICsga2V5UGF0aCArIFwiYC4gVmFsdWU6XCIsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSBsb2dpYyB0aGF0IGRpc3BhdGNoZWQgdGhpcyBhY3Rpb246IFwiLCBhY3Rpb24sIFwiXFxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvYWN0aW9ucyN3aHktc2hvdWxkLXR5cGUtYmUtYS1zdHJpbmctb3ItYXQtbGVhc3Qtc2VyaWFsaXphYmxlLXdoeS1zaG91bGQtbXktYWN0aW9uLXR5cGVzLWJlLWNvbnN0YW50cylcIiwgXCJcXG4oVG8gYWxsb3cgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgc2VlOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3VzYWdlL3VzYWdlLWd1aWRlI3dvcmtpbmctd2l0aC1ub24tc2VyaWFsaXphYmxlLWRhdGEpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcclxuICAgICAgICBpZiAoIWlnbm9yZVN0YXRlKSB7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBzdG9yZUFQSS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShzdGF0ZSwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogYFwiICsga2V5UGF0aCArIFwiYC4gVmFsdWU6XCIsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6IFwiICsgYWN0aW9uLnR5cGUgKyBcIi5cXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07IH07IH07XHJcbn1cclxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xyXG59XHJcbmZ1bmN0aW9uIGN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucyk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgX2IgPSBvcHRpb25zLnRodW5rLCB0aHVuayA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5pbW11dGFibGVDaGVjaywgaW1tdXRhYmxlQ2hlY2sgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IG9wdGlvbnMuc2VyaWFsaXphYmxlQ2hlY2ssIHNlcmlhbGl6YWJsZUNoZWNrID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZDtcclxuICAgIHZhciBtaWRkbGV3YXJlQXJyYXkgPSBuZXcgTWlkZGxld2FyZUFycmF5KCk7XHJcbiAgICBpZiAodGh1bmspIHtcclxuICAgICAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlLndpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKGltbXV0YWJsZUNoZWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbW11dGFibGVPcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xyXG4gICAgICAgICAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShpbW11dGFibGVPcHRpb25zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXJpYWxpemFibGVDaGVjaykge1xyXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaChjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoc2VyaWFsaXphYmxlT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XHJcbn1cclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbnZhciBJU19QUk9EVUNUSU9OID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xyXG5mdW5jdGlvbiBjb25maWd1cmVTdG9yZShvcHRpb25zKSB7XHJcbiAgICB2YXIgY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlID0gY3VycnlHZXREZWZhdWx0TWlkZGxld2FyZSgpO1xyXG4gICAgdmFyIF9iID0gb3B0aW9ucyB8fCB7fSwgX2MgPSBfYi5yZWR1Y2VyLCByZWR1Y2VyID0gX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLCBfZCA9IF9iLm1pZGRsZXdhcmUsIG1pZGRsZXdhcmUgPSBfZCA9PT0gdm9pZCAwID8gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKCkgOiBfZCwgX2UgPSBfYi5kZXZUb29scywgZGV2VG9vbHMgPSBfZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9lLCBfZiA9IF9iLnByZWxvYWRlZFN0YXRlLCBwcmVsb2FkZWRTdGF0ZSA9IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZiwgX2cgPSBfYi5lbmhhbmNlcnMsIGVuaGFuY2VycyA9IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZztcclxuICAgIHZhciByb290UmVkdWNlcjtcclxuICAgIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChyZWR1Y2VyKSkge1xyXG4gICAgICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInJlZHVjZXJcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2VycycpO1xyXG4gICAgfVxyXG4gICAgdmFyIGZpbmFsTWlkZGxld2FyZSA9IG1pZGRsZXdhcmU7XHJcbiAgICBpZiAodHlwZW9mIGZpbmFsTWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgZmluYWxNaWRkbGV3YXJlID0gZmluYWxNaWRkbGV3YXJlKGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSk7XHJcbiAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIjsgfSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlYWNoIG1pZGRsZXdhcmUgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIG1pZGRsZXdhcmVFbmhhbmNlciA9IGFwcGx5TWlkZGxld2FyZS5hcHBseSh2b2lkIDAsIGZpbmFsTWlkZGxld2FyZSk7XHJcbiAgICB2YXIgZmluYWxDb21wb3NlID0gY29tcG9zZTI7XHJcbiAgICBpZiAoZGV2VG9vbHMpIHtcclxuICAgICAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKF9fb2JqU3ByZWFkKHtcclxuICAgICAgICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OXHJcbiAgICAgICAgfSwgdHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgc3RvcmVFbmhhbmNlcnMgPSBbbWlkZGxld2FyZUVuaGFuY2VyXTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGVuaGFuY2VycykpIHtcclxuICAgICAgICBzdG9yZUVuaGFuY2VycyA9IF9fc3ByZWFkQXJyYXkoW21pZGRsZXdhcmVFbmhhbmNlcl0sIGVuaGFuY2Vycyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZW5oYW5jZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBzdG9yZUVuaGFuY2VycyA9IGVuaGFuY2VycyhzdG9yZUVuaGFuY2Vycyk7XHJcbiAgICB9XHJcbiAgICB2YXIgY29tcG9zZWRFbmhhbmNlciA9IGZpbmFsQ29tcG9zZS5hcHBseSh2b2lkIDAsIHN0b3JlRW5oYW5jZXJzKTtcclxuICAgIHJldHVybiBjcmVhdGVTdG9yZShyb290UmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGNvbXBvc2VkRW5oYW5jZXIpO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVBY3Rpb24udHNcclxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcclxuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmVwYXJlQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24uYXBwbHkodm9pZCAwLCBhcmdzKTtcclxuICAgICAgICAgICAgaWYgKCFwcmVwYXJlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJlcGFyZUFjdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3RcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9fb2JqU3ByZWFkKF9fb2JqU3ByZWFkKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwcmVwYXJlZC5wYXlsb2FkXHJcbiAgICAgICAgICAgIH0sIFwibWV0YVwiIGluIHByZXBhcmVkICYmIHsgbWV0YTogcHJlcGFyZWQubWV0YSB9KSwgXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHsgZXJyb3I6IHByZXBhcmVkLmVycm9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBhcmdzWzBdIH07XHJcbiAgICB9XHJcbiAgICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJcIiArIHR5cGU7IH07XHJcbiAgICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xyXG4gICAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFjdGlvbi50eXBlID09PSB0eXBlOyB9O1xyXG4gICAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XHJcbn1cclxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdChhY3Rpb24pICYmIHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBPYmplY3Qua2V5cyhhY3Rpb24pLmV2ZXJ5KGlzVmFsaWRLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XHJcbiAgICByZXR1cm4gW1widHlwZVwiLCBcInBheWxvYWRcIiwgXCJlcnJvclwiLCBcIm1ldGFcIl0uaW5kZXhPZihrZXkpID4gLTE7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHlwZShhY3Rpb25DcmVhdG9yKSB7XHJcbiAgICByZXR1cm4gXCJcIiArIGFjdGlvbkNyZWF0b3I7XHJcbn1cclxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZSwgeyBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSwgZW5hYmxlRVM1IH0gZnJvbSBcImltbWVyXCI7XHJcbi8vIHNyYy9tYXBCdWlsZGVycy50c1xyXG5mdW5jdGlvbiBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhidWlsZGVyQ2FsbGJhY2spIHtcclxuICAgIHZhciBhY3Rpb25zTWFwID0ge307XHJcbiAgICB2YXIgYWN0aW9uTWF0Y2hlcnMgPSBbXTtcclxuICAgIHZhciBkZWZhdWx0Q2FzZVJlZHVjZXI7XHJcbiAgICB2YXIgYnVpbGRlciA9IHtcclxuICAgICAgICBhZGRDYXNlOiBmdW5jdGlvbiAodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcikge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uTWF0Y2hlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGRNYXRjaGVyYFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xyXG4gICAgICAgICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRDYXNlIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbnNNYXBbdHlwZV0gPSByZWR1Y2VyO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZE1hdGNoZXI6IGZ1bmN0aW9uIChtYXRjaGVyLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgYnVpbGRlci5hZGRNYXRjaGVyYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goeyBtYXRjaGVyOiBtYXRjaGVyLCByZWR1Y2VyOiByZWR1Y2VyIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZERlZmF1bHRDYXNlOiBmdW5jdGlvbiAocmVkdWNlcikge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBidWlsZGVyQ2FsbGJhY2soYnVpbGRlcik7XHJcbiAgICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBtYXBPckJ1aWxkZXJDYWxsYmFjaywgYWN0aW9uTWF0Y2hlcnMsIGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgaWYgKGFjdGlvbk1hdGNoZXJzID09PSB2b2lkIDApIHsgYWN0aW9uTWF0Y2hlcnMgPSBbXTsgfVxyXG4gICAgZW5hYmxlRVM1KCk7XHJcbiAgICB2YXIgX2IgPSB0eXBlb2YgbWFwT3JCdWlsZGVyQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKSA6IFttYXBPckJ1aWxkZXJDYWxsYmFjaywgYWN0aW9uTWF0Y2hlcnMsIGRlZmF1bHRDYXNlUmVkdWNlcl0sIGFjdGlvbnNNYXAgPSBfYlswXSwgZmluYWxBY3Rpb25NYXRjaGVycyA9IF9iWzFdLCBmaW5hbERlZmF1bHRDYXNlUmVkdWNlciA9IF9iWzJdO1xyXG4gICAgdmFyIGZyb3plbkluaXRpYWxTdGF0ZSA9IGNyZWF0ZU5leHRTdGF0ZShpbml0aWFsU3RhdGUsIGZ1bmN0aW9uICgpIHtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHsgc3RhdGUgPSBmcm96ZW5Jbml0aWFsU3RhdGU7IH1cclxuICAgICAgICB2YXIgY2FzZVJlZHVjZXJzID0gX19zcHJlYWRBcnJheShbXHJcbiAgICAgICAgICAgIGFjdGlvbnNNYXBbYWN0aW9uLnR5cGVdXHJcbiAgICAgICAgXSwgZmluYWxBY3Rpb25NYXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVyID0gX2IubWF0Y2hlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcclxuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgIHZhciByZWR1Y2VyID0gX2IucmVkdWNlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZXI7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGlmIChjYXNlUmVkdWNlcnMuZmlsdGVyKGZ1bmN0aW9uIChjcikgeyByZXR1cm4gISFjcjsgfSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICBpZiAoY2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RyYWZ0MihwcmV2aW91c1N0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmFmdCA9IHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzRHJhZnRhYmxlKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiQSBjYXNlIHJlZHVjZXIgb24gYSBub24tZHJhZnRhYmxlIHZhbHVlIG11c3Qgbm90IHJldHVybiB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlKHByZXZpb3VzU3RhdGUsIGZ1bmN0aW9uIChkcmFmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgfSwgc3RhdGUpO1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvY3JlYXRlU2xpY2UudHNcclxuZnVuY3Rpb24gZ2V0VHlwZTIoc2xpY2UsIGFjdGlvbktleSkge1xyXG4gICAgcmV0dXJuIHNsaWNlICsgXCIvXCIgKyBhY3Rpb25LZXk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2xpY2Uob3B0aW9ucykge1xyXG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUsIGluaXRpYWxTdGF0ZSA9IG9wdGlvbnMuaW5pdGlhbFN0YXRlO1xyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG5hbWVgIGlzIGEgcmVxdWlyZWQgb3B0aW9uIGZvciBjcmVhdGVTbGljZVwiKTtcclxuICAgIH1cclxuICAgIHZhciByZWR1Y2VycyA9IG9wdGlvbnMucmVkdWNlcnMgfHwge307XHJcbiAgICB2YXIgX2IgPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc10sIF9jID0gX2JbMF0sIGV4dHJhUmVkdWNlcnMgPSBfYyA9PT0gdm9pZCAwID8ge30gOiBfYywgX2QgPSBfYlsxXSwgYWN0aW9uTWF0Y2hlcnMgPSBfZCA9PT0gdm9pZCAwID8gW10gOiBfZCwgX2UgPSBfYlsyXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lO1xyXG4gICAgdmFyIHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcclxuICAgIHZhciBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSA9IHt9O1xyXG4gICAgdmFyIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlID0ge307XHJcbiAgICB2YXIgYWN0aW9uQ3JlYXRvcnMgPSB7fTtcclxuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWR1Y2VyTmFtZSkge1xyXG4gICAgICAgIHZhciBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSA9IHJlZHVjZXJzW3JlZHVjZXJOYW1lXTtcclxuICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUyKG5hbWUsIHJlZHVjZXJOYW1lKTtcclxuICAgICAgICB2YXIgY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgdmFyIHByZXBhcmVDYWxsYmFjaztcclxuICAgICAgICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xyXG4gICAgICAgICAgICBwcmVwYXJlQ2FsbGJhY2sgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5wcmVwYXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbcmVkdWNlck5hbWVdID0gY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSBjYXNlUmVkdWNlcjtcclxuICAgICAgICBhY3Rpb25DcmVhdG9yc1tyZWR1Y2VyTmFtZV0gPSBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGZpbmFsQ2FzZVJlZHVjZXJzID0gX19vYmpTcHJlYWQoX19vYmpTcHJlYWQoe30sIGV4dHJhUmVkdWNlcnMpLCBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSk7XHJcbiAgICB2YXIgcmVkdWNlciA9IGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBmaW5hbENhc2VSZWR1Y2VycywgYWN0aW9uTWF0Y2hlcnMsIGRlZmF1bHRDYXNlUmVkdWNlcik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgcmVkdWNlcjogcmVkdWNlcixcclxuICAgICAgICBhY3Rpb25zOiBhY3Rpb25DcmVhdG9ycyxcclxuICAgICAgICBjYXNlUmVkdWNlcnM6IHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lXHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy9lbnRpdHlfc3RhdGUudHNcclxuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZHM6IFtdLFxyXG4gICAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KCkge1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKGFkZGl0aW9uYWxTdGF0ZSkge1xyXG4gICAgICAgIGlmIChhZGRpdGlvbmFsU3RhdGUgPT09IHZvaWQgMCkgeyBhZGRpdGlvbmFsU3RhdGUgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZ2V0SW5pdGlhbFN0YXRlOiBnZXRJbml0aWFsU3RhdGUgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfc2VsZWN0b3JzLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XHJcbiAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUpIHtcclxuICAgICAgICB2YXIgc2VsZWN0SWRzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5pZHM7IH07XHJcbiAgICAgICAgdmFyIHNlbGVjdEVudGl0aWVzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5lbnRpdGllczsgfTtcclxuICAgICAgICB2YXIgc2VsZWN0QWxsID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0SWRzLCBzZWxlY3RFbnRpdGllcywgZnVuY3Rpb24gKGlkcywgZW50aXRpZXMpIHsgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBlbnRpdGllc1tpZF07IH0pOyB9KTtcclxuICAgICAgICB2YXIgc2VsZWN0SWQgPSBmdW5jdGlvbiAoXywgaWQpIHsgcmV0dXJuIGlkOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RCeUlkID0gZnVuY3Rpb24gKGVudGl0aWVzLCBpZCkgeyByZXR1cm4gZW50aXRpZXNbaWRdOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RUb3RhbCA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdElkcywgZnVuY3Rpb24gKGlkcykgeyByZXR1cm4gaWRzLmxlbmd0aDsgfSk7XHJcbiAgICAgICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0SWRzOiBzZWxlY3RJZHMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RFbnRpdGllczogc2VsZWN0RW50aXRpZXMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RBbGw6IHNlbGVjdEFsbCxcclxuICAgICAgICAgICAgICAgIHNlbGVjdFRvdGFsOiBzZWxlY3RUb3RhbCxcclxuICAgICAgICAgICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2VsZWN0SWRzOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcclxuICAgICAgICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcclxuICAgICAgICAgICAgc2VsZWN0QWxsOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcclxuICAgICAgICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RUb3RhbCksXHJcbiAgICAgICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGdldFNlbGVjdG9yczogZ2V0U2VsZWN0b3JzIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZTIsIHsgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xyXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gICAgdmFyIG9wZXJhdG9yID0gY3JlYXRlU3RhdGVPcGVyYXRvcihmdW5jdGlvbiAoXywgc3RhdGUpIHsgcmV0dXJuIG11dGF0b3Ioc3RhdGUpOyB9KTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNGU0EoYXJnMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBydW5NdXRhdG9yID0gZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaXNEcmFmdDMoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMihzdGF0ZSwgcnVuTXV0YXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcclxuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XHJcbiAgICB2YXIga2V5ID0gc2VsZWN0SWQoZW50aXR5KTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcclxuICAgICAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVudGl0aWVzO1xyXG59XHJcbmZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSkge1xyXG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgIHZhciBhZGRlZCA9IFtdO1xyXG4gICAgdmFyIHVwZGF0ZWQgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgbmV3RW50aXRpZXNfMSA9IG5ld0VudGl0aWVzOyBfaSA8IG5ld0VudGl0aWVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IG5ld0VudGl0aWVzXzFbX2ldO1xyXG4gICAgICAgIHZhciBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKGlkIGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZWQucHVzaCh7IGlkOiBpZCwgY2hhbmdlczogZW50aXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbYWRkZWQsIHVwZGF0ZWRdO1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKSB7XHJcbiAgICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICB2YXIga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcclxuICAgICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzIgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18yLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfMltfaV07XHJcbiAgICAgICAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzMgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18zLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfM1tfaV07XHJcbiAgICAgICAgICAgIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzID0ge307XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlTWFueU11dGFibHkoa2V5cywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgZGlkTXV0YXRlID0gZmFsc2U7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRpZE11dGF0ZSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgaW4gc3RhdGUuZW50aXRpZXM7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XHJcbiAgICAgICAgICAgIGlkczogW10sXHJcbiAgICAgICAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsMiA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDIsIHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgICAgICB2YXIgbmV3S2V5ID0gc2VsZWN0SWRWYWx1ZSh1cGRhdGVkLCBzZWxlY3RJZCk7XHJcbiAgICAgICAgdmFyIGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xyXG4gICAgICAgIGlmIChoYXNOZXdLZXkpIHtcclxuICAgICAgICAgICAga2V5c1t1cGRhdGUuaWRdID0gbmV3S2V5O1xyXG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XHJcbiAgICAgICAgcmV0dXJuIGhhc05ld0tleTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgbmV3S2V5cyA9IHt9O1xyXG4gICAgICAgIHZhciB1cGRhdGVzUGVyRW50aXR5ID0ge307XHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogX19vYmpTcHJlYWQoX19vYmpTcHJlYWQoe30sIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA/IHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXS5jaGFuZ2VzIDogbnVsbCksIHVwZGF0ZS5jaGFuZ2VzKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xyXG4gICAgICAgIHZhciBkaWRNdXRhdGVFbnRpdGllcyA9IHVwZGF0ZXMubGVuZ3RoID4gMDtcclxuICAgICAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdmFyIGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKGZ1bmN0aW9uICh1cGRhdGUpIHsgcmV0dXJuIHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSk7IH0pLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBuZXdLZXlzW2lkXSB8fCBpZDsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYiA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSksIGFkZGVkID0gX2JbMF0sIHVwZGF0ZWQgPSBfYlsxXTtcclxuICAgICAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVtb3ZlQWxsOiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IocmVtb3ZlQWxsTXV0YWJseSksXHJcbiAgICAgICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxyXG4gICAgICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcclxuICAgICAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcclxuICAgICAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXHJcbiAgICAgICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxyXG4gICAgICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcclxuICAgICAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXHJcbiAgICAgICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcclxuICAgIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3NvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydCkge1xyXG4gICAgdmFyIF9iID0gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpLCByZW1vdmVPbmUgPSBfYi5yZW1vdmVPbmUsIHJlbW92ZU1hbnkgPSBfYi5yZW1vdmVNYW55LCByZW1vdmVBbGwgPSBfYi5yZW1vdmVBbGw7XHJcbiAgICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gYWRkTWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgdmFyIG1vZGVscyA9IG5ld0VudGl0aWVzLmZpbHRlcihmdW5jdGlvbiAobW9kZWwpIHsgcmV0dXJuICEoc2VsZWN0SWRWYWx1ZShtb2RlbCwgc2VsZWN0SWQpIGluIHN0YXRlLmVudGl0aWVzKTsgfSk7XHJcbiAgICAgICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgbWVyZ2UobW9kZWxzLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNldE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIGlmIChuZXdFbnRpdGllcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgbWVyZ2UobmV3RW50aXRpZXMsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcclxuICAgICAgICBzdGF0ZS5pZHMgPSBbXTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0YWtlVXBkYXRlZE1vZGVsKG1vZGVscywgdXBkYXRlLCBzdGF0ZSkge1xyXG4gICAgICAgIGlmICghKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWwyID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICB2YXIgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsMiwgdXBkYXRlLmNoYW5nZXMpO1xyXG4gICAgICAgIHZhciBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcclxuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICBtb2RlbHMucHVzaCh1cGRhdGVkKTtcclxuICAgICAgICByZXR1cm4gbmV3S2V5ICE9PSB1cGRhdGUuaWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBtb2RlbHMgPSBbXTtcclxuICAgICAgICB1cGRhdGVzLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkgeyByZXR1cm4gdGFrZVVwZGF0ZWRNb2RlbChtb2RlbHMsIHVwZGF0ZSwgc3RhdGUpOyB9KTtcclxuICAgICAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYiA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSksIGFkZGVkID0gX2JbMF0sIHVwZGF0ZWQgPSBfYlsxXTtcclxuICAgICAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aCAmJiBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlKG1vZGVscywgc3RhdGUpIHtcclxuICAgICAgICBtb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICAgICAgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQobW9kZWwpXSA9IG1vZGVsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBhbGxFbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoc3RhdGUuZW50aXRpZXMpO1xyXG4gICAgICAgIGFsbEVudGl0aWVzLnNvcnQoc29ydCk7XHJcbiAgICAgICAgdmFyIG5ld1NvcnRlZElkcyA9IGFsbEVudGl0aWVzLm1hcChzZWxlY3RJZCk7XHJcbiAgICAgICAgdmFyIGlkcyA9IHN0YXRlLmlkcztcclxuICAgICAgICBpZiAoIWFyZUFycmF5c0VxdWFsKGlkcywgbmV3U29ydGVkSWRzKSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW1vdmVPbmU6IHJlbW92ZU9uZSxcclxuICAgICAgICByZW1vdmVNYW55OiByZW1vdmVNYW55LFxyXG4gICAgICAgIHJlbW92ZUFsbDogcmVtb3ZlQWxsLFxyXG4gICAgICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXHJcbiAgICAgICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcclxuICAgICAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcclxuICAgICAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXHJcbiAgICAgICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICAgICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXHJcbiAgICAgICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSlcclxuICAgIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZUVudGl0eUFkYXB0ZXIob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgIHZhciBfYiA9IF9fb2JqU3ByZWFkKHtcclxuICAgICAgICBzb3J0Q29tcGFyZXI6IGZhbHNlLFxyXG4gICAgICAgIHNlbGVjdElkOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHsgcmV0dXJuIGluc3RhbmNlLmlkOyB9XHJcbiAgICB9LCBvcHRpb25zKSwgc2VsZWN0SWQgPSBfYi5zZWxlY3RJZCwgc29ydENvbXBhcmVyID0gX2Iuc29ydENvbXBhcmVyO1xyXG4gICAgdmFyIHN0YXRlRmFjdG9yeSA9IGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3RvcnkoKTtcclxuICAgIHZhciBzZWxlY3RvcnNGYWN0b3J5ID0gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpO1xyXG4gICAgdmFyIHN0YXRlQWRhcHRlciA9IHNvcnRDb21wYXJlciA/IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydENvbXBhcmVyKSA6IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcclxuICAgIHJldHVybiBfX29ialNwcmVhZChfX29ialNwcmVhZChfX29ialNwcmVhZCh7XHJcbiAgICAgICAgc2VsZWN0SWQ6IHNlbGVjdElkLFxyXG4gICAgICAgIHNvcnRDb21wYXJlcjogc29ydENvbXBhcmVyXHJcbiAgICB9LCBzdGF0ZUZhY3RvcnkpLCBzZWxlY3RvcnNGYWN0b3J5KSwgc3RhdGVBZGFwdGVyKTtcclxufVxyXG4vLyBzcmMvbmFub2lkLnRzXHJcbnZhciB1cmxBbHBoYWJldCA9IFwiTW9kdWxlU3ltYmhhc093blByLTAxMjM0NTY3ODlBQkNERUZHSE5SVmZnY3RpVXZ6X0txWVRKa0x4cFpYSWpRV1wiO1xyXG52YXIgbmFub2lkID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgIGlmIChzaXplID09PSB2b2lkIDApIHsgc2l6ZSA9IDIxOyB9XHJcbiAgICB2YXIgaWQgPSBcIlwiO1xyXG4gICAgdmFyIGkgPSBzaXplO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlkICs9IHVybEFscGhhYmV0W01hdGgucmFuZG9tKCkgKiA2NCB8IDBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlkO1xyXG59O1xyXG4vLyBzcmMvY3JlYXRlQXN5bmNUaHVuay50c1xyXG52YXIgY29tbW9uUHJvcGVydGllcyA9IFtcclxuICAgIFwibmFtZVwiLFxyXG4gICAgXCJtZXNzYWdlXCIsXHJcbiAgICBcInN0YWNrXCIsXHJcbiAgICBcImNvZGVcIlxyXG5dO1xyXG52YXIgUmVqZWN0V2l0aFZhbHVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVqZWN0V2l0aFZhbHVlKHBheWxvYWQsIG1ldGEpIHtcclxuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xyXG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVqZWN0V2l0aFZhbHVlO1xyXG59KCkpO1xyXG52YXIgRnVsZmlsbFdpdGhNZXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRnVsZmlsbFdpdGhNZXRhKHBheWxvYWQsIG1ldGEpIHtcclxuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xyXG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRnVsZmlsbFdpdGhNZXRhO1xyXG59KCkpO1xyXG52YXIgbWluaVNlcmlhbGl6ZUVycm9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIHNpbXBsZUVycm9yID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb21tb25Qcm9wZXJ0aWVzXzEgPSBjb21tb25Qcm9wZXJ0aWVzOyBfaSA8IGNvbW1vblByb3BlcnRpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gY29tbW9uUHJvcGVydGllc18xW19pXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtwcm9wZXJ0eV0gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHNpbXBsZUVycm9yW3Byb3BlcnR5XSA9IHZhbHVlW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2ltcGxlRXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBtZXNzYWdlOiBTdHJpbmcodmFsdWUpIH07XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jVGh1bmsodHlwZVByZWZpeCwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpIHtcclxuICAgIHZhciBmdWxmaWxsZWQgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL2Z1bGZpbGxlZFwiLCBmdW5jdGlvbiAocGF5bG9hZCwgcmVxdWVzdElkLCBhcmcsIG1ldGEpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcclxuICAgICAgICBtZXRhOiBfX29ialNwcmVhZChfX29ialNwcmVhZCh7fSwgbWV0YSB8fCB7fSksIHtcclxuICAgICAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICByZXF1ZXN0U3RhdHVzOiBcImZ1bGZpbGxlZFwiXHJcbiAgICAgICAgfSlcclxuICAgIH0pOyB9KTtcclxuICAgIHZhciBwZW5kaW5nID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9wZW5kaW5nXCIsIGZ1bmN0aW9uIChyZXF1ZXN0SWQsIGFyZywgbWV0YSkgeyByZXR1cm4gKHtcclxuICAgICAgICBwYXlsb2FkOiB2b2lkIDAsXHJcbiAgICAgICAgbWV0YTogX19vYmpTcHJlYWQoX19vYmpTcHJlYWQoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcclxuICAgICAgICB9KVxyXG4gICAgfSk7IH0pO1xyXG4gICAgdmFyIHJlamVjdGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9yZWplY3RlZFwiLCBmdW5jdGlvbiAoZXJyb3IsIHJlcXVlc3RJZCwgYXJnLCBwYXlsb2FkLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXHJcbiAgICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxyXG4gICAgICAgIG1ldGE6IF9fb2JqU3ByZWFkKF9fb2JqU3ByZWFkKHt9LCBtZXRhIHx8IHt9KSwge1xyXG4gICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgIHJlamVjdGVkV2l0aFZhbHVlOiAhIXBheWxvYWQsXHJcbiAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6IFwicmVqZWN0ZWRcIixcclxuICAgICAgICAgICAgYWJvcnRlZDogKGVycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5uYW1lKSA9PT0gXCJBYm9ydEVycm9yXCIsXHJcbiAgICAgICAgICAgIGNvbmRpdGlvbjogKGVycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5uYW1lKSA9PT0gXCJDb25kaXRpb25FcnJvclwiXHJcbiAgICAgICAgfSlcclxuICAgIH0pOyB9KTtcclxuICAgIHZhciBkaXNwbGF5ZWRXYXJuaW5nID0gZmFsc2U7XHJcbiAgICB2YXIgQUMgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSBcInVuZGVmaW5lZFwiID8gQWJvcnRDb250cm9sbGVyIDogLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsID0ge1xyXG4gICAgICAgICAgICAgICAgYWJvcnRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbmFib3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkaXNwbGF5ZWRXYXJuaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheWVkV2FybmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVGhpcyBwbGF0Zm9ybSBkb2VzIG5vdCBpbXBsZW1lbnQgQWJvcnRDb250cm9sbGVyLiBcXG5JZiB5b3Ugd2FudCB0byB1c2UgdGhlIEFib3J0Q29udHJvbGxlciB0byByZWFjdCB0byBgYWJvcnRgIGV2ZW50cywgcGxlYXNlIGNvbnNpZGVyIGltcG9ydGluZyBhIHBvbHlmaWxsIGxpa2UgJ2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC9kaXN0L2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC1vbmx5Jy5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgfSgpKTtcclxuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RJZCA9ICgoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmlkR2VuZXJhdG9yKSAhPSBudWxsID8gX2EgOiBuYW5vaWQpKCk7XHJcbiAgICAgICAgICAgIHZhciBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQUMoKTtcclxuICAgICAgICAgICAgdmFyIGFib3J0UmVhc29uO1xyXG4gICAgICAgICAgICB2YXIgYWJvcnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7IHJldHVybiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZWplY3QoeyBuYW1lOiBcIkFib3J0RXJyb3JcIiwgbWVzc2FnZTogYWJvcnRSZWFzb24gfHwgXCJBYm9ydGVkXCIgfSk7IH0pOyB9KTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uO1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTIsIGZpbmFsQWN0aW9uLCBlcnJfMSwgc2tpcERpc3BhdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb25kaXRpb24gJiYgb3B0aW9ucy5jb25kaXRpb24oYXJnLCB7IGdldFN0YXRlOiBnZXRTdGF0ZSwgZXh0cmE6IGV4dHJhIH0pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkFib3J0ZWQgZHVlIHRvIGNvbmRpdGlvbiBjYWxsYmFjayByZXR1cm5pbmcgZmFsc2UuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gocGVuZGluZyhyZXF1ZXN0SWQsIGFyZywgKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0UGVuZGluZ01ldGEpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zLCB7IHJlcXVlc3RJZDogcmVxdWVzdElkLCBhcmc6IGFyZyB9LCB7IGdldFN0YXRlOiBnZXRTdGF0ZSwgZXh0cmE6IGV4dHJhIH0pKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0ZWRQcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHBheWxvYWRDcmVhdG9yKGFyZywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IGV4dHJhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgbWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlamVjdFdpdGhWYWx1ZSh2YWx1ZSwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsV2l0aFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIG1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdCwgcmVxdWVzdElkLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gZXJyXzEgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUgPyByZWplY3RlZChudWxsLCByZXF1ZXN0SWQsIGFyZywgZXJyXzEucGF5bG9hZCwgZXJyXzEubWV0YSkgOiByZWplY3RlZChlcnJfMSwgcmVxdWVzdElkLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBEaXNwYXRjaCA9IG9wdGlvbnMgJiYgIW9wdGlvbnMuZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24gJiYgcmVqZWN0ZWQubWF0Y2goZmluYWxBY3Rpb24pICYmIGZpbmFsQWN0aW9uLm1ldGEuY29uZGl0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2tpcERpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZpbmFsQWN0aW9uXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0oKTtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbWlzZSwge1xyXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGFib3J0LFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHVud3JhcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odW53cmFwUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjdGlvbkNyZWF0b3IsIHtcclxuICAgICAgICBwZW5kaW5nOiBwZW5kaW5nLFxyXG4gICAgICAgIHJlamVjdGVkOiByZWplY3RlZCxcclxuICAgICAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcclxuICAgICAgICB0eXBlUHJlZml4OiB0eXBlUHJlZml4XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XHJcbiAgICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcclxuICAgIH1cclxuICAgIGlmIChhY3Rpb24uZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XHJcbn1cclxuLy8gc3JjL3RzSGVscGVycy50c1xyXG52YXIgaGFzTWF0Y2hGdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICByZXR1cm4gdiAmJiB0eXBlb2Ygdi5tYXRjaCA9PT0gXCJmdW5jdGlvblwiO1xyXG59O1xyXG4vLyBzcmMvbWF0Y2hlcnMudHNcclxudmFyIG1hdGNoZXMgPSBmdW5jdGlvbiAobWF0Y2hlciwgYWN0aW9uKSB7XHJcbiAgICBpZiAoaGFzTWF0Y2hGdW5jdGlvbihtYXRjaGVyKSkge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKGFjdGlvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBpc0FueU9mKCkge1xyXG4gICAgdmFyIG1hdGNoZXJzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIG1hdGNoZXJzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVycy5zb21lKGZ1bmN0aW9uIChtYXRjaGVyKSB7IHJldHVybiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbik7IH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc0FsbE9mKCkge1xyXG4gICAgdmFyIG1hdGNoZXJzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIG1hdGNoZXJzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVycy5ldmVyeShmdW5jdGlvbiAobWF0Y2hlcikgeyByZXR1cm4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pOyB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCB2YWxpZFN0YXR1cykge1xyXG4gICAgaWYgKCFhY3Rpb24gfHwgIWFjdGlvbi5tZXRhKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBoYXNWYWxpZFJlcXVlc3RJZCA9IHR5cGVvZiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQgPT09IFwic3RyaW5nXCI7XHJcbiAgICB2YXIgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xyXG4gICAgcmV0dXJuIGhhc1ZhbGlkUmVxdWVzdElkICYmIGhhc1ZhbGlkUmVxdWVzdFN0YXR1cztcclxufVxyXG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtBcnJheShhKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBcInBlbmRpbmdcIiBpbiBhWzBdICYmIFwiZnVsZmlsbGVkXCIgaW4gYVswXSAmJiBcInJlamVjdGVkXCIgaW4gYVswXTtcclxufVxyXG5mdW5jdGlvbiBpc1BlbmRpbmcoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJwZW5kaW5nXCJdKTsgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUGVuZGluZygpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKGZ1bmN0aW9uIChhc3luY1RodW5rKSB7IHJldHVybiBhc3luY1RodW5rLnBlbmRpbmc7IH0pO1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mLmFwcGx5KHZvaWQgMCwgbWF0Y2hlcnMpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNSZWplY3RlZCgpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInJlamVjdGVkXCJdKTsgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVqZWN0ZWQoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcChmdW5jdGlvbiAoYXN5bmNUaHVuaykgeyByZXR1cm4gYXN5bmNUaHVuay5yZWplY3RlZDsgfSk7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1JlamVjdGVkV2l0aFZhbHVlKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgaGFzRmxhZyA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gYWN0aW9uICYmIGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlO1xyXG4gICAgfTtcclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkLmFwcGx5KHZvaWQgMCwgYXN5bmNUaHVua3MpLCBoYXNGbGFnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1JlamVjdGVkV2l0aFZhbHVlKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkLmFwcGx5KHZvaWQgMCwgYXN5bmNUaHVua3MpLCBoYXNGbGFnKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wiZnVsZmlsbGVkXCJdKTsgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzRnVsZmlsbGVkKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoZnVuY3Rpb24gKGFzeW5jVGh1bmspIHsgcmV0dXJuIGFzeW5jVGh1bmsuZnVsZmlsbGVkOyB9KTtcclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZi5hcHBseSh2b2lkIDAsIG1hdGNoZXJzKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbigpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIiwgXCJmdWxmaWxsZWRcIiwgXCJyZWplY3RlZFwiXSk7IH07XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xyXG4gICAgICAgIHJldHVybiBpc0FzeW5jVGh1bmtBY3Rpb24oKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBtYXRjaGVycyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYXN5bmNUaHVua3NfMSA9IGFzeW5jVGh1bmtzOyBfaSA8IGFzeW5jVGh1bmtzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhc3luY1RodW5rID0gYXN5bmNUaHVua3NfMVtfaV07XHJcbiAgICAgICAgICAgIG1hdGNoZXJzLnB1c2goYXN5bmNUaHVuay5wZW5kaW5nLCBhc3luY1RodW5rLnJlamVjdGVkLCBhc3luY1RodW5rLmZ1bGZpbGxlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mLmFwcGx5KHZvaWQgMCwgbWF0Y2hlcnMpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IHsgTWlkZGxld2FyZUFycmF5LCBjb25maWd1cmVTdG9yZSwgY3JlYXRlQWN0aW9uLCBjcmVhdGVBc3luY1RodW5rLCBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciwgY3JlYXRlRW50aXR5QWRhcHRlciwgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLCBkZWZhdWx0MiBhcyBjcmVhdGVOZXh0U3RhdGUsIGNyZWF0ZVJlZHVjZXIsIGNyZWF0ZVNlbGVjdG9yMiBhcyBjcmVhdGVTZWxlY3RvciwgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVTbGljZSwgY3VycmVudDIgYXMgY3VycmVudCwgZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlLCBmcmVlemUsIGdldERlZmF1bHRNaWRkbGV3YXJlLCBnZXRUeXBlLCBpc0FsbE9mLCBpc0FueU9mLCBpc0FzeW5jVGh1bmtBY3Rpb24sIGlzRHJhZnQ0IGFzIGlzRHJhZnQsIGlzRnVsZmlsbGVkLCBpc0ltbXV0YWJsZURlZmF1bHQsIGlzUGVuZGluZywgaXNQbGFpbiwgaXNQbGFpbk9iamVjdCwgaXNSZWplY3RlZCwgaXNSZWplY3RlZFdpdGhWYWx1ZSwgbWluaVNlcmlhbGl6ZUVycm9yLCBuYW5vaWQsIG9yaWdpbmFsLCB1bndyYXBSZXN1bHQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcCIsIi8qKlxuICogUmVhY3QgUm91dGVyIERPTSB2Ni4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlTGF5b3V0RWZmZWN0LCBjcmVhdGVFbGVtZW50LCBmb3J3YXJkUmVmLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlUGF0aCB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0IHsgUm91dGVyLCB1c2VIcmVmLCB1c2VMb2NhdGlvbiwgdXNlUmVzb2x2ZWRQYXRoLCB1c2VOYXZpZ2F0ZSB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5leHBvcnQgeyBNZW1vcnlSb3V0ZXIsIE5hdmlnYXRlLCBPdXRsZXQsIFJvdXRlLCBSb3V0ZXIsIFJvdXRlcywgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCwgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LCBVTlNBRkVfUm91dGVDb250ZXh0LCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sIGdlbmVyYXRlUGF0aCwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgcmVuZGVyTWF0Y2hlcywgcmVzb2x2ZVBhdGgsIHVzZUhyZWYsIHVzZUluUm91dGVyQ29udGV4dCwgdXNlTG9jYXRpb24sIHVzZU1hdGNoLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJvbkNsaWNrXCIsIFwicmVsb2FkRG9jdW1lbnRcIiwgXCJyZXBsYWNlXCIsIFwic3RhdGVcIiwgXCJ0YXJnZXRcIiwgXCJ0b1wiXSxcbiAgICAgIF9leGNsdWRlZDIgPSBbXCJhcmlhLWN1cnJlbnRcIiwgXCJjYXNlU2Vuc2l0aXZlXCIsIFwiY2xhc3NOYW1lXCIsIFwiZW5kXCIsIFwic3R5bGVcIiwgXCJ0b1wiLCBcImNoaWxkcmVuXCJdO1xuXG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCBSb3V0ZXIhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ09NUE9ORU5UU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICovXG5mdW5jdGlvbiBCcm93c2VyUm91dGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICB3aW5kb3dcbiAgfSA9IF9yZWY7XG4gIGxldCBoaXN0b3J5UmVmID0gdXNlUmVmKCk7XG5cbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnkoe1xuICAgICAgd2luZG93XG4gICAgfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICB9KTtcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFN0b3JlcyB0aGUgbG9jYXRpb24gaW4gdGhlIGhhc2hcbiAqIHBvcnRpb24gb2YgdGhlIFVSTCBzbyBpdCBpcyBub3Qgc2VudCB0byB0aGUgc2VydmVyLlxuICovXG5mdW5jdGlvbiBIYXNoUm91dGVyKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgd2luZG93XG4gIH0gPSBfcmVmMjtcbiAgbGV0IGhpc3RvcnlSZWYgPSB1c2VSZWYoKTtcblxuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVIYXNoSGlzdG9yeSh7XG4gICAgICB3aW5kb3dcbiAgICB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gIH0pO1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IGFjY2VwdHMgYSBwcmUtaW5zdGFudGlhdGVkIGhpc3Rvcnkgb2JqZWN0LiBJdCdzIGltcG9ydGFudFxuICogdG8gbm90ZSB0aGF0IHVzaW5nIHlvdXIgb3duIGhpc3Rvcnkgb2JqZWN0IGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBhbmQgbWF5IGFkZFxuICogdHdvIHZlcnNpb25zIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdG8geW91ciBidW5kbGVzIHVubGVzcyB5b3UgdXNlIHRoZSBzYW1lXG4gKiB2ZXJzaW9uIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdGhhdCBSZWFjdCBSb3V0ZXIgdXNlcyBpbnRlcm5hbGx5LlxuICovXG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKF9yZWYzKSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgaGlzdG9yeVxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBIaXN0b3J5Um91dGVyLmRpc3BsYXlOYW1lID0gXCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyXCI7XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5jb25zdCBMaW5rID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gTGlua1dpdGhSZWYoX3JlZjQsIHJlZikge1xuICBsZXQge1xuICAgIG9uQ2xpY2ssXG4gICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgcmVwbGFjZSA9IGZhbHNlLFxuICAgIHN0YXRlLFxuICAgIHRhcmdldCxcbiAgICB0b1xuICB9ID0gX3JlZjQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjQsIF9leGNsdWRlZCk7XG5cbiAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvKTtcbiAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICByZXBsYWNlLFxuICAgIHN0YXRlLFxuICAgIHRhcmdldFxuICB9KTtcblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmIChvbkNsaWNrKSBvbkNsaWNrKGV2ZW50KTtcblxuICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJiAhcmVsb2FkRG9jdW1lbnQpIHtcbiAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1oYXMtY29udGVudFxuICAgIGNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICBocmVmOiBocmVmLFxuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICByZWY6IHJlZixcbiAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfSkpXG4gICk7XG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBMaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG59XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbmNvbnN0IE5hdkxpbmsgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihmdW5jdGlvbiBOYXZMaW5rV2l0aFJlZihfcmVmNSwgcmVmKSB7XG4gIGxldCB7XG4gICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRQcm9wID0gXCJwYWdlXCIsXG4gICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lUHJvcCA9IFwiXCIsXG4gICAgZW5kID0gZmFsc2UsXG4gICAgc3R5bGU6IHN0eWxlUHJvcCxcbiAgICB0byxcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjUsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjUsIF9leGNsdWRlZDIpO1xuXG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvKTtcbiAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgbGV0IHRvUGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lO1xuXG4gIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGxldCBpc0FjdGl2ZSA9IGxvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHwgIWVuZCAmJiBsb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiYgbG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIjtcbiAgbGV0IGFyaWFDdXJyZW50ID0gaXNBY3RpdmUgPyBhcmlhQ3VycmVudFByb3AgOiB1bmRlZmluZWQ7XG4gIGxldCBjbGFzc05hbWU7XG5cbiAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVQcm9wKHtcbiAgICAgIGlzQWN0aXZlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGNsYXNzTmFtZSBwcm9wIGlzIG5vdCBhIGZ1bmN0aW9uLCB3ZSB1c2UgYSBkZWZhdWx0IGBhY3RpdmVgXG4gICAgLy8gY2xhc3MgZm9yIDxOYXZMaW5rIC8+cyB0aGF0IGFyZSBhY3RpdmUuIEluIHY1IGBhY3RpdmVgIHdhcyB0aGUgZGVmYXVsdFxuICAgIC8vIHZhbHVlIGZvciBgYWN0aXZlQ2xhc3NOYW1lYCwgYnV0IHdlIGFyZSByZW1vdmluZyB0aGF0IEFQSSBhbmQgY2FuIHN0aWxsXG4gICAgLy8gdXNlIHRoZSBvbGQgZGVmYXVsdCBiZWhhdmlvciBmb3IgYSBjbGVhbmVyIHVwZ3JhZGUgcGF0aCBhbmQga2VlcCB0aGVcbiAgICAvLyBzaW1wbGUgc3R5bGluZyBydWxlcyB3b3JraW5nIGFzIHRoZXkgY3VycmVudGx5IGRvLlxuICAgIGNsYXNzTmFtZSA9IFtjbGFzc05hbWVQcm9wLCBpc0FjdGl2ZSA/IFwiYWN0aXZlXCIgOiBudWxsXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gIH1cblxuICBsZXQgc3R5bGUgPSB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3Aoe1xuICAgIGlzQWN0aXZlXG4gIH0pIDogc3R5bGVQcm9wO1xuICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoTGluaywgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICByZWY6IHJlZixcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgdG86IHRvXG4gIH0pLCB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKHtcbiAgICBpc0FjdGl2ZVxuICB9KSA6IGNoaWxkcmVuKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhPT0tTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGNsaWNrIGJlaGF2aW9yIGZvciByb3V0ZXIgYDxMaW5rPmAgY29tcG9uZW50cy4gVGhpcyBpcyB1c2VmdWwgaWZcbiAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBjdXN0b20gYDxMaW5rPmAgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGNsaWNrIGJlaGF2aW9yIHdlXG4gKiB1c2UgaW4gb3VyIGV4cG9ydGVkIGA8TGluaz5gLlxuICovXG5cblxuZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcih0bywgX3RlbXApIHtcbiAgbGV0IHtcbiAgICB0YXJnZXQsXG4gICAgcmVwbGFjZTogcmVwbGFjZVByb3AsXG4gICAgc3RhdGVcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0byk7XG4gIHJldHVybiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAoIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmIC8vIExldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIElmIHRoZSBVUkwgaGFzbid0IGNoYW5nZWQsIGEgcmVndWxhciA8YT4gd2lsbCBkbyBhIHJlcGxhY2UgaW5zdGVhZCBvZlxuICAgICAgLy8gYSBwdXNoLCBzbyBkbyB0aGUgc2FtZSBoZXJlLlxuXG4gICAgICBsZXQgcmVwbGFjZSA9ICEhcmVwbGFjZVByb3AgfHwgY3JlYXRlUGF0aChsb2NhdGlvbikgPT09IGNyZWF0ZVBhdGgocGF0aCk7XG4gICAgICBuYXZpZ2F0ZSh0bywge1xuICAgICAgICByZXBsYWNlLFxuICAgICAgICBzdGF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbbG9jYXRpb24sIG5hdmlnYXRlLCBwYXRoLCByZXBsYWNlUHJvcCwgc3RhdGUsIHRhcmdldCwgdG9dKTtcbn1cbi8qKlxuICogQSBjb252ZW5pZW50IHdyYXBwZXIgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgc2VhcmNoIHBhcmFtZXRlcnMgdmlhIHRoZVxuICogVVJMU2VhcmNoUGFyYW1zIGludGVyZmFjZS5cbiAqL1xuXG5mdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyh0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLCBcIllvdSBjYW5ub3QgdXNlIHRoZSBgdXNlU2VhcmNoUGFyYW1zYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IFwiICsgXCJzdXBwb3J0IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IEludGVybmV0IFwiICsgXCJFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBcIiArIFwiaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuXCIgKyBcIklmIHlvdSdyZSB1bnN1cmUgaG93IHRvIGxvYWQgcG9seWZpbGxzLCB3ZSByZWNvbW1lbmQgeW91IGNoZWNrIG91dCBcIiArIFwiaHR0cHM6Ly9wb2x5ZmlsbC5pby92My8gd2hpY2ggcHJvdmlkZXMgc29tZSByZWNvbW1lbmRhdGlvbnMgYWJvdXQgaG93IFwiICsgXCJ0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgXCIgKyBcInVzZXIuXCIpIDogdm9pZCAwO1xuICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IHVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKTtcblxuICAgIGZvciAobGV0IGtleSBvZiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQua2V5cygpKSB7XG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQuZ2V0QWxsKGtleSkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbiAgfSwgW2xvY2F0aW9uLnNlYXJjaF0pO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gdXNlQ2FsbGJhY2soKG5leHRJbml0LCBuYXZpZ2F0ZU9wdGlvbnMpID0+IHtcbiAgICBuYXZpZ2F0ZShcIj9cIiArIGNyZWF0ZVNlYXJjaFBhcmFtcyhuZXh0SW5pdCksIG5hdmlnYXRlT3B0aW9ucyk7XG4gIH0sIFtuYXZpZ2F0ZV0pO1xuICByZXR1cm4gW3NlYXJjaFBhcmFtcywgc2V0U2VhcmNoUGFyYW1zXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoaW5pdCkge1xuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdCA9IFwiXCI7XG4gIH1cblxuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyh0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGluaXQpIHx8IGluaXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBpbml0IDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vLCBrZXkpID0+IHtcbiAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgcmV0dXJuIG1lbW8uY29uY2F0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHYgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV0pO1xuICB9LCBbXSkpO1xufVxuXG5leHBvcnQgeyBCcm93c2VyUm91dGVyLCBIYXNoUm91dGVyLCBMaW5rLCBOYXZMaW5rLCBjcmVhdGVTZWFyY2hQYXJhbXMsIEhpc3RvcnlSb3V0ZXIgYXMgdW5zdGFibGVfSGlzdG9yeVJvdXRlciwgdXNlTGlua0NsaWNrSGFuZGxlciwgdXNlU2VhcmNoUGFyYW1zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIi8qKlxuICogUmVhY3QgUm91dGVyIHY2LjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VMYXlvdXRFZmZlY3QsIGNyZWF0ZUVsZW1lbnQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIENoaWxkcmVuLCBpc1ZhbGlkRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVNZW1vcnlIaXN0b3J5LCBBY3Rpb24sIHBhcnNlUGF0aCB9IGZyb20gJ2hpc3RvcnknO1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gd2FybmluZyhjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgUm91dGVyIVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuY29uc3QgYWxyZWFkeVdhcm5lZCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuaW5nT25jZShrZXksIGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICBhbHJlYWR5V2FybmVkW2tleV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICB9XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENPTlRFWFRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIE5hdmlnYXRvciBpcyBhIFwibG9jYXRpb24gY2hhbmdlclwiOyBpdCdzIGhvdyB5b3UgZ2V0IHRvIGRpZmZlcmVudCBsb2NhdGlvbnMuXG4gKlxuICogRXZlcnkgaGlzdG9yeSBpbnN0YW5jZSBjb25mb3JtcyB0byB0aGUgTmF2aWdhdG9yIGludGVyZmFjZSwgYnV0IHRoZVxuICogZGlzdGluY3Rpb24gaXMgdXNlZnVsIHByaW1hcmlseSB3aGVuIGl0IGNvbWVzIHRvIHRoZSBsb3ctbGV2ZWwgPFJvdXRlcj4gQVBJXG4gKiB3aGVyZSBib3RoIHRoZSBsb2NhdGlvbiBhbmQgYSBuYXZpZ2F0b3IgbXVzdCBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGluIG9yZGVyXG4gKiB0byBhdm9pZCBcInRlYXJpbmdcIiB0aGF0IG1heSBvY2N1ciBpbiBhIHN1c3BlbnNlLWVuYWJsZWQgYXBwIGlmIHRoZSBhY3Rpb25cbiAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cbiAqL1xuXG5cbmNvbnN0IE5hdmlnYXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbn1cblxuY29uc3QgTG9jYXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xufVxuXG5jb25zdCBSb3V0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh7XG4gIG91dGxldDogbnVsbCxcbiAgbWF0Y2hlczogW11cbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ09NUE9ORU5UU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8qKlxuICogQSA8Um91dGVyPiB0aGF0IHN0b3JlcyBhbGwgZW50cmllcyBpbiBtZW1vcnkuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtZW1vcnlyb3V0ZXJcbiAqL1xuZnVuY3Rpb24gTWVtb3J5Um91dGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBpbml0aWFsRW50cmllcyxcbiAgICBpbml0aWFsSW5kZXhcbiAgfSA9IF9yZWY7XG4gIGxldCBoaXN0b3J5UmVmID0gdXNlUmVmKCk7XG5cbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleFxuICAgIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBOb3RlOiBUaGlzIEFQSSBpcyBtb3N0bHkgdXNlZnVsIGluIFJlYWN0LkNvbXBvbmVudCBzdWJjbGFzc2VzIHRoYXQgYXJlIG5vdFxuICogYWJsZSB0byB1c2UgaG9va3MuIEluIGZ1bmN0aW9uYWwgY29tcG9uZW50cywgd2UgcmVjb21tZW5kIHlvdSB1c2UgdGhlXG4gKiBgdXNlTmF2aWdhdGVgIGhvb2sgaW5zdGVhZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI25hdmlnYXRlXG4gKi9cbmZ1bmN0aW9uIE5hdmlnYXRlKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgdG8sXG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZVxuICB9ID0gX3JlZjI7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2ZcbiAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCI8TmF2aWdhdGU+IG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghdXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljLCBcIjxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gXCIgKyBcIlRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBcIiArIFwib25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuXCIpIDogdm9pZCAwO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG5hdmlnYXRlKHRvLCB7XG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGNoaWxkIHJvdXRlJ3MgZWxlbWVudCwgaWYgdGhlcmUgaXMgb25lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjb3V0bGV0XG4gKi9cbmZ1bmN0aW9uIE91dGxldChwcm9wcykge1xuICByZXR1cm4gdXNlT3V0bGV0KHByb3BzLmNvbnRleHQpO1xufVxuXG4vKipcbiAqIERlY2xhcmVzIGFuIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYXQgYSBjZXJ0YWluIFVSTCBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcm91dGVcbiAqL1xuZnVuY3Rpb24gUm91dGUoX3Byb3BzKSB7XG4gICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQSA8Um91dGU+IGlzIG9ubHkgZXZlciB0byBiZSB1c2VkIGFzIHRoZSBjaGlsZCBvZiA8Um91dGVzPiBlbGVtZW50LCBcIiArIFwibmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LlwiKSA6IGludmFyaWFudChmYWxzZSkgO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGxvY2F0aW9uIGNvbnRleHQgZm9yIHRoZSByZXN0IG9mIHRoZSBhcHAuXG4gKlxuICogTm90ZTogWW91IHVzdWFsbHkgd29uJ3QgcmVuZGVyIGEgPFJvdXRlcj4gZGlyZWN0bHkuIEluc3RlYWQsIHlvdSdsbCByZW5kZXIgYVxuICogcm91dGVyIHRoYXQgaXMgbW9yZSBzcGVjaWZpYyB0byB5b3VyIGVudmlyb25tZW50IHN1Y2ggYXMgYSA8QnJvd3NlclJvdXRlcj5cbiAqIGluIHdlYiBicm93c2VycyBvciBhIDxTdGF0aWNSb3V0ZXI+IGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcm91dGVyXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcihfcmVmMykge1xuICBsZXQge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZVByb3AgPSBcIi9cIixcbiAgICBjaGlsZHJlbiA9IG51bGwsXG4gICAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCxcbiAgICBuYXZpZ2F0aW9uVHlwZSA9IEFjdGlvbi5Qb3AsXG4gICAgbmF2aWdhdG9yLFxuICAgIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlXG4gIH0gPSBfcmVmMztcbiAgISF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LlwiICsgXCIgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IGJhc2VuYW1lID0gbm9ybWFsaXplUGF0aG5hbWUoYmFzZW5hbWVQcm9wKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGJhc2VuYW1lLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3BcbiAgfSksIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXSk7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuXG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIlxuICB9ID0gbG9jYXRpb25Qcm9wO1xuICBsZXQgbG9jYXRpb24gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcblxuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2gsXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleVxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleV0pO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGxvY2F0aW9uICE9IG51bGwsIFwiPFJvdXRlciBiYXNlbmFtZT1cXFwiXCIgKyBiYXNlbmFtZSArIFwiXFxcIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBcIiArIChcIlxcXCJcIiArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCArIFwiXFxcIiBiZWNhdXNlIGl0IGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIFwiKSArIFwiYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuXCIpIDogdm9pZCAwO1xuXG4gIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbmF2aWdhdGlvbkNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHZhbHVlOiB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlXG4gICAgfVxuICB9KSk7XG59XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGEgbmVzdGVkIHRyZWUgb2YgPFJvdXRlPiBlbGVtZW50cyB0aGF0IHJlbmRlcnMgdGhlIGJyYW5jaFxuICogdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNyb3V0ZXNcbiAqL1xuZnVuY3Rpb24gUm91dGVzKF9yZWY0KSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgbG9jYXRpb25cbiAgfSA9IF9yZWY0O1xuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSE9PS1Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZ1xuICogY3VzdG9tIGxpbmtzIHRoYXQgYXJlIGFsc28gYWNjZXNzaWJsZSBhbmQgcHJlc2VydmUgcmlnaHQtY2xpY2sgYmVoYXZpb3IuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VocmVmXG4gKi9cblxuZnVuY3Rpb24gdXNlSHJlZih0bykge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlSHJlZigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IHVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIGhhc2gsXG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoXG4gIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8pO1xuICBsZXQgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZTtcblxuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgbGV0IHRvUGF0aG5hbWUgPSBnZXRUb1BhdGhuYW1lKHRvKTtcbiAgICBsZXQgZW5kc1dpdGhTbGFzaCA9IHRvUGF0aG5hbWUgIT0gbnVsbCAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgICBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lICsgKGVuZHNXaXRoU2xhc2ggPyBcIi9cIiA6IFwiXCIpIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7XG4gICAgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoXG4gIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGEgPFJvdXRlcj4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VpbnJvdXRlcmNvbnRleHRcbiAqL1xuXG5mdW5jdGlvbiB1c2VJblJvdXRlckNvbnRleHQoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2Vsb2NhdGlvblxuICovXG5cbmZ1bmN0aW9uIHVzZUxvY2F0aW9uKCkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiB1c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGFjdGlvbiB3aGljaCBkZXNjcmliZXMgaG93IHRoZSByb3V0ZXIgY2FtZSB0b1xuICogdGhlIGN1cnJlbnQgbG9jYXRpb24sIGVpdGhlciBieSBhIHBvcCwgcHVzaCwgb3IgcmVwbGFjZSBvbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW5hdmlnYXRpb250eXBlXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIFVSTCBmb3IgdGhlIGdpdmVuIFwidG9cIiB2YWx1ZSBtYXRjaGVzIHRoZSBjdXJyZW50IFVSTC5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IFwiYWN0aXZlXCIgc3RhdGUsIGUuZy5cbiAqIDxOYXZMaW5rPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW1hdGNoXG4gKi9cblxuZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlTWF0Y2goKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgcGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IG1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSksIFtwYXRobmFtZSwgcGF0dGVybl0pO1xufVxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGltcGVyYXRpdmUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgbG9jYXRpb24uIFVzZWQgYnkgPExpbms+cywgYnV0XG4gKiBtYXkgYWxzbyBiZSB1c2VkIGJ5IG90aGVyIGVsZW1lbnRzIHRvIGNoYW5nZSB0aGUgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VuYXZpZ2F0ZVxuICovXG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIG5hdmlnYXRvclxuICB9ID0gdXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gdXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lXG4gIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkobWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKSk7XG4gIGxldCBhY3RpdmVSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0bywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBcIllvdSBzaG91bGQgY2FsbCBuYXZpZ2F0ZSgpIGluIGEgUmVhY3QudXNlRWZmZWN0KCksIG5vdCB3aGVuIFwiICsgXCJ5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5cIikgOiB2b2lkIDA7XG4gICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbmF2aWdhdG9yLmdvKHRvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IHJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lKTtcblxuICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgIHBhdGgucGF0aG5hbWUgPSBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgfVxuXG4gICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkocGF0aCwgb3B0aW9ucy5zdGF0ZSk7XG4gIH0sIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWVdKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxuY29uc3QgT3V0bGV0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0IChpZiBwcm92aWRlZCkgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VvdXRsZXRjb250ZXh0XG4gKi9cblxuZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LiBVc2VkIGludGVybmFsbHkgYnkgPE91dGxldD4gdG8gcmVuZGVyIGNoaWxkIHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW91dGxldFxuICovXG5cbmZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0KSB7XG4gIGxldCBvdXRsZXQgPSB1c2VDb250ZXh0KFJvdXRlQ29udGV4dCkub3V0bGV0O1xuXG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoT3V0bGV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRcbiAgICB9LCBvdXRsZXQpO1xuICB9XG5cbiAgcmV0dXJuIG91dGxldDtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIHBhcmFtcyBmcm9tIHRoZSBjdXJyZW50XG4gKiBVUkwgdGhhdCB3ZXJlIG1hdGNoZWQgYnkgdGhlIHJvdXRlIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VwYXJhbXNcbiAqL1xuXG5mdW5jdGlvbiB1c2VQYXJhbXMoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gdXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xufVxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aG5hbWUgb2YgdGhlIGdpdmVuIGB0b2AgdmFsdWUgYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZXJlc29sdmVkcGF0aFxuICovXG5cbmZ1bmN0aW9uIHVzZVJlc29sdmVkUGF0aCh0bykge1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IHVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KG1hdGNoZXMubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSkpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSksIFt0bywgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lXSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgb2YgdGhlIHJvdXRlIHRoYXQgbWF0Y2hlZCB0aGUgY3VycmVudCBsb2NhdGlvbiwgcHJlcGFyZWRcbiAqIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dCB0byByZW5kZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgcm91dGUgdHJlZS4gUm91dGVcbiAqIGVsZW1lbnRzIGluIHRoZSB0cmVlIG11c3QgcmVuZGVyIGFuIDxPdXRsZXQ+IHRvIHJlbmRlciB0aGVpciBjaGlsZCByb3V0ZSdzXG4gKiBlbGVtZW50LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlcm91dGVzXG4gKi9cblxuZnVuY3Rpb24gdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcpIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzXG4gIH0gPSB1c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAvLyBZb3Ugd29uJ3QgZ2V0IGEgd2FybmluZyBhYm91dCAyIGRpZmZlcmVudCA8Um91dGVzPiB1bmRlciBhIDxSb3V0ZT5cbiAgICAvLyB3aXRob3V0IGEgdHJhaWxpbmcgKiwgYnV0IHRoaXMgaXMgYSBiZXN0LWVmZm9ydCB3YXJuaW5nIGFueXdheSBzaW5jZSB3ZVxuICAgIC8vIGNhbm5vdCBldmVuIGdpdmUgdGhlIHdhcm5pbmcgdW5sZXNzIHRoZXkgbGFuZCBhdCB0aGUgcGFyZW50IHJvdXRlLlxuICAgIC8vXG4gICAgLy8gRXhhbXBsZTpcbiAgICAvL1xuICAgIC8vIDxSb3V0ZXM+XG4gICAgLy8gICB7LyogVGhpcyByb3V0ZSBwYXRoIE1VU1QgZW5kIHdpdGggLyogYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyAgICAgICBpdCB3aWxsIG5ldmVyIG1hdGNoIC9ibG9nL3Bvc3QvMTIzICovfVxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nXCIgZWxlbWVudD17PEJsb2cgLz59IC8+XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2cvZmVlZFwiIGVsZW1lbnQ9ezxCbG9nRmVlZCAvPn0gLz5cbiAgICAvLyA8L1JvdXRlcz5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIEJsb2coKSB7XG4gICAgLy8gICByZXR1cm4gKFxuICAgIC8vICAgICA8Um91dGVzPlxuICAgIC8vICAgICAgIDxSb3V0ZSBwYXRoPVwicG9zdC86aWRcIiBlbGVtZW50PXs8UG9zdCAvPn0gLz5cbiAgICAvLyAgICAgPC9Sb3V0ZXM+XG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgICBsZXQgcGFyZW50UGF0aCA9IHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGggfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShwYXJlbnRQYXRobmFtZSwgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLCBcIllvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgYHVzZVJvdXRlcygpYCkgYXQgXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRobmFtZSArIFwiXFxcIiAodW5kZXIgPFJvdXRlIHBhdGg9XFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIj4pIGJ1dCB0aGUgXCIpICsgXCJwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXFxcIipcXFwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBcIiArIFwiZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgXCIgKyBcInJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cXG5cXG5cIiArIChcIlBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiPiB0byA8Um91dGUgXCIpICsgKFwicGF0aD1cXFwiXCIgKyAocGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IHBhcmVudFBhdGggKyBcIi8qXCIpICsgXCJcXFwiPi5cIikpO1xuICB9XG5cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbG9jYXRpb247XG5cbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgdmFyIF9wYXJzZWRMb2NhdGlvbkFyZyRwYTtcblxuICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgICAhKHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHwgKChfcGFyc2VkTG9jYXRpb25BcmckcGEgPSBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJzZWRMb2NhdGlvbkFyZyRwYS5zdGFydHNXaXRoKHBhcmVudFBhdGhuYW1lQmFzZSkpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIGA8Um91dGVzIGxvY2F0aW9uPmAgb3IgYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKWAsIFwiICsgXCJ0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgXCIgKyAoXCJtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFxcXCJcIiArIHBhcmVudFBhdGhuYW1lQmFzZSArIFwiXFxcIiBcIikgKyAoXCJidXQgcGF0aG5hbWUgXFxcIlwiICsgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWUgKyBcIlxcXCIgd2FzIGdpdmVuIGluIHRoZSBgbG9jYXRpb25gIHByb3AuXCIpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cblxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiA/IHBhdGhuYW1lIDogcGF0aG5hbWUuc2xpY2UocGFyZW50UGF0aG5hbWVCYXNlLmxlbmd0aCkgfHwgXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7XG4gICAgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lXG4gIH0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCwgXCJObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcXFwiXCIgKyBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2ggKyBcIlxcXCIgXCIpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcobWF0Y2hlcyA9PSBudWxsIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQsIFwiTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQuIFwiICsgXCJUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIG51bGwgdmFsdWUgYnkgZGVmYXVsdCByZXN1bHRpbmcgaW4gYW4gXFxcImVtcHR5XFxcIiBwYWdlLlwiKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzICYmIG1hdGNoZXMubWFwKG1hdGNoID0+IE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgIHBhdGhuYW1lQmFzZTogbWF0Y2gucGF0aG5hbWVCYXNlID09PSBcIi9cIiA/IHBhcmVudFBhdGhuYW1lQmFzZSA6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICB9KSksIHBhcmVudE1hdGNoZXMpO1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZXMgYSByb3V0ZSBjb25maWcgZnJvbSBhIFJlYWN0IFwiY2hpbGRyZW5cIiBvYmplY3QsIHdoaWNoIGlzIHVzdWFsbHlcbiAqIGVpdGhlciBhIGA8Um91dGU+YCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZW0uIFVzZWQgaW50ZXJuYWxseSBieVxuICogYDxSb3V0ZXM+YCB0byBjcmVhdGUgYSByb3V0ZSBjb25maWcgZnJvbSBpdHMgY2hpbGRyZW4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNjcmVhdGVyb3V0ZXNmcm9tY2hpbGRyZW5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgbGV0IHJvdXRlcyA9IFtdO1xuICBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBlbGVtZW50ID0+IHtcbiAgICBpZiAoISAvKiNfX1BVUkVfXyovaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIElnbm9yZSBub24tZWxlbWVudHMuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBtb3JlIGVhc2lseSBpbmxpbmVcbiAgICAgIC8vIGNvbmRpdGlvbmFscyBpbiB0aGVpciByb3V0ZSBjb25maWcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIFRyYW5zcGFyZW50bHkgc3VwcG9ydCBSZWFjdC5GcmFnbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgcm91dGVzLnB1c2guYXBwbHkocm91dGVzLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICEoZWxlbWVudC50eXBlID09PSBSb3V0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiW1wiICsgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZSkgKyBcIl0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgbGV0IHJvdXRlID0ge1xuICAgICAgY2FzZVNlbnNpdGl2ZTogZWxlbWVudC5wcm9wcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGhcbiAgICB9O1xuXG4gICAgaWYgKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIHJvdXRlLmNoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfSk7XG4gIHJldHVybiByb3V0ZXM7XG59XG4vKipcbiAqIFRoZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXJzZWQgZnJvbSB0aGUgVVJMIHBhdGguXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNnZW5lcmF0ZXBhdGhcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKHBhdGgsIHBhcmFtcykge1xuICBpZiAocGFyYW1zID09PSB2b2lkIDApIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBwYXRoLnJlcGxhY2UoLzooXFx3KykvZywgKF8sIGtleSkgPT4ge1xuICAgICEocGFyYW1zW2tleV0gIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiTWlzc2luZyBcXFwiOlwiICsga2V5ICsgXCJcXFwiIHBhcmFtXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gcGFyYW1zW2tleV07XG4gIH0pLnJlcGxhY2UoL1xcLypcXCokLywgXyA9PiBwYXJhbXNbXCIqXCJdID09IG51bGwgPyBcIlwiIDogcGFyYW1zW1wiKlwiXS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKSk7XG59XG4vKipcbiAqIEEgUm91dGVNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIHJvdXRlIG1hdGNoZWQgYSBVUkwuXG4gKi9cblxuLyoqXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI21hdGNocm91dGVzXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcsIGJhc2VuYW1lKSB7XG4gIGlmIChiYXNlbmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgYmFzZW5hbWUgPSBcIi9cIjtcbiAgfVxuXG4gIGxldCBsb2NhdGlvbiA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgbGV0IHBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIiwgYmFzZW5hbWUpO1xuXG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgYnJhbmNoZXMgPSBmbGF0dGVuUm91dGVzKHJvdXRlcyk7XG4gIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKTtcbiAgbGV0IG1hdGNoZXMgPSBudWxsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBtYXRjaGVzID09IG51bGwgJiYgaSA8IGJyYW5jaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgbWF0Y2hlcyA9IG1hdGNoUm91dGVCcmFuY2goYnJhbmNoZXNbaV0sIHBhdGhuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuUm91dGVzKHJvdXRlcywgYnJhbmNoZXMsIHBhcmVudHNNZXRhLCBwYXJlbnRQYXRoKSB7XG4gIGlmIChicmFuY2hlcyA9PT0gdm9pZCAwKSB7XG4gICAgYnJhbmNoZXMgPSBbXTtcbiAgfVxuXG4gIGlmIChwYXJlbnRzTWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50c01ldGEgPSBbXTtcbiAgfVxuXG4gIGlmIChwYXJlbnRQYXRoID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnRQYXRoID0gXCJcIjtcbiAgfVxuXG4gIHJvdXRlcy5mb3JFYWNoKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBsZXQgbWV0YSA9IHtcbiAgICAgIHJlbGF0aXZlUGF0aDogcm91dGUucGF0aCB8fCBcIlwiLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGVcbiAgICB9O1xuXG4gICAgaWYgKG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAhbWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChwYXJlbnRQYXRoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJBYnNvbHV0ZSByb3V0ZSBwYXRoIFxcXCJcIiArIG1ldGEucmVsYXRpdmVQYXRoICsgXCJcXFwiIG5lc3RlZCB1bmRlciBwYXRoIFwiICsgKFwiXFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggXCIpICsgXCJtdXN0IHN0YXJ0IHdpdGggdGhlIGNvbWJpbmVkIHBhdGggb2YgYWxsIGl0cyBwYXJlbnQgcm91dGVzLlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTsgLy8gQWRkIHRoZSBjaGlsZHJlbiBiZWZvcmUgYWRkaW5nIHRoaXMgcm91dGUgdG8gdGhlIGFycmF5IHNvIHdlIHRyYXZlcnNlIHRoZVxuICAgIC8vIHJvdXRlIHRyZWUgZGVwdGgtZmlyc3QgYW5kIGNoaWxkIHJvdXRlcyBhcHBlYXIgYmVmb3JlIHRoZWlyIHBhcmVudHMgaW5cbiAgICAvLyB0aGUgXCJmbGF0dGVuZWRcIiB2ZXJzaW9uLlxuXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICEocm91dGUuaW5kZXggIT09IHRydWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBcIiArIChcImFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCIuXCIpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICBmbGF0dGVuUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBicmFuY2hlcywgcm91dGVzTWV0YSwgcGF0aCk7XG4gICAgfSAvLyBSb3V0ZXMgd2l0aG91dCBhIHBhdGggc2hvdWxkbid0IGV2ZXIgbWF0Y2ggYnkgdGhlbXNlbHZlcyB1bmxlc3MgdGhleSBhcmVcbiAgICAvLyBpbmRleCByb3V0ZXMsIHNvIGRvbid0IGFkZCB0aGVtIHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGJyYW5jaGVzLlxuXG5cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJyYW5jaGVzLnB1c2goe1xuICAgICAgcGF0aCxcbiAgICAgIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLFxuICAgICAgcm91dGVzTWV0YVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGJyYW5jaGVzO1xufVxuXG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcykge1xuICBicmFuY2hlcy5zb3J0KChhLCBiKSA9PiBhLnNjb3JlICE9PSBiLnNjb3JlID8gYi5zY29yZSAtIGEuc2NvcmUgLy8gSGlnaGVyIHNjb3JlIGZpcnN0XG4gIDogY29tcGFyZUluZGV4ZXMoYS5yb3V0ZXNNZXRhLm1hcChtZXRhID0+IG1ldGEuY2hpbGRyZW5JbmRleCksIGIucm91dGVzTWV0YS5tYXAobWV0YSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpKSk7XG59XG5cbmNvbnN0IHBhcmFtUmUgPSAvXjpcXHcrJC87XG5jb25zdCBkeW5hbWljU2VnbWVudFZhbHVlID0gMztcbmNvbnN0IGluZGV4Um91dGVWYWx1ZSA9IDI7XG5jb25zdCBlbXB0eVNlZ21lbnRWYWx1ZSA9IDE7XG5jb25zdCBzdGF0aWNTZWdtZW50VmFsdWUgPSAxMDtcbmNvbnN0IHNwbGF0UGVuYWx0eSA9IC0yO1xuXG5jb25zdCBpc1NwbGF0ID0gcyA9PiBzID09PSBcIipcIjtcblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGgsIGluZGV4KSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBsZXQgaW5pdGlhbFNjb3JlID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuXG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHMuZmlsdGVyKHMgPT4gIWlzU3BsYXQocykpLnJlZHVjZSgoc2NvcmUsIHNlZ21lbnQpID0+IHNjb3JlICsgKHBhcmFtUmUudGVzdChzZWdtZW50KSA/IGR5bmFtaWNTZWdtZW50VmFsdWUgOiBzZWdtZW50ID09PSBcIlwiID8gZW1wdHlTZWdtZW50VmFsdWUgOiBzdGF0aWNTZWdtZW50VmFsdWUpLCBpbml0aWFsU2NvcmUpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhLCBiKSB7XG4gIGxldCBzaWJsaW5ncyA9IGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLnNsaWNlKDAsIC0xKS5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYltpXSk7XG4gIHJldHVybiBzaWJsaW5ncyA/IC8vIElmIHR3byByb3V0ZXMgYXJlIHNpYmxpbmdzLCB3ZSBzaG91bGQgdHJ5IHRvIG1hdGNoIHRoZSBlYXJsaWVyIHNpYmxpbmdcbiAgLy8gZmlyc3QuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBoYXZlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIG1hdGNoaW5nXG4gIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAvLyB3YW50IHRoZW0gdHJpZWQuXG4gIGFbYS5sZW5ndGggLSAxXSAtIGJbYi5sZW5ndGggLSAxXSA6IC8vIE90aGVyd2lzZSwgaXQgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZSB0byByYW5rIG5vbi1zaWJsaW5ncyBieSBpbmRleCxcbiAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gIDA7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2goYnJhbmNoLCBwYXRobmFtZSkge1xuICBsZXQge1xuICAgIHJvdXRlc01ldGFcbiAgfSA9IGJyYW5jaDtcbiAgbGV0IG1hdGNoZWRQYXJhbXMgPSB7fTtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IFwiL1wiO1xuICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCIgPyBwYXRobmFtZSA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aCh7XG4gICAgICBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVuZFxuICAgIH0sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgcGFyYW1zOiBtYXRjaGVkUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSksXG4gICAgICByb3V0ZVxuICAgIH0pO1xuXG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgcmVzdWx0IG9mIGBtYXRjaFJvdXRlcygpYCBpbnRvIGEgUmVhY3QgZWxlbWVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbmRlck1hdGNoZXMobWF0Y2hlcykge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG5cbmZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMsIHBhcmVudE1hdGNoZXMpIHtcbiAgaWYgKHBhcmVudE1hdGNoZXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmVudE1hdGNoZXMgPSBbXTtcbiAgfVxuXG4gIGlmIChtYXRjaGVzID09IG51bGwpIHJldHVybiBudWxsO1xuICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICBjaGlsZHJlbjogbWF0Y2gucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkID8gbWF0Y2gucm91dGUuZWxlbWVudCA6IC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KE91dGxldCwgbnVsbCksXG4gICAgICB2YWx1ZToge1xuICAgICAgICBvdXRsZXQsXG4gICAgICAgIG1hdGNoZXM6IHBhcmVudE1hdGNoZXMuY29uY2F0KG1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgbnVsbCk7XG59XG4vKipcbiAqIEEgUGF0aFBhdHRlcm4gaXMgdXNlZCB0byBtYXRjaCBvbiBzb21lIHBvcnRpb24gb2YgYSBVUkwgcGF0aG5hbWUuXG4gKi9cblxuXG4vKipcbiAqIFBlcmZvcm1zIHBhdHRlcm4gbWF0Y2hpbmcgb24gYSBVUkwgcGF0aG5hbWUgYW5kIHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHRoZSBtYXRjaC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI21hdGNocGF0aFxuICovXG5mdW5jdGlvbiBtYXRjaFBhdGgocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcGF0dGVybiA9IHtcbiAgICAgIHBhdGg6IHBhdHRlcm4sXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgIGVuZDogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBsZXQgW21hdGNoZXIsIHBhcmFtTmFtZXNdID0gY29tcGlsZVBhdGgocGF0dGVybi5wYXRoLCBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsIHBhdHRlcm4uZW5kKTtcbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gbWF0Y2hbMF07XG4gIGxldCBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICBsZXQgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnNsaWNlKDEpO1xuICBsZXQgcGFyYW1zID0gcGFyYW1OYW1lcy5yZWR1Y2UoKG1lbW8sIHBhcmFtTmFtZSwgaW5kZXgpID0+IHtcbiAgICAvLyBXZSBuZWVkIHRvIGNvbXB1dGUgdGhlIHBhdGhuYW1lQmFzZSBoZXJlIHVzaW5nIHRoZSByYXcgc3BsYXQgdmFsdWVcbiAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHBhcmFtc1tcIipcIl0gbGF0ZXIgYmVjYXVzZSBpdCB3aWxsIGJlIGRlY29kZWQgdGhlblxuICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICBsZXQgc3BsYXRWYWx1ZSA9IGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCI7XG4gICAgICBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUuc2xpY2UoMCwgbWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCAtIHNwbGF0VmFsdWUubGVuZ3RoKS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gICAgfVxuXG4gICAgbWVtb1twYXJhbU5hbWVdID0gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCIsIHBhcmFtTmFtZSk7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoZWRQYXRobmFtZSxcbiAgICBwYXRobmFtZUJhc2UsXG4gICAgcGF0dGVyblxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21waWxlUGF0aChwYXRoLCBjYXNlU2Vuc2l0aXZlLCBlbmQpIHtcbiAgaWYgKGNhc2VTZW5zaXRpdmUgPT09IHZvaWQgMCkge1xuICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChlbmQgPT09IHZvaWQgMCkge1xuICAgIGVuZCA9IHRydWU7XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHBhdGggPT09IFwiKlwiIHx8ICFwYXRoLmVuZHNXaXRoKFwiKlwiKSB8fCBwYXRoLmVuZHNXaXRoKFwiLypcIiksIFwiUm91dGUgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiICsgKFwiXFxcIlwiICsgcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSArIFwiXFxcIiBiZWNhdXNlIHRoZSBgKmAgY2hhcmFjdGVyIG11c3QgXCIpICsgXCJhbHdheXMgZm9sbG93IGEgYC9gIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgXCIgKyAoXCJwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIuXCIpKSA6IHZvaWQgMDtcbiAgbGV0IHBhcmFtTmFtZXMgPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9IFwiXlwiICsgcGF0aC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xuICAucmVwbGFjZSgvW1xcXFwuKiteJD97fXwoKVtcXF1dL2csIFwiXFxcXCQmXCIpIC8vIEVzY2FwZSBzcGVjaWFsIHJlZ2V4IGNoYXJzXG4gIC5yZXBsYWNlKC86KFxcdyspL2csIChfLCBwYXJhbU5hbWUpID0+IHtcbiAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW1OYW1lKTtcbiAgICByZXR1cm4gXCIoW15cXFxcL10rKVwiO1xuICB9KTtcblxuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikpIHtcbiAgICBwYXJhbU5hbWVzLnB1c2goXCIqXCIpO1xuICAgIHJlZ2V4cFNvdXJjZSArPSBwYXRoID09PSBcIipcIiB8fCBwYXRoID09PSBcIi8qXCIgPyBcIiguKikkXCIgLy8gQWxyZWFkeSBtYXRjaGVkIHRoZSBpbml0aWFsIC8sIGp1c3QgbWF0Y2ggdGhlIHJlc3RcbiAgICA6IFwiKD86XFxcXC8oLispfFxcXFwvKikkXCI7IC8vIERvbid0IGluY2x1ZGUgdGhlIC8gaW4gcGFyYW1zW1wiKlwiXVxuICB9IGVsc2Uge1xuICAgIHJlZ2V4cFNvdXJjZSArPSBlbmQgPyBcIlxcXFwvKiRcIiAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgOiAvLyBPdGhlcndpc2UsIG1hdGNoIGEgd29yZCBib3VuZGFyeSBvciBhIHByb2NlZWRpbmcgLy4gVGhlIHdvcmQgYm91bmRhcnkgcmVzdHJpY3RzXG4gICAgLy8gcGFyZW50IHJvdXRlcyB0byBtYXRjaGluZyBvbmx5IHRoZWlyIG93biB3b3JkcyBhbmQgbm90aGluZyBtb3JlLCBlLmcuIHBhcmVudFxuICAgIC8vIHJvdXRlIFwiL2hvbWVcIiBzaG91bGQgbm90IG1hdGNoIFwiL2hvbWUyXCIuXG4gICAgXCIoPzpcXFxcYnxcXFxcL3wkKVwiO1xuICB9XG5cbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IFwiaVwiKTtcbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbU5hbWVzXTtcbn1cblxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlLCBwYXJhbU5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIlRoZSB2YWx1ZSBmb3IgdGhlIFVSTCBwYXJhbSBcXFwiXCIgKyBwYXJhbU5hbWUgKyBcIlxcXCIgd2lsbCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlXCIgKyAoXCIgdGhlIHN0cmluZyBcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseVwiKSArIChcIiBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoXCIgKyBlcnJvciArIFwiKS5cIikpIDogdm9pZCAwO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcmVzb2x2ZXBhdGhcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvLCBmcm9tUGF0aG5hbWUpIHtcbiAgaWYgKGZyb21QYXRobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgZnJvbVBhdGhuYW1lID0gXCIvXCI7XG4gIH1cblxuICBsZXQge1xuICAgIHBhdGhuYW1lOiB0b1BhdGhuYW1lLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCJcbiAgfSA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZSA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lIDogcmVzb2x2ZVBhdGhuYW1lKHRvUGF0aG5hbWUsIGZyb21QYXRobmFtZSkgOiBmcm9tUGF0aG5hbWU7XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIC8vIEtlZXAgdGhlIHJvb3QgXCJcIiBzZWdtZW50IHNvIHRoZSBwYXRobmFtZSBzdGFydHMgYXQgL1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVG8odG9BcmcsIHJvdXRlUGF0aG5hbWVzLCBsb2NhdGlvblBhdGhuYW1lKSB7XG4gIGxldCB0byA9IHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0b0FyZykgOiB0b0FyZztcbiAgbGV0IHRvUGF0aG5hbWUgPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIiA/IFwiL1wiIDogdG8ucGF0aG5hbWU7IC8vIElmIGEgcGF0aG5hbWUgaXMgZXhwbGljaXRseSBwcm92aWRlZCBpbiBgdG9gLCBpdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlXG4gIC8vIHJvdXRlIGNvbnRleHQuIFRoaXMgaXMgZXhwbGFpbmVkIGluIGBOb3RlIG9uIGA8TGluayB0bz5gIHZhbHVlc2AgaW4gb3VyXG4gIC8vIG1pZ3JhdGlvbiBndWlkZSBmcm9tIHY1IGFzIGEgbWVhbnMgb2YgZGlzYW1iaWd1YXRpb24gYmV0d2VlbiBgdG9gIHZhbHVlc1xuICAvLyB0aGF0IGJlZ2luIHdpdGggYC9gIGFuZCB0aG9zZSB0aGF0IGRvIG5vdC4gSG93ZXZlciwgdGhpcyBpcyBwcm9ibGVtYXRpYyBmb3JcbiAgLy8gYHRvYCB2YWx1ZXMgdGhhdCBkbyBub3QgcHJvdmlkZSBhIHBhdGhuYW1lLiBgdG9gIGNhbiBzaW1wbHkgYmUgYSBzZWFyY2ggb3JcbiAgLy8gaGFzaCBzdHJpbmcsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBuYXZpZ2F0aW9uIGlzIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uJ3MgcGF0aG5hbWUgYW5kICpub3QqIHRoZSByb3V0ZSBwYXRobmFtZS5cblxuICBsZXQgZnJvbTtcblxuICBpZiAodG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAodG9QYXRobmFtZS5zdGFydHNXaXRoKFwiLi5cIikpIHtcbiAgICAgIGxldCB0b1NlZ21lbnRzID0gdG9QYXRobmFtZS5zcGxpdChcIi9cIik7IC8vIEVhY2ggbGVhZGluZyAuLiBzZWdtZW50IG1lYW5zIFwiZ28gdXAgb25lIHJvdXRlXCIgaW5zdGVhZCBvZiBcImdvIHVwIG9uZVxuICAgICAgLy8gVVJMIHNlZ21lbnRcIi4gIFRoaXMgaXMgYSBrZXkgZGlmZmVyZW5jZSBmcm9tIGhvdyA8YSBocmVmPiB3b3JrcyBhbmQgYVxuICAgICAgLy8gbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhIFwidG9cIiB2YWx1ZSBpbnN0ZWFkIG9mIGEgXCJocmVmXCIuXG5cbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH0gLy8gSWYgdGhlcmUgYXJlIG1vcmUgXCIuLlwiIHNlZ21lbnRzIHRoYW4gcGFyZW50IHJvdXRlcywgcmVzb2x2ZSByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSByb290IC8gVVJMLlxuXG5cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cblxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTsgLy8gRW5zdXJlIHRoZSBwYXRobmFtZSBoYXMgYSB0cmFpbGluZyBzbGFzaCBpZiB0aGUgb3JpZ2luYWwgdG8gdmFsdWUgaGFkIG9uZS5cblxuICBpZiAodG9QYXRobmFtZSAmJiB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJiAhcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGdldFRvUGF0aG5hbWUodG8pIHtcbiAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyAvIHBhdGhzXG4gIHJldHVybiB0byA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIiA/IFwiL1wiIDogdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKS5wYXRobmFtZSA6IHRvLnBhdGhuYW1lO1xufVxuXG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSByZXR1cm4gcGF0aG5hbWU7XG5cbiAgaWYgKCFwYXRobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYmFzZW5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBuZXh0Q2hhciA9IHBhdGhuYW1lLmNoYXJBdChiYXNlbmFtZS5sZW5ndGgpO1xuXG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKGJhc2VuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG59XG5cbmNvbnN0IGpvaW5QYXRocyA9IHBhdGhzID0+IHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuXG5jb25zdCBub3JtYWxpemVQYXRobmFtZSA9IHBhdGhuYW1lID0+IHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG5cbmNvbnN0IG5vcm1hbGl6ZVNlYXJjaCA9IHNlYXJjaCA9PiAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCIgPyBcIlwiIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG5cbmNvbnN0IG5vcm1hbGl6ZUhhc2ggPSBoYXNoID0+ICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCB7IE1lbW9yeVJvdXRlciwgTmF2aWdhdGUsIE91dGxldCwgUm91dGUsIFJvdXRlciwgUm91dGVzLCBMb2NhdGlvbkNvbnRleHQgYXMgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCwgTmF2aWdhdGlvbkNvbnRleHQgYXMgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LCBSb3V0ZUNvbnRleHQgYXMgVU5TQUZFX1JvdXRlQ29udGV4dCwgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLCBnZW5lcmF0ZVBhdGgsIG1hdGNoUGF0aCwgbWF0Y2hSb3V0ZXMsIHJlbmRlck1hdGNoZXMsIHJlc29sdmVQYXRoLCB1c2VIcmVmLCB1c2VJblJvdXRlckNvbnRleHQsIHVzZUxvY2F0aW9uLCB1c2VNYXRjaCwgdXNlTmF2aWdhdGUsIHVzZU5hdmlnYXRpb25UeXBlLCB1c2VPdXRsZXQsIHVzZU91dGxldENvbnRleHQsIHVzZVBhcmFtcywgdXNlUmVzb2x2ZWRQYXRoLCB1c2VSb3V0ZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9